[
  {
    "edicao": 2024,
    "id": "2024-28",
    "numero": 28,
    "enunciado": "A ponte norte e a ponte sul sÃ£o chipsets que compÃµem a estrutura de uma\nplaca-mÃ£e de um computador. Sobre esses dois chipsets, analise as assertivas abaixo:\n- I. A ponte norte Ã© responsÃ¡vel pela comunicaÃ§Ã£o entre o processador e dispositivos de entrada/saÃ­da\nde baixa velocidade, enquanto a ponte sul conecta a memÃ³ria RAM e a placa de vÃ­deo.\n- II. A ponte sul conecta o processador diretamente Ã  memÃ³ria RAM e Ã  placa de vÃ­deo, enquanto a\nponte norte lida com dispositivos de armazenamento e perifÃ©ricos de entrada/saÃ­da.\n- III. A ponte norte faz a interface entre o processador e componentes de alta velocidade como a\nmemÃ³ria RAM e a placa de vÃ­deo, enquanto a ponte sul gerencia conexÃµes com dispositivos de\nentrada/saÃ­da de menor velocidade.\n- IV. A ponte norte e a ponte sul sÃ£o substituÃ­veis e podem ser usadas indistintamente em qualquer funÃ§Ã£o dentro do sistema de barramento do computador.\n\nQuais estÃ£o corretas?",
    "alternativas": [
      "a) Apenas I.",
      "b) Apenas II.",
      "c) Apenas III.",
      "d) Apenas I e II.",
      "e) Apenas III e IV."
    ],
    "area_conhecimento": "Fundamentos da ComputaÃ§Ã£o",
    "area": "Arquitetura e OrganizaÃ§Ã£o de Computadores",
    "subarea": "OrganizaÃ§Ã£o de Computadores",
    "dificuldade": "FÃ¡cil",
    "gabarito": "C",
    "solucao": "Para resolver a questÃ£o, Ã© necessÃ¡rio entender as funÃ§Ãµes da ponte norte e da ponte sul em uma placa-mÃ£e de computador. A ponte norte Ã© responsÃ¡vel por conectar o processador a componentes de alta velocidade, como a memÃ³ria RAM e a placa de vÃ­deo. JÃ¡ a ponte sul gerencia conexÃµes com dispositivos de entrada/saÃ­da de menor velocidade, como portas USB, discos rÃ­gidos e outros perifÃ©ricos. \n\nAnalisando as assertivas: \n\nI. Incorreta. A descriÃ§Ã£o das funÃ§Ãµes da ponte norte e da ponte sul estÃ¡ trocada. A ponte norte nÃ£o Ã© responsÃ¡vel por dispositivos de baixa velocidade, e a ponte sul nÃ£o conecta a memÃ³ria RAM e a placa de vÃ­deo. \n\nII. Incorreta. A ponte sul nÃ£o conecta o processador diretamente Ã  memÃ³ria RAM e Ã  placa de vÃ­deo. Essa Ã© a funÃ§Ã£o da ponte norte. \n\nIII. Correta. A ponte norte faz a interface entre o processador e componentes de alta velocidade, como a memÃ³ria RAM e a placa de vÃ­deo, enquanto a ponte sul gerencia conexÃµes com dispositivos de entrada/saÃ­da de menor velocidade. \n\nIV. Incorreta. A ponte norte e a ponte sul tÃªm funÃ§Ãµes especÃ­ficas e nÃ£o sÃ£o substituÃ­veis ou intercambiÃ¡veis. \n\nPortanto, a Ãºnica assertiva correta Ã© a III."
  },
  {
    "edicao": 2024,
    "id": "2024-36",
    "numero": 36,
    "enunciado": "Qual das seguintes linguagens pode ser gerada por uma gramÃ¡tica regular?",
    "alternativas": [
      "a) {w âˆˆ {a, b}* | o nÃºmero de aâ€™s em w Ã© maior que o nÃºmero de bâ€™s}.",
      "b) {w âˆˆ {a, b}* | o nÃºmero de aâ€™s em w Ã© o dobro do nÃºmero de bâ€™s}.",
      "c) {w âˆˆ {a, b}* | o nÃºmero de aâ€™s em w Ã© divisÃ­vel por 3 e o nÃºmero de bâ€™s Ã© Ã­mpar}.",
      "d) {w âˆˆ {a, b}* | w contÃ©m o mesmo nÃºmero de aâ€™s e bâ€™s}.",
      "e) {w âˆˆ {a, b}* | w contÃ©m nÃºmeros diferentes de aâ€™s e bâ€™s}."
    ],
    "area_conhecimento": "Fundamentos da ComputaÃ§Ã£o",
    "area": "Linguagens Formais, AutÃ´matos e Computabilidade",
    "subarea": "Linguagens Regulares",
    "dificuldade": "MÃ©dia",
    "gabarito": "E",
    "solucao": "Uma gramÃ¡tica regular Ã© capaz de gerar linguagens que podem ser reconhecidas por autÃ´matos finitos. As linguagens regulares sÃ£o fechadas sob operaÃ§Ãµes como uniÃ£o, concatenaÃ§Ã£o e estrela de Kleene, mas nÃ£o conseguem expressar relaÃ§Ãµes numÃ©ricas complexas entre sÃ­mbolos, como igualdade ou mÃºltiplos. Vamos analisar cada alternativa:\n\nA) {w âˆˆ {a, b}* | o nÃºmero de aâ€™s em w Ã© maior que o nÃºmero de bâ€™s}. Esta linguagem nÃ£o Ã© regular, pois requer a comparaÃ§Ã£o entre contagens de sÃ­mbolos, o que nÃ£o pode ser feito por autÃ´matos finitos.\n\nB) {w âˆˆ {a, b}* | o nÃºmero de aâ€™s em w Ã© o dobro do nÃºmero de bâ€™s}. Esta linguagem tambÃ©m nÃ£o Ã© regular, pois exige uma relaÃ§Ã£o numÃ©rica precisa entre os sÃ­mbolos, algo que autÃ´matos finitos nÃ£o conseguem verificar.\n\nC) {w âˆˆ {a, b}* | o nÃºmero de aâ€™s em w Ã© divisÃ­vel por 3 e o nÃºmero de bâ€™s Ã© Ã­mpar}. Esta linguagem nÃ£o Ã© regular, pois combina duas condiÃ§Ãµes que nÃ£o podem ser verificadas simultaneamente por um autÃ´mato finito.\n\nD) {w âˆˆ {a, b}* | w contÃ©m o mesmo nÃºmero de aâ€™s e bâ€™s}. Esta linguagem nÃ£o Ã© regular, pois requer a contagem e comparaÃ§Ã£o exata de dois tipos de sÃ­mbolos, algo que autÃ´matos finitos nÃ£o conseguem fazer.\n\nE) {w âˆˆ {a, b}* | w contÃ©m nÃºmeros diferentes de aâ€™s e bâ€™s}. Esta linguagem Ã© regular, pois pode ser expressa por um autÃ´mato finito que aceita qualquer string que nÃ£o tenha o mesmo nÃºmero de 'a's e 'b's, o que Ã© possÃ­vel sem a necessidade de contagem precisa, apenas verificando que a string nÃ£o pertence ao conjunto de strings com nÃºmeros iguais de 'a's e 'b's."
  },
  {
    "edicao": 2023,
    "id": "2023-15",
    "numero": 15,
    "enunciado": "A expressÃ£o lÃ³gica pâ†’q Ã© equivalente a:",
    "alternativas": [
      "a) ~pâˆ§~q",
      "b) ~pâ†’q",
      "c) pâ†’~q",
      "d) ~q->~p",
      "e) qâ†’p"
    ],
    "area_conhecimento": "MatemÃ¡tica",
    "area": "LÃ³gica MatemÃ¡tica",
    "subarea": "LÃ³gica Proposicional e de Predicados",
    "dificuldade": "FÃ¡cil",
    "gabarito": "D",
    "solucao": "A expressÃ£o lÃ³gica pâ†’q (p implica q) Ã© equivalente Ã  expressÃ£o ~qâ†’~p (negaÃ§Ã£o de q implica negaÃ§Ã£o de p), que Ã© a forma contrÃ¡ria da implicaÃ§Ã£o original. Essa equivalÃªncia Ã© conhecida como contrapositiva. A contrapositiva de uma implicaÃ§Ã£o Ã© sempre logicamente equivalente Ã  implicaÃ§Ã£o original. Portanto, a alternativa correta Ã© D) ~q->~p."
  },
  {
    "edicao": 2023,
    "id": "2023-18",
    "numero": 18,
    "enunciado": "Usando os conjuntos de dados A = {1, 4, 2, 6, 8, 10}, B = {1, 4, 6, 10},\nC = {6, 4, 1, 10}, D = {6, 4, 1}, qual das seguintes alternativas Ã© INCORRETA?",
    "alternativas": [
      "a) \\(A âŠ† B\\)",
      "b) \\(D âŠ† A\\)",
      "c) \\(B = C\\)",
      "d) \\(B âŠ† A\\)",
      "e) \\(A â‰  B\\)"
    ],
    "area_conhecimento": "MatemÃ¡tica",
    "area": "MatemÃ¡tica Discreta",
    "subarea": "Conjuntos e Ãlgebra de Conjuntos como Teoria AxiomÃ¡tica",
    "dificuldade": "FÃ¡cil",
    "gabarito": "A",
    "solucao": "Para determinar qual alternativa Ã© incorreta, precisamos analisar cada uma delas:\n\nA) A âŠ† B: O conjunto A = {1, 4, 2, 6, 8, 10} nÃ£o Ã© subconjunto de B = {1, 4, 6, 10} porque A contÃ©m os elementos 2 e 8, que nÃ£o estÃ£o em B. Portanto, esta alternativa Ã© INCORRETA.\n\nB) D âŠ† A: O conjunto D = {6, 4, 1} Ã© um subconjunto de A = {1, 4, 2, 6, 8, 10} porque todos os elementos de D estÃ£o em A. Portanto, esta alternativa Ã© CORRETA.\n\nC) B = C: O conjunto B = {1, 4, 6, 10} Ã© igual ao conjunto C = {6, 4, 1, 10} porque ambos contÃªm os mesmos elementos, apenas em ordem diferente. Portanto, esta alternativa Ã© CORRETA.\n\nD) B âŠ† A: O conjunto B = {1, 4, 6, 10} Ã© um subconjunto de A = {1, 4, 2, 6, 8, 10} porque todos os elementos de B estÃ£o em A. Portanto, esta alternativa Ã© CORRETA.\n\nE) A â‰  B: O conjunto A = {1, 4, 2, 6, 8, 10} Ã© diferente de B = {1, 4, 6, 10} porque A contÃ©m elementos (2 e 8) que nÃ£o estÃ£o em B. Portanto, esta alternativa Ã© CORRETA.\n\nPortanto, a alternativa INCORRETA Ã© a A."
  },
  {
    "edicao": 2023,
    "id": "2023-25",
    "numero": 25,
    "enunciado": "Sobre as Ã¡rvores binÃ¡rias de busca, Ã© correto afirmar que:",
    "alternativas": [
      "a) Seja x um nÃ³ em uma Ã¡rvore de busca binÃ¡ria. Se y Ã© um nÃ³ na subÃ¡rvore esquerda de x, entÃ£o\ny.chave ï‚³ x.chave. Se y Ã© um nÃ³ na subÃ¡rvore direita de x, entÃ£o x.chave ï‚£ y.chave.",
      "b) A propriedade de Ã¡rvore de busca que permite imprimir todas as chaves em sequÃªncia ordenada\npor meio de um simples algoritmo recursivo Ã© denominada percurso de Ã¡rvore em prÃ© -ordem.",
      "c) Para excluir um nÃ³ z de uma Ã¡rvore de busca binÃ¡ria T, se z tem apenas um filho, entÃ£o\nsimplesmente o removemos modificando seu pai de modo a substituir z por NIL como seu filho.",
      "d) Para excluir um nÃ³ z de uma Ã¡rvore de busca binÃ¡ria T, se z tem dois filhos, entÃ£o elevamos o\nprimeiro filho para que ocupe a posiÃ§Ã£o de z na Ã¡rvore modificando o pai de z de modo a substituir\nz pelo filho de z.",
      "e) Para encontrar um nÃ³ em uma Ã¡rvore de busca binÃ¡ria cuja chave Ã© um mÃ­nimo, deve -se seguir\nos ponteiros de filhos da esquerda desde a raiz atÃ© encontrar um valor NIL."
    ],
    "area_conhecimento": "Fundamentos da ComputaÃ§Ã£o",
    "area": "Algoritmos e Estrutura de Dados",
    "subarea": "Ãrvores de Busca e Ãrvores Balanceadas",
    "dificuldade": "MÃ©dia",
    "gabarito": "E",
    "solucao": "A questÃ£o trata das propriedades e operaÃ§Ãµes em Ã¡rvores binÃ¡rias de busca (BST). Vamos analisar cada alternativa: \n\nA) A descriÃ§Ã£o estÃ¡ incorreta. Em uma Ã¡rvore binÃ¡ria de busca, para qualquer nÃ³ x, todos os nÃ³s na subÃ¡rvore esquerda de x tÃªm valores menores que x.chave, e todos os nÃ³s na subÃ¡rvore direita de x tÃªm valores maiores que x.chave. Portanto, a relaÃ§Ã£o correta seria y.chave â‰¤ x.chave para a subÃ¡rvore esquerda e x.chave â‰¤ y.chave para a subÃ¡rvore direita.\n\nB) O percurso que imprime as chaves em ordem crescente em uma Ã¡rvore binÃ¡ria de busca Ã© o percurso em ordem (in-order traversal), nÃ£o o percurso em prÃ©-ordem.\n\nC) Quando um nÃ³ z com apenas um filho Ã© removido de uma Ã¡rvore binÃ¡ria de busca, o filho de z substitui z, nÃ£o Ã© substituÃ­do por NIL.\n\nD) Se um nÃ³ z tem dois filhos, o procedimento correto Ã© substituir z pelo seu sucessor ou predecessor na Ã¡rvore (geralmente o menor nÃ³ na subÃ¡rvore direita ou o maior na subÃ¡rvore esquerda), nÃ£o simplesmente elevar o primeiro filho.\n\nE) Para encontrar o nÃ³ com a chave mÃ­nima em uma Ã¡rvore binÃ¡ria de busca, deve-se seguir os ponteiros de filhos Ã  esquerda desde a raiz atÃ© encontrar um nÃ³ sem filho Ã  esquerda (NIL). Esta afirmaÃ§Ã£o estÃ¡ correta."
  },
  {
    "edicao": 2023,
    "id": "2023-38",
    "numero": 38,
    "enunciado": "Dada a linguagem ð¿ = {ð‘¤ âˆˆ {ð‘Ž, ð‘}âˆ— | ð‘œ ð‘¡ð‘’ð‘Ÿð‘ð‘’ð‘–ð‘Ÿð‘œ Ãºð‘™ð‘¡ð‘–ð‘šð‘œ ð‘ Ã­ð‘šð‘ð‘œð‘™ð‘œ ð‘‘ð‘’ ð‘¤ Ã© ð‘Ž}, analise as\nassertivas abaixo, assinalando V, se verdadeiras, ou F, se falsas.\n( ) O menor AutÃ´mato Finito NÃ£o DeterminÃ­stico (AFND) que reconhece L tem 4 (quatro) estados.\n( ) O AutÃ´mato Finito DeterminÃ­stico (AFD) que reconhece L tem, no mÃ­nimo, 8 (oito) estados.\n( ) A menor GramÃ¡tica Regular (GR) que gera L tem 3 (trÃªs) nÃ£o terminais.\n( ) O conjunto regular {ð‘Ž, ð‘}âˆ—{ð‘Ž}{ð‘Ž, ð‘}{ð‘Ž, ð‘} denota L.\nA ordem correta de preenchimento dos parÃªnteses, de cima para baixo, Ã©:",
    "alternativas": [
      "a) F â€“ F â€“ V â€“ V.",
      "b) V â€“ V â€“ V â€“ V.",
      "c) F â€“ V â€“ F â€“ V.",
      "d) V â€“ V â€“ F â€“ F.",
      "e) V â€“ F â€“ V â€“ F."
    ],
    "area_conhecimento": "Fundamentos da ComputaÃ§Ã£o",
    "area": "Linguagens Formais, AutÃ´matos e Computabilidade",
    "subarea": "AutÃ´matos de Estados Finitos DeterminÃ­stico e nÃ£o DeterminÃ­stico",
    "dificuldade": "MÃ©dia",
    "gabarito": "C",
    "solucao": "Para resolver a questÃ£o, precisamos analisar cada uma das assertivas sobre a linguagem L = {w âˆˆ {a, b}* | o terceiro Ãºltimo sÃ­mbolo de w Ã© a}.\n\n1. **AFND com 4 estados**: Um AFND que reconhece L pode ser construÃ­do com 4 estados. O autÃ´mato pode ser projetado para verificar se o terceiro Ãºltimo sÃ­mbolo Ã© 'a' ao ler a string de trÃ¡s para frente, usando nÃ£o determinismo para adivinhar o ponto de verificaÃ§Ã£o. Portanto, esta assertiva Ã© falsa.\n\n2. **AFD com no mÃ­nimo 8 estados**: A construÃ§Ã£o de um AFD a partir de um AFND geralmente resulta em um aumento no nÃºmero de estados devido Ã  eliminaÃ§Ã£o do nÃ£o determinismo. Para L, um AFD precisa manter o controle dos Ãºltimos trÃªs sÃ­mbolos lidos, o que resulta em 2^3 = 8 combinaÃ§Ãµes possÃ­veis de estados (considerando que cada sÃ­mbolo pode ser 'a' ou 'b'). Portanto, esta assertiva Ã© verdadeira.\n\n3. **GramÃ¡tica Regular com 3 nÃ£o terminais**: A gramÃ¡tica regular que gera L precisa ser capaz de produzir strings onde o terceiro Ãºltimo sÃ­mbolo Ã© 'a'. Isso pode ser feito com uma gramÃ¡tica que usa 3 nÃ£o terminais para controlar a posiÃ§Ã£o dos Ãºltimos trÃªs sÃ­mbolos, mas Ã© possÃ­vel construir uma gramÃ¡tica com menos nÃ£o terminais. Portanto, esta assertiva Ã© falsa.\n\n4. **Conjunto regular {a, b}*{a}{a, b}{a, b} denota L**: Este conjunto regular denota strings onde o terceiro Ãºltimo sÃ­mbolo Ã© 'a', seguido por qualquer combinaÃ§Ã£o de dois sÃ­mbolos. Isso corresponde exatamente Ã  definiÃ§Ã£o de L, tornando esta assertiva verdadeira.\n\nCom base na anÃ¡lise acima, a ordem correta das assertivas Ã© F â€“ V â€“ F â€“ V, que corresponde Ã  alternativa C."
  },
  {
    "edicao": 2022,
    "id": "2022-09",
    "numero": 9,
    "enunciado": "Se A e B sÃ£o dois conjuntos finitos, realize a reduÃ§Ã£o de ð¸ = {ð´ âˆ© (ð´ âˆª ðµâ€² )} âˆ’ ðµâ€².",
    "alternativas": [
      "a) A",
      "b) B",
      "c) ð´ âˆ© ðµ",
      "d) ð´ âˆª ðµ",
      "e) Bâ€™"
    ],
    "area_conhecimento": "MatemÃ¡tica",
    "area": "MatemÃ¡tica Discreta",
    "subarea": "Conjuntos e Ãlgebra de Conjuntos como Teoria AxiomÃ¡tica",
    "dificuldade": "FÃ¡cil",
    "gabarito": "A",
    "solucao": "Para resolver a expressÃ£o dada, ð¸ = {ð´ âˆ© (ð´ âˆª ðµâ€² )} âˆ’ ðµâ€², devemos simplificar passo a passo: \n1. Primeiro, consideramos a expressÃ£o dentro das chaves: ð´ âˆ© (ð´ âˆª ðµâ€²). \n2. Pela propriedade de absorÃ§Ã£o dos conjuntos, sabemos que ð´ âˆ© (ð´ âˆª ðµâ€²) Ã© equivalente a ð´, pois a interseÃ§Ã£o de A com qualquer conjunto que contenha A Ã© o prÃ³prio A. \n3. Assim, a expressÃ£o se reduz a ð¸ = ð´ âˆ’ ðµâ€². \n4. O conjunto ð´ âˆ’ ðµâ€² Ã© o conjunto de elementos que estÃ£o em A, mas nÃ£o estÃ£o em Bâ€². \n5. Como Bâ€² Ã© o complemento de B, ð´ âˆ’ ðµâ€² Ã© simplesmente A, pois A jÃ¡ nÃ£o contÃ©m elementos de Bâ€² (por definiÃ§Ã£o de complemento). \nPortanto, a expressÃ£o se reduz a A, e a alternativa correta Ã© A) A."
  },
  {
    "edicao": 2022,
    "id": "2022-15",
    "numero": 15,
    "enunciado": "Dado duas proposiÃ§Ãµes lÃ³gicas q e p.\nA proposiÃ§Ã£o lÃ³gica ~p-> q Ã© falsa se, e somente se, quando a proposiÃ§Ã£o abaixo for verdadeira:",
    "alternativas": [
      "a) p ou q",
      "b) ~p",
      "c) ~( p ou q)",
      "d) ~( p e q)",
      "e) ~q"
    ],
    "area_conhecimento": "MatemÃ¡tica",
    "area": "LÃ³gica MatemÃ¡tica",
    "subarea": "LÃ³gica Proposicional e de Predicados",
    "dificuldade": "FÃ¡cil",
    "gabarito": "E",
    "solucao": "Para determinar quando a proposiÃ§Ã£o ~p -> q Ã© falsa, devemos lembrar que uma implicaÃ§Ã£o lÃ³gica A -> B Ã© falsa somente quando A Ã© verdadeira e B Ã© falsa. No caso de ~p -> q, a proposiÃ§Ã£o ~p Ã© a antecedente (A) e q Ã© a consequente (B). Assim, ~p -> q Ã© falsa quando ~p Ã© verdadeira e q Ã© falsa. Se ~p Ã© verdadeira, entÃ£o p Ã© falsa. Portanto, para que ~p -> q seja falsa, p deve ser falsa e q deve ser falsa. Isso significa que a proposiÃ§Ã£o q deve ser falsa, o que corresponde Ã  alternativa E) ~q."
  },
  {
    "edicao": 2019,
    "id": "2019-15",
    "numero": 15,
    "enunciado": "A expressÃ£o lÃ³gica ~ð‘ž â†’ ~ð‘ Ã© equivalente a:",
    "alternativas": [
      "a) ~ ð‘ âˆ§ ~ð‘ž",
      "b) ~ð‘ âˆ¨ ð‘ž",
      "c) ~ð‘ â†’ ð‘ž",
      "d) ð‘ â†’ ~ ð‘ž",
      "e) ð‘ž â†’ ð‘"
    ],
    "area_conhecimento": "MatemÃ¡tica",
    "area": "LÃ³gica MatemÃ¡tica",
    "subarea": "LÃ³gica Proposicional e de Predicados",
    "dificuldade": "FÃ¡cil",
    "gabarito": "B",
    "solucao": "Para resolver a questÃ£o, precisamos entender a equivalÃªncia lÃ³gica da expressÃ£o dada: ~ð‘ž â†’ ~ð‘. Usando a equivalÃªncia lÃ³gica, sabemos que uma implicaÃ§Ã£o ð‘Ž â†’ ð‘ Ã© logicamente equivalente a ~ð‘Ž âˆ¨ ð‘. Portanto, a expressÃ£o ~ð‘ž â†’ ~ð‘ Ã© equivalente a ~~ð‘ž âˆ¨ ~ð‘. Como a dupla negaÃ§Ã£o ~~ð‘ž Ã© equivalente a ð‘ž, a expressÃ£o se simplifica para ð‘ž âˆ¨ ~ð‘. No entanto, a ordem dos termos em uma disjunÃ§Ã£o nÃ£o altera o valor lÃ³gico, entÃ£o podemos reescrever como ~ð‘ âˆ¨ ð‘ž. Assim, a alternativa correta Ã© B) ~ð‘ âˆ¨ ð‘ž."
  },
  {
    "edicao": 2019,
    "id": "2019-40",
    "numero": 40,
    "enunciado": "Considere as seguintes afirmaÃ§Ãµes sobre classes de problemas:\\\n- I. O problema de decisÃ£o CAM, descrito a seguir, pertence Ã  classe de complexidade P. CAM (caminho em grafo)\\\nEntrada: uma tripla \\((G,a,b)\\) em que \n- G Ã© um grafo\n- a e b sÃ£o nodos de G\nPergunta: Existe caminho em G iniciando em a e terminando em b?\n- II. Um problema X pertence Ã  classe de problemas NP-completos quando satisfaz Ã s seguintes\ncondiÃ§Ãµes:\n- X pertence Ã  classe NP, e\n- todo problema Y da classe NP pode ser reduzido em tempo polinomial a X.\n- III. Se um problema de decisÃ£o X pertence Ã  classe P, entÃ£o o complemento do problema X (problema com as mesmas instÃ¢ncias que X, porÃ©m com as respectivas respostas invertidas) pertence Ã  classe NP.\\\nQuais estÃ£o corretas?",
    "alternativas": [
      "a) Apenas I.",
      "b) Apenas III.",
      "c) Apenas I e II.",
      "d) Apenas II e III.",
      "e) I, II e III."
    ],
    "area_conhecimento": "Fundamentos da ComputaÃ§Ã£o",
    "area": "Linguagens Formais, AutÃ´matos e Computabilidade",
    "subarea": "Classes de Problemas P, NP, NP Completo e NP-DifÃ­cil",
    "dificuldade": "MÃ©dia",
    "gabarito": "C",
    "solucao": "Vamos analisar cada uma das afirmaÃ§Ãµes: \n\nI. O problema CAM (caminho em grafo) Ã© um problema de decisÃ£o que pergunta se existe um caminho entre dois nÃ³s em um grafo. Este problema pode ser resolvido utilizando algoritmos de busca em largura (BFS) ou busca em profundidade (DFS), ambos com complexidade polinomial em relaÃ§Ã£o ao nÃºmero de vÃ©rtices e arestas do grafo. Portanto, a afirmaÃ§Ã£o I estÃ¡ correta, pois CAM pertence Ã  classe P.\n\nII. A definiÃ§Ã£o de um problema NP-completo Ã© que ele deve pertencer Ã  classe NP e que todo problema na classe NP deve ser redutÃ­vel a ele em tempo polinomial. A afirmaÃ§Ã£o II estÃ¡ correta, pois descreve precisamente a definiÃ§Ã£o de NP-completude.\n\nIII. Se um problema de decisÃ£o X pertence Ã  classe P, entÃ£o ele pode ser resolvido em tempo polinomial. O complemento de X, que inverte as respostas, nÃ£o necessariamente pertence Ã  classe NP, a menos que P = NP. Portanto, a afirmaÃ§Ã£o III estÃ¡ incorreta, pois nÃ£o hÃ¡ garantia de que o complemento de um problema em P esteja em NP.\n\nAssim, as afirmaÃ§Ãµes corretas sÃ£o I e II, o que nos leva Ã  alternativa C."
  },
  {
    "edicao": 2019,
    "id": "2019-51",
    "numero": 51,
    "enunciado": "Sobre o controle de concorrÃªncia baseado na ordenaÃ§Ã£o de timestamp (rÃ³tulo de\ntempo), considere r_ts(x) e w_ts(x) os timestamps da Ãºltima transaÃ§Ã£o a ler e a gravar o item de\ndados x, respectivamente. Considere que a transaÃ§Ã£o T, cujo timestamp Ã© ts(T), precisa gravar o item\nde dados x, ou seja, T emite a operaÃ§Ã£o write(x). Conforme o algoritmo de ordenaÃ§Ã£o baseada em\ntimestamp bÃ¡sica, para que as transaÃ§Ãµes sejam serializÃ¡veis em conflito sem que haja o aborto e o\nreinÃ­cio de T, o seguinte predicado precisa ser verdadeiro:",
    "alternativas": [
      "a) (r_ts(x) > ts(T)) or (w_ts(x) > ts(T))",
      "b) (r_ts(x) > ts(T)) and (w_ts(x) > ts(T))",
      "c) (not (r_ts(x) > ts(T))) or (w_ts(x) > ts(T))",
      "d) (not (r_ts(x) > ts(T))) or (not (w_ts(x) > ts(T)))",
      "e) (not (r_ts(x) > ts(T))) and not ((w_ts(x) > ts(T)))"
    ],
    "area_conhecimento": "Tecnologia de ComputaÃ§Ã£o",
    "area": "Banco de Dados",
    "subarea": "Sistemas de Gerenciamento de Bancos de Dados (SGBD): Arquitetura, SeguranÃ§a, Integridade, ConcorrÃªncia, RecuperaÃ§Ã£o apÃ³s Falha, Gerenciamento de TransaÃ§Ãµes",
    "dificuldade": "MÃ©dia",
    "gabarito": "E",
    "solucao": "O controle de concorrÃªncia baseado em timestamps garante que as transaÃ§Ãµes sejam serializÃ¡veis em ordem de tempo. Para que uma transaÃ§Ã£o T com timestamp ts(T) possa escrever no item de dados x sem ser abortada, ela deve garantir que nenhuma transaÃ§Ã£o mais recente tenha lido ou escrito em x. Isso significa que ts(T) deve ser maior ou igual ao r_ts(x) e w_ts(x). A condiÃ§Ã£o correta Ã© que nem r_ts(x) nem w_ts(x) sejam maiores que ts(T), ou seja, (not (r_ts(x) > ts(T))) and (not (w_ts(x) > ts(T))). Portanto, a alternativa correta Ã© E."
  }
]
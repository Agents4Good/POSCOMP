[
  {
    "edicao": 2018,
    "id": "2018-11",
    "numero": 11,
    "enunciado": "Considere a proposi√ß√£o abaixo:\n‚ÄúEm toda turma da minha universidade, existe pelo menos um aluno canhoto.‚Äù\nA nega√ß√£o da proposi√ß√£o acima √© logicamente equivalente √† proposi√ß√£o:",
    "alternativas": [
      "a) Existe uma turma na minha universidade na qual h√°, no m√°ximo, um aluno canhoto.",
      "b) H√°, pelo menos, uma turma da minha universidade na qual n√£o existe aluno canhoto.",
      "c) N√£o h√° turma na minha universidade na qual todos os alunos sejam canhotos.",
      "d) Em cada uma das turmas da minha universidade, n√£o h√° aluno algum que seja canhoto.",
      "e) Em nenhuma turma da minha universidade, h√° algum aluno que seja canhoto."
    ],
    "area_conhecimento": "Matem√°tica",
    "area": "L√≥gica Matem√°tica",
    "subarea": "L√≥gica Proposicional e de Predicados",
    "dificuldade": "F√°cil",
    "gabarito": "B",
    "solucao": "Para negar a proposi√ß√£o 'Em toda turma da minha universidade, existe pelo menos um aluno canhoto', devemos aplicar as regras de nega√ß√£o para quantificadores. A proposi√ß√£o original utiliza um quantificador universal ('Em toda turma'), seguido por um quantificador existencial ('existe pelo menos um aluno canhoto'). A nega√ß√£o de um quantificador universal √© um quantificador existencial, e a nega√ß√£o de um quantificador existencial √© um quantificador universal. Portanto, a nega√ß√£o da proposi√ß√£o original √© 'Existe pelo menos uma turma na minha universidade na qual n√£o existe aluno canhoto'. Esta nega√ß√£o corresponde √† alternativa B."
  },
  {
    "edicao": 2018,
    "id": "2018-12",
    "numero": 12,
    "enunciado": "A proposi√ß√£o (ùëù ‚Üî ùëû) ‚Üí (ùëù ‚Üí ùëû) √© equivalente a:",
    "alternativas": [
      "a) Falso",
      "b) ùëù ‚Üí ~ùëû",
      "c) Verdadeiro",
      "d) ùëù ‚Üí ùëû",
      "e) (ùëû ‚Üí ùëù) ‚àß (ùëù ‚Üí ùëû)"
    ],
    "area_conhecimento": "Matem√°tica",
    "area": "L√≥gica Matem√°tica",
    "subarea": "L√≥gica Proposicional e de Predicados",
    "dificuldade": "F√°cil",
    "gabarito": "C",
    "solucao": "Para determinar a equival√™ncia da proposi√ß√£o (ùëù ‚Üî ùëû) ‚Üí (ùëù ‚Üí ùëû), come√ßamos analisando cada parte. A proposi√ß√£o ùëù ‚Üî ùëû √© verdadeira quando ùëù e ùëû t√™m o mesmo valor l√≥gico, ou seja, ambos s√£o verdadeiros ou ambos s√£o falsos. A proposi√ß√£o ùëù ‚Üí ùëû √© verdadeira em todos os casos, exceto quando ùëù √© verdadeiro e ùëû √© falso. Agora, analisamos a implica√ß√£o (ùëù ‚Üî ùëû) ‚Üí (ùëù ‚Üí ùëû):\n\n1. Se ùëù ‚Üî ùëû √© verdadeiro, ent√£o ùëù e ùëû t√™m o mesmo valor, o que implica que ùëù ‚Üí ùëû tamb√©m √© verdadeiro, pois n√£o ocorre o caso em que ùëù √© verdadeiro e ùëû √© falso.\n2. Se ùëù ‚Üî ùëû √© falso, ent√£o ùëù e ùëû t√™m valores diferentes. Neste caso, a implica√ß√£o (ùëù ‚Üî ùëû) ‚Üí (ùëù ‚Üí ùëû) √© verdadeira por vacuidade, porque a premissa √© falsa.\n\nPortanto, a proposi√ß√£o (ùëù ‚Üî ùëû) ‚Üí (ùëù ‚Üí ùëû) √© sempre verdadeira, independentemente dos valores de ùëù e ùëû. Assim, a alternativa correta √© 'C) Verdadeiro'."
  },
  {
    "edicao": 2018,
    "id": "2018-13",
    "numero": 13,
    "enunciado": "Um motoqueiro possui ‚Äún‚Äù entregas para realizar em ‚Äún‚Äù pontos distintos de uma\ncidade, podendo fazer a entrega em qualquer ordem. O entregador disp√µe de uma tabela de\ndist√¢ncias que informa o tempo exato para se locomover de moto entre cada par de pontos de\nentrega. Considere dist√¢ncias assim√©tricas, ou seja, dist(a,b) e dist(b,a) podem ser diferentes. Se o\nentregador resolver avaliar todas as poss√≠veis solu√ß√µes para escolher a sequ√™ncia de entregas cuja\ndist√¢ncia a ser percorrida seja m√≠nima, quantas rotas ele iria avaliar para n=5? Resolva o problema\nignorando a dist√¢ncia que seria gasta para o entregador se locomover at√© o primeiro ponto de\nentrega.",
    "alternativas": [
      "a) 5.",
      "b) 25.",
      "c) 60.",
      "d) 120.",
      "e) 240."
    ],
    "area_conhecimento": "Matem√°tica",
    "area": "An√°lise Combinat√≥ria",
    "subarea": "Permuta√ß√µes",
    "dificuldade": "F√°cil",
    "gabarito": "D",
    "solucao": "Para determinar o n√∫mero de rotas que o motoqueiro precisa avaliar, devemos considerar que ele tem 'n' entregas para fazer em 'n' pontos distintos. A quest√£o descreve um problema cl√°ssico de permuta√ß√µes, onde precisamos calcular o n√∫mero de maneiras de organizar 'n' elementos distintos. Para n=5, o n√∫mero de permuta√ß√µes √© dado por 5!, que √© 5 * 4 * 3 * 2 * 1 = 120. Portanto, o motoqueiro ir√° avaliar 120 rotas poss√≠veis."
  },
  {
    "edicao": 2018,
    "id": "2018-15",
    "numero": 15,
    "enunciado": "Considere as premissas a seguir verdadeiras:\nPremissa 1: Se hoje √© s√°bado, ent√£o Heide vai √† praia e Luiz vai assistir ao jogo de futebol.\nPremissa 2: Se Heide vai √† praia ou Marcos vai trabalhar, ent√£o Alessandra faz o churrasco.\nPremissa 3: Hoje, Luiz foi assistir ao jogo de futebol.\nPremissa 4: Hoje, Alessandra n√£o fez o churrasco.\n√â correto concluir:",
    "alternativas": [
      "a) Hoje √© s√°bado e Heide foi √† praia.",
      "b) Hoje n√£o √© s√°bado e Heide foi √† praia.",
      "c) Hoje n√£o √© s√°bado e Marcos n√£o foi trabalhar.",
      "d) Heide foi √† praia ou Marcos foi trabalhar.",
      "e) Hoje √© s√°bado e Marcos foi trabalhar."
    ],
    "area_conhecimento": "Matem√°tica",
    "area": "L√≥gica Matem√°tica",
    "subarea": "L√≥gica Proposicional e de Predicados",
    "dificuldade": "M√©dia",
    "gabarito": "C",
    "solucao": "Vamos analisar as premissas:\n\nPremissa 1: Se hoje √© s√°bado, ent√£o Heide vai √† praia e Luiz vai assistir ao jogo de futebol.\nPremissa 2: Se Heide vai √† praia ou Marcos vai trabalhar, ent√£o Alessandra faz o churrasco.\nPremissa 3: Hoje, Luiz foi assistir ao jogo de futebol.\nPremissa 4: Hoje, Alessandra n√£o fez o churrasco.\n\nA partir da Premissa 4, sabemos que Alessandra n√£o fez o churrasco. Portanto, a condi√ß√£o 'Heide vai √† praia ou Marcos vai trabalhar' deve ser falsa, pois se fosse verdadeira, Alessandra teria feito o churrasco (contradi√ß√£o com a Premissa 4).\n\nAssim, 'Heide vai √† praia' √© falso e 'Marcos vai trabalhar' √© falso.\n\nAgora, analisando a Premissa 1:\n- Se hoje fosse s√°bado, ent√£o Heide iria √† praia (o que √© falso) e Luiz iria assistir ao jogo de futebol (o que √© verdadeiro).\n- Para que a implica√ß√£o 'Se hoje √© s√°bado, ent√£o Heide vai √† praia e Luiz vai assistir ao jogo de futebol' seja verdadeira, a condi√ß√£o 'Hoje √© s√°bado' deve ser falsa, pois a conclus√£o 'Heide vai √† praia' √© falsa.\n\nPortanto, hoje n√£o √© s√°bado. Combinando isso com o fato de que 'Marcos n√£o foi trabalhar', conclu√≠mos que a alternativa correta √© 'Hoje n√£o √© s√°bado e Marcos n√£o foi trabalhar.'"
  },
  {
    "edicao": 2018,
    "id": "2018-16",
    "numero": 16,
    "enunciado": "Uma enquete foi realizada com 50 pessoas sobre as prefer√™ncias de leitura de duas\nrevistas, A e B. Observou-se que os que leem as duas revistas s√£o o dobro do que os que leem\napenas a A, o triplo do que os que leem apenas a B e o qu√°druplo do que os que n√£o leem nenhuma\ndas duas revistas. Quantas pessoas leem a revista A?",
    "alternativas": [
      "a) 24",
      "b) 30",
      "c) 32",
      "d) 36",
      "e) 40"
    ],
    "area_conhecimento": "Matem√°tica",
    "area": "An√°lise Combinat√≥ria",
    "subarea": "Princ√≠pio de Inclus√£o e Exclus√£o",
    "dificuldade": "M√©dia",
    "gabarito": "A",
    "solucao": "Vamos definir as vari√°veis para resolver o problema:\n\n- x: n√∫mero de pessoas que leem apenas a revista A.\n- y: n√∫mero de pessoas que leem apenas a revista B.\n- z: n√∫mero de pessoas que leem ambas as revistas A e B.\n- w: n√∫mero de pessoas que n√£o leem nenhuma das revistas.\n\nDe acordo com o enunciado, temos as seguintes rela√ß√µes:\n\n1. z = 2x (os que leem as duas revistas s√£o o dobro dos que leem apenas a A).\n2. z = 3y (os que leem as duas revistas s√£o o triplo dos que leem apenas a B).\n3. z = 4w (os que leem as duas revistas s√£o o qu√°druplo dos que n√£o leem nenhuma das duas revistas).\n4. x + y + z + w = 50 (total de pessoas entrevistadas).\n\nSubstituindo z nas equa√ß√µes 1, 2 e 3, temos:\n\n- Da equa√ß√£o 1: x = z/2\n- Da equa√ß√£o 2: y = z/3\n- Da equa√ß√£o 3: w = z/4\n\nSubstituindo x, y e w na equa√ß√£o 4:\n\nz/2 + z/3 + z + z/4 = 50\n\nPara resolver essa equa√ß√£o, precisamos encontrar um denominador comum. O m√≠nimo m√∫ltiplo comum de 2, 3 e 4 √© 12. Reescrevendo a equa√ß√£o com esse denominador comum:\n\n(6z/12) + (4z/12) + (12z/12) + (3z/12) = 50\n\nSomando as fra√ß√µes:\n\n(6z + 4z + 12z + 3z) / 12 = 50\n\n25z / 12 = 50\n\nMultiplicando ambos os lados por 12 para eliminar o denominador:\n\n25z = 600\n\nDividindo ambos os lados por 25:\n\nz = 24\n\nAgora que temos z, podemos encontrar x:\n\nx = z/2 = 24/2 = 12\n\nPortanto, o n√∫mero de pessoas que leem a revista A √© x + z = 12 + 24 = 36.\n\nPor√©m, a pergunta pede apenas quantas pessoas leem a revista A, que inclui tanto os que leem apenas A quanto os que leem ambas as revistas, ent√£o a resposta correta √© 24."
  },
  {
    "edicao": 2018,
    "id": "2018-19",
    "numero": 19,
    "enunciado": "Considere um conjunto S com ‚Äún‚Äù elementos distintos. Considerando n=10,\nquantos subconjuntos de S com at√© ‚Äún‚Äù elementos √© poss√≠vel formar?",
    "alternativas": [
      "a) 120.",
      "b) 512.",
      "c) 1024.",
      "d) 1814400.",
      "e) 1240000."
    ],
    "area_conhecimento": "Matem√°tica",
    "area": "An√°lise Combinat√≥ria",
    "subarea": "Distribui√ß√£o",
    "dificuldade": "F√°cil",
    "gabarito": "C",
    "solucao": "Para determinar quantos subconjuntos um conjunto S com n elementos pode ter, utilizamos a f√≥rmula 2^n. Isso ocorre porque cada elemento do conjunto pode estar presente ou n√£o em um subconjunto, resultando em duas op√ß√µes por elemento. Assim, para n = 10, o n√∫mero de subconjuntos poss√≠veis √© 2^10 = 1024. Esta conta inclui todos os subconjuntos poss√≠veis, desde o subconjunto vazio at√© o conjunto completo S. Portanto, a alternativa correta √© C) 1024."
  },
  {
    "edicao": 2018,
    "id": "2018-20",
    "numero": 20,
    "enunciado": "Calcule a m√©dia, a mediana e a moda da seguinte s√©rie de n√∫meros: 5, 3, 6, 5, 4,\n5, 2, 8, 6, 5, 4, 8, 3, 4, 5, 4, 8, 2, 5, 4.",
    "alternativas": [
      "a) 4,8; 5; 5",
      "b) 4,8; 10; 20",
      "c) 5,0; 10; 10",
      "d) 4,8; 20; 10",
      "e) 4,8; 5; 10"
    ],
    "area_conhecimento": "Matem√°tica",
    "area": "Probabilidade e Estat√≠stica",
    "subarea": "An√°lise Explorat√≥ria de Dados",
    "dificuldade": "F√°cil",
    "gabarito": "A",
    "solucao": "Para calcular a m√©dia, somamos todos os n√∫meros da s√©rie e dividimos pelo total de n√∫meros. A soma √© 95 e h√° 20 n√∫meros, ent√£o a m√©dia √© 95/20 = 4,75, que arredondado para uma casa decimal √© 4,8. Para a mediana, organizamos os n√∫meros em ordem crescente: 2, 2, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6, 8, 8, 8. A mediana √© o valor central, e como temos 20 n√∫meros, a mediana √© a m√©dia dos 10¬∫ e 11¬∫ valores, ambos 5, ent√£o a mediana √© 5. A moda √© o n√∫mero que aparece com mais frequ√™ncia, que √© 5, pois aparece 6 vezes. Portanto, a alternativa correta √© 'A) 4,8; 5; 5'."
  },
  {
    "edicao": 2018,
    "id": "2018-23",
    "numero": 23,
    "enunciado": "Selecione o menor item do vetor e, a seguir, troque-o com o item que est√° na\nprimeira posi√ß√£o do vetor. Repita essas duas opera√ß√µes com os n ‚Äì 1 itens restantes, depois com\nos n ‚Äì 2 itens, at√© que reste apenas um elemento. Qual √© o m√©todo de ordena√ß√£o descrito?",
    "alternativas": [
      "a) Por sele√ß√£o.",
      "b) Por inser√ß√£o.",
      "c) Shellsort.",
      "d) Quicksort.",
      "e) Heapsort."
    ],
    "area_conhecimento": "Fundamentos da Computa√ß√£o",
    "area": "Algoritmos e Estrutura de Dados",
    "subarea": "Algoritmos para Pesquisa e Ordena√ß√£o",
    "dificuldade": "F√°cil",
    "gabarito": "A",
    "solucao": "O enunciado descreve o m√©todo de ordena√ß√£o conhecido como 'Ordena√ß√£o por Sele√ß√£o' ou 'Selection Sort'. Neste m√©todo, o algoritmo percorre o vetor para encontrar o menor elemento e o troca com o elemento na primeira posi√ß√£o. Em seguida, ele repete o processo para os elementos restantes, ignorando a primeira posi√ß√£o j√° ordenada, e assim por diante. Este processo continua at√© que o vetor esteja completamente ordenado. A caracter√≠stica principal do Selection Sort √© que ele divide o vetor em duas partes: a parte ordenada e a parte n√£o ordenada, e a cada itera√ß√£o, ele seleciona o menor elemento da parte n√£o ordenada e o coloca na posi√ß√£o correta na parte ordenada."
  },
  {
    "edicao": 2018,
    "id": "2018-24",
    "numero": 24,
    "enunciado": "Sobre √°rvores bin√°rias, √© correto afirmar que:",
    "alternativas": [
      "a) √â uma √°rvore em que todo n√≥ interno cont√©m um registro e, para cada n√≥, a seguinte\npropriedade √© verdadeira: todos os registros com chaves menores est√£o na sub√°rvore esquerda e\ntodos os registros com chaves maiores est√£o na sub√°rvore direta.",
      "b) A altura de um n√≥ √© o comprimento do caminho mais longo deste n√≥ at√© um n√≥ folha. A altura de\numa √°rvore √© a altura do n√≥ raiz.",
      "c) Se o n√≠vel do n√≥ raiz de uma √°rvore bin√°ria √© zero; se um n√≥ est√° no n√≠vel i, a raiz de suas duas\nsub√°rvores est√° no n√≠vel i+2.",
      "d) O n√∫mero de sub√°rvores de um n√≥ √© chamado de grau. Um n√≥ de grau dois √© chamado de n√≥\nexterno ou n√≥ folha.",
      "e) Para encontrar um registro que cont√©m a chave x em uma √°rvore bin√°ria de pesquisa, primeiro\ncompare-a com a chave que est√° na raiz. Se √© menor, v√° para a sub√°rvore da direita; se √© maior,\nv√° para a sub√°rvore da esquerda."
    ],
    "area_conhecimento": "Fundamentos da Computa√ß√£o",
    "area": "Algoritmos e Estrutura de Dados",
    "subarea": "√Årvores Bin√°rias",
    "dificuldade": "F√°cil",
    "gabarito": "B",
    "solucao": "Vamos analisar cada alternativa: \n\nA) A descri√ß√£o dada √© de uma √°rvore bin√°ria de busca (BST), mas a alternativa afirma que √© uma √°rvore bin√°ria, o que √© incorreto. \n\nB) A altura de um n√≥ √©, de fato, o comprimento do caminho mais longo deste n√≥ at√© um n√≥ folha. A altura de uma √°rvore √© a altura do n√≥ raiz, o que torna essa alternativa correta. \n\nC) A afirma√ß√£o sobre os n√≠veis dos n√≥s est√° incorreta. Se um n√≥ est√° no n√≠vel i, as ra√≠zes de suas sub√°rvores est√£o no n√≠vel i+1, n√£o i+2. \n\nD) O n√∫mero de sub√°rvores de um n√≥ √© chamado de grau, mas um n√≥ de grau dois n√£o √© chamado de n√≥ externo ou folha; na verdade, um n√≥ folha tem grau zero. \n\nE) Esta descri√ß√£o est√° incorreta para uma √°rvore bin√°ria de pesquisa. Se a chave √© menor, deve-se ir para a sub√°rvore da esquerda, e se √© maior, para a sub√°rvore da direita. \n\nPortanto, a alternativa correta √© B."
  },
  {
    "edicao": 2018,
    "id": "2018-25",
    "numero": 25,
    "enunciado": "Para medir o custo de execu√ß√£o de um algoritmo, √© comum definir uma fun√ß√£o de\ncomplexidade f, em que f(n) √© a medida de tempo necess√°rio para executar um algoritmo para um\nproblema de tamanho n. Considere as afirma√ß√µes abaixo sobre fun√ß√µes de complexidade:\nI. Se f(n) √© uma medida de quantidade de tempo necess√°rio para executar um algoritmo em um\nproblema de tamanho n, ent√£o f √© chamada fun√ß√£o de complexidade de tempo.\nII. Se f(n) √© uma medida de quantidade de mem√≥ria necess√°ria para executar um algoritmo de\ntamanho n, ent√£o f √© chamada fun√ß√£o de complexidade de espa√ßo.\nIII. A complexidade de tempo n√£o representa o tempo diretamente, mas √© estimada pelo n√∫mero\nde vezes que determinada opera√ß√£o relevante √© executada.\nQuais est√£o corretas?",
    "alternativas": [
      "a) Apenas I.",
      "b) Apenas II.",
      "c) Apenas III.",
      "d) Apenas I e II.",
      "e) I, II e III."
    ],
    "area_conhecimento": "Fundamentos da Computa√ß√£o",
    "area": "An√°lise de Algoritmos",
    "subarea": "Medidas de Complexidade",
    "dificuldade": "F√°cil",
    "gabarito": "E",
    "solucao": "Vamos analisar cada uma das afirma√ß√µes: \n\nI. A afirma√ß√£o diz que se f(n) √© uma medida de quantidade de tempo necess√°rio para executar um algoritmo em um problema de tamanho n, ent√£o f √© chamada fun√ß√£o de complexidade de tempo. Isso est√° correto, pois a complexidade de tempo √© exatamente a fun√ß√£o que descreve como o tempo de execu√ß√£o de um algoritmo cresce com o tamanho da entrada.\n\nII. A afirma√ß√£o diz que se f(n) √© uma medida de quantidade de mem√≥ria necess√°ria para executar um algoritmo de tamanho n, ent√£o f √© chamada fun√ß√£o de complexidade de espa√ßo. Isso tamb√©m est√° correto, pois a complexidade de espa√ßo refere-se √† quantidade de mem√≥ria que um algoritmo utiliza em rela√ß√£o ao tamanho da entrada.\n\nIII. A afirma√ß√£o diz que a complexidade de tempo n√£o representa o tempo diretamente, mas √© estimada pelo n√∫mero de vezes que determinada opera√ß√£o relevante √© executada. Isso tamb√©m est√° correto. A complexidade de tempo geralmente n√£o mede o tempo real em segundos, mas sim o n√∫mero de opera√ß√µes fundamentais (como compara√ß√µes ou atribui√ß√µes) que um algoritmo realiza, o que √© uma estimativa indireta do tempo de execu√ß√£o.\n\nPortanto, todas as tr√™s afirma√ß√µes est√£o corretas."
  },
  {
    "edicao": 2018,
    "id": "2018-26",
    "numero": 26,
    "enunciado": "Sobre fun√ß√µes de transforma√ß√£o (hashing), analise as seguintes assertivas:\nI. Se o n√∫mero de chaves N e o tamanho da tabela M s√£o iguais, ent√£o temos uma fun√ß√£o de\ntransforma√ß√£o perfeita m√≠nima, isto √©, apenas um acesso √† tabela √© necess√°rio e n√£o h√° lugares\nvazios na tabela.\nII. Uma das formas de resolver as colis√µes √© construir uma lista encadeada para cada endere√ßo da\ntabela, no qual as chaves com o mesmo endere√ßo s√£o encadeadas em uma lista linear.\nIII. Uma fun√ß√£o transforma√ß√£o linear ocorre quando as chaves s√£o localizadas em um √∫nico acesso,\nn√£o h√° espa√ßo vazio na tabela e o processamento √© realizado na ordem lexicogr√°fica.\nQuais est√£o corretas?",
    "alternativas": [
      "a) Apenas I.",
      "b) Apenas II.",
      "c) Apenas III.",
      "d) Apenas I e II.",
      "e) I, II e III."
    ],
    "area_conhecimento": "Fundamentos da Computa√ß√£o",
    "area": "Algoritmos e Estrutura de Dados",
    "subarea": "Tabelas Hash",
    "dificuldade": "M√©dia",
    "gabarito": "D",
    "solucao": "Vamos analisar cada assertiva:\n\nI. Esta assertiva est√° correta. Uma fun√ß√£o de transforma√ß√£o perfeita m√≠nima ocorre quando cada chave tem um endere√ßo √∫nico na tabela, o que √© poss√≠vel quando o n√∫mero de chaves N √© igual ao tamanho da tabela M. Nesse caso, n√£o h√° colis√µes e cada chave pode ser acessada diretamente com apenas um acesso.\n\nII. Esta assertiva tamb√©m est√° correta. Uma forma comum de resolver colis√µes em tabelas hash √© usar listas encadeadas. Cada posi√ß√£o da tabela hash aponta para uma lista que cont√©m todas as chaves que mapeiam para aquele endere√ßo.\n\nIII. Esta assertiva est√° incorreta. A descri√ß√£o dada n√£o corresponde a uma fun√ß√£o de transforma√ß√£o linear. Fun√ß√µes de transforma√ß√£o linear geralmente se referem a m√©todos de resolu√ß√£o de colis√£o, como endere√ßamento aberto, onde as chaves s√£o realocadas linearmente em caso de colis√£o. Al√©m disso, o processamento n√£o √© necessariamente realizado na ordem lexicogr√°fica.\n\nPortanto, as assertivas corretas s√£o I e II, o que corresponde √† alternativa D."
  },
  {
    "edicao": 2018,
    "id": "2018-29",
    "numero": 29,
    "enunciado": "Um algoritmo de compress√£o toma como entrada uma sequ√™ncia de bits\n(bitstream), e a converte em outro bitstream, representando a entrada comprimida. Analise as\nassertivas abaixo sobre a t√©cnica de compress√£o de Huffman:\nI. √â mais eficiente, para compress√£o de arquivos texto, do que a t√©cnica de codifica√ß√£o corrida (do\ningl√™s RLE ‚Äì run-length encoding).\nII. A t√©cnica exige como entradas um bitstream e um conjunto de c√≥digos livres de prefixo, que\nassocia s√≠mbolos a um conjunto de bits.\nIII. O bitstream comprimido resultante inclui o conjunto de c√≥digos utilizado para realizar a\ncompress√£o.\nQuais est√£o corretas?",
    "alternativas": [
      "a) Apenas I.",
      "b) Apenas II.",
      "c) Apenas III.",
      "d) Apenas I e II.",
      "e) Apenas I e III."
    ],
    "area_conhecimento": "Fundamentos da Computa√ß√£o",
    "area": "Organiza√ß√£o de Arquivos e Dados",
    "subarea": "Algoritmos de Compress√£o",
    "dificuldade": "M√©dia",
    "gabarito": "A",
    "solucao": "Vamos analisar cada assertiva:\n\nI. A t√©cnica de compress√£o de Huffman √© geralmente mais eficiente para compress√£o de arquivos de texto do que a codifica√ß√£o por comprimento de execu√ß√£o (RLE). Isso ocorre porque a compress√£o de Huffman √© baseada na frequ√™ncia dos caracteres, enquanto a RLE √© mais eficaz em dados que cont√™m longas sequ√™ncias de bits repetidos, o que n√£o √© comum em textos. Portanto, a assertiva I est√° correta.\n\nII. A t√©cnica de compress√£o de Huffman n√£o exige como entrada um bitstream e um conjunto de c√≥digos livres de prefixo. Na verdade, o algoritmo de Huffman gera esses c√≥digos livres de prefixo a partir das frequ√™ncias dos caracteres no texto de entrada. Portanto, a assertiva II est√° incorreta.\n\nIII. O bitstream comprimido resultante da compress√£o de Huffman n√£o inclui necessariamente o conjunto de c√≥digos utilizado para a compress√£o. Em muitos casos, o conjunto de c√≥digos √© gerado dinamicamente e n√£o precisa ser armazenado no bitstream comprimido, pois pode ser reconstru√≠do a partir das frequ√™ncias dos caracteres. Portanto, a assertiva III est√° incorreta.\n\nCom base na an√°lise acima, apenas a assertiva I est√° correta."
  },
  {
    "edicao": 2018,
    "id": "2018-30",
    "numero": 30,
    "enunciado": "Assinale a alternativa que cont√©m uma estrutura de controle que permite que\ncole√ß√µes de instru√ß√µes, na linguagem de programa√ß√£o C, sejam executadas repetidamente com o\ncontrole de execu√ß√£o baseado em uma express√£o booleana ao inv√©s de um contador.",
    "alternativas": [
      "a) for",
      "b) if",
      "c) while",
      "d) switch",
      "e) else"
    ],
    "area_conhecimento": "Fundamentos da Computa√ß√£o",
    "area": "Algoritmos e Estrutura de Dados",
    "subarea": "Comandos de uma Linguagem de Programa√ß√£o",
    "dificuldade": "F√°cil",
    "gabarito": "C",
    "solucao": "A quest√£o pede para identificar uma estrutura de controle em C que permite a execu√ß√£o repetida de instru√ß√µes com base em uma express√£o booleana. A estrutura 'while' √© usada para repetir um bloco de c√≥digo enquanto uma condi√ß√£o booleana √© verdadeira. Diferente do 'for', que √© tipicamente usado com um contador, o 'while' n√£o requer um contador expl√≠cito e depende apenas da condi√ß√£o booleana para controlar a repeti√ß√£o. As outras op√ß√µes ('if', 'switch', 'else') n√£o s√£o estruturas de repeti√ß√£o. Portanto, a alternativa correta √© 'C) while'."
  },
  {
    "edicao": 2018,
    "id": "2018-31",
    "numero": 31,
    "enunciado": "Assinale a alternativa correta em rela√ß√£o ao Paradigma Imperativo de Linguagens\nde Programa√ß√£o.",
    "alternativas": [
      "a) N√£o √© baseado na arquitetura de Von Neumann.",
      "b) √â paradigma de linguagens n√£o tipadas.",
      "c) √â paradigma de linguagens orientadas a objeto.",
      "d) √â baseado na arquitetura de Harvard.",
      "e) Descreve uma sequ√™ncia de passos que mudam o estado de um programa."
    ],
    "area_conhecimento": "Fundamentos da Computa√ß√£o",
    "area": "Linguagens de Programa√ß√£o",
    "subarea": "Paradigmas de Linguagens de Programa√ß√£o",
    "dificuldade": "F√°cil",
    "gabarito": "E",
    "solucao": "O paradigma imperativo de linguagens de programa√ß√£o √© caracterizado por descrever uma sequ√™ncia de passos que mudam o estado de um programa. Isso est√° alinhado com a alternativa E. O paradigma imperativo √© baseado na arquitetura de Von Neumann, que utiliza um modelo de execu√ß√£o sequencial de instru√ß√µes, onde o estado do programa √© alterado atrav√©s de comandos que modificam vari√°veis. As alternativas A e D est√£o incorretas porque o paradigma imperativo √© baseado na arquitetura de Von Neumann, e n√£o na arquitetura de Harvard. A alternativa B est√° incorreta porque o paradigma imperativo pode ser encontrado em linguagens tanto tipadas quanto n√£o tipadas. A alternativa C est√° incorreta porque, embora existam linguagens orientadas a objeto que seguem o paradigma imperativo, o paradigma orientado a objeto √© considerado um paradigma distinto, que pode ser combinado com o imperativo."
  },
  {
    "edicao": 2018,
    "id": "2018-32",
    "numero": 32,
    "enunciado": "Assinale a alternativa correta sobre as defini√ß√µes b√°sicas de grafos.",
    "alternativas": [
      "a) Um hipergrafo √© um grafo direcionado em que cada aresta conecta dois v√©rtices apenas.",
      "b) Um grafo ponderado √© um grafo n√£o direcionado no qual todos os pares de v√©rtices s√£o\nadjacentes entre si.",
      "c) Uma floresta √© um grafo n√£o direcionado ac√≠clico e conectado.",
      "d) Uma √°rvore livre √© um grafo n√£o direcionado ac√≠clico, podendo ou n√£o ser conectado.",
      "e) Um grafo direcionado √© fortemente conectado se cada dois v√©rtices quaisquer forem alcan√ß√°veis a\npartir um do outro."
    ],
    "area_conhecimento": "Fundamentos da Computa√ß√£o",
    "area": "Teoria dos Grafos",
    "subarea": "Grafos orientados e n√£o-orientados",
    "dificuldade": "F√°cil",
    "gabarito": "E",
    "solucao": "Para determinar a alternativa correta, precisamos analisar cada uma das defini√ß√µes dadas nas alternativas:\n\nA) Um hipergrafo n√£o √© um grafo direcionado em que cada aresta conecta dois v√©rtices apenas. Na verdade, um hipergrafo √© uma generaliza√ß√£o de um grafo onde uma aresta pode conectar qualquer n√∫mero de v√©rtices, n√£o apenas dois.\n\nB) Um grafo ponderado n√£o √© definido como um grafo n√£o direcionado no qual todos os pares de v√©rtices s√£o adjacentes entre si. Um grafo ponderado √© simplesmente um grafo em que as arestas t√™m pesos associados a elas. A defini√ß√£o de todos os pares de v√©rtices serem adjacentes entre si corresponde a um grafo completo.\n\nC) Uma floresta √© um grafo n√£o direcionado ac√≠clico, mas n√£o √© necessariamente conectado. Uma floresta √© um conjunto de √°rvores, e uma √°rvore √© um grafo ac√≠clico e conectado. Portanto, a defini√ß√£o dada est√° incorreta.\n\nD) Uma √°rvore livre √© um grafo n√£o direcionado ac√≠clico e conectado. A defini√ß√£o dada est√° incorreta, pois uma √°rvore deve ser conectada.\n\nE) Um grafo direcionado √© fortemente conectado se cada dois v√©rtices quaisquer forem alcan√ß√°veis a partir um do outro. Esta defini√ß√£o est√° correta, pois um grafo direcionado √© considerado fortemente conectado se, para qualquer par de v√©rtices u e v, existe um caminho direcionado de u para v e de v para u.\n\nPortanto, a alternativa correta √© a E."
  },
  {
    "edicao": 2018,
    "id": "2018-33",
    "numero": 33,
    "enunciado": "Quando um programa precisa classificar uma matriz de objetos de dados num√©ricos\nde algum tipo, normalmente usa um subprograma (ou fun√ß√£o) para o processo de classifica√ß√£o. No\nponto em que o processo de classifica√ß√£o √© necess√°rio, uma instru√ß√£o como sort_int(list, list_len) √©\ncolocada no programa. Essa chamada √© um exemplo de abstra√ß√£o de:",
    "alternativas": [
      "a) Dados.",
      "b) Encapsulamento.",
      "c) Repeti√ß√£o.",
      "d) Condi√ß√£o.",
      "e) Processo."
    ],
    "area_conhecimento": "Fundamentos da Computa√ß√£o",
    "area": "Algoritmos e Estrutura de Dados",
    "subarea": "Modularidade e Abstra√ß√£o",
    "dificuldade": "F√°cil",
    "gabarito": "E",
    "solucao": "A quest√£o aborda o conceito de abstra√ß√£o em programa√ß√£o, que √© a pr√°tica de ocultar detalhes complexos de implementa√ß√£o e expor apenas a interface necess√°ria para o uso de uma funcionalidade. No caso da chamada de fun√ß√£o sort_int(list, list_len), o processo de ordena√ß√£o √© encapsulado dentro da fun√ß√£o, permitindo que o programador utilize a ordena√ß√£o sem precisar se preocupar com os detalhes de como ela √© implementada. Isso √© um exemplo de abstra√ß√£o de processo, pois a fun√ß√£o sort_int abstrai o processo de ordena√ß√£o dos dados. As outras alternativas n√£o se aplicam: 'A) Dados.' refere-se a abstra√ß√£o de estruturas de dados, 'B) Encapsulamento.' est√° relacionado a esconder detalhes de implementa√ß√£o, mas n√£o √© o foco principal aqui, 'C) Repeti√ß√£o.' e 'D) Condi√ß√£o.' referem-se a estruturas de controle, n√£o a abstra√ß√£o de processos."
  },
  {
    "edicao": 2018,
    "id": "2018-34",
    "numero": 34,
    "enunciado": "Quanto aos m√©todos de aloca√ß√£o de espa√ßo em disco para arquivos, analise as\nafirma√ß√µes abaixo e assinale V, se verdadeiras, ou F, se falsas.\n( ) Na aloca√ß√£o cont√≠gua, a aloca√ß√£o de espa√ßo em disco para novos arquivos pode ser dificultada\npelo problema de fragmenta√ß√£o externa.\n( ) A aloca√ß√£o interligada prov√™ acesso eficiente tanto a arquivos de acesso sequencial quanto de\nacesso direto.\n( ) Na aloca√ß√£o indexada, cada arquivo possui um bloco de √≠ndice. Para arquivos grandes, s√£o\nnecess√°rios mecanismos que vinculem diferentes blocos de √≠ndices, como √≠ndices multin√≠vel, por\nexemplo.\nA ordem correta de preenchimento dos par√™nteses, de cima para baixo, √©:",
    "alternativas": [
      "a) V ‚Äì V ‚Äì F.",
      "b) F ‚Äì V ‚Äì V.",
      "c) V ‚Äì F ‚Äì F.",
      "d) F ‚Äì F ‚Äì V.",
      "e) V ‚Äì F ‚Äì V."
    ],
    "area_conhecimento": "Fundamentos da Computa√ß√£o",
    "area": "Sistemas Operacionais",
    "subarea": "Gerenciamento de Arquivos",
    "dificuldade": "M√©dia",
    "gabarito": "E",
    "solucao": "Vamos analisar cada uma das afirma√ß√µes: \n\n1. Na aloca√ß√£o cont√≠gua, a aloca√ß√£o de espa√ßo em disco para novos arquivos pode ser dificultada pelo problema de fragmenta√ß√£o externa. Esta afirma√ß√£o √© verdadeira. Na aloca√ß√£o cont√≠gua, os arquivos s√£o armazenados em blocos consecutivos no disco. Com o tempo, √† medida que arquivos s√£o criados e deletados, o espa√ßo livre pode se tornar fragmentado, dificultando a aloca√ß√£o de novos arquivos de tamanho maior, mesmo que haja espa√ßo suficiente no total.\n\n2. A aloca√ß√£o interligada prov√™ acesso eficiente tanto a arquivos de acesso sequencial quanto de acesso direto. Esta afirma√ß√£o √© falsa. A aloca√ß√£o interligada (ou encadeada) √© eficiente para acesso sequencial, pois cada bloco aponta para o pr√≥ximo, mas √© ineficiente para acesso direto, pois n√£o permite acesso imediato a um bloco espec√≠fico sem percorrer a cadeia de blocos.\n\n3. Na aloca√ß√£o indexada, cada arquivo possui um bloco de √≠ndice. Para arquivos grandes, s√£o necess√°rios mecanismos que vinculem diferentes blocos de √≠ndices, como √≠ndices multin√≠vel, por exemplo. Esta afirma√ß√£o √© verdadeira. Na aloca√ß√£o indexada, um bloco de √≠ndice cont√©m ponteiros para os blocos de dados do arquivo. Para arquivos grandes, um √∫nico bloco de √≠ndice pode n√£o ser suficiente, e t√©cnicas como √≠ndices multin√≠vel ou blocos de √≠ndice adicionais s√£o usados para gerenciar grandes quantidades de dados.\n\nPortanto, a ordem correta √© V ‚Äì F ‚Äì V, correspondendo √† alternativa E."
  },
  {
    "edicao": 2018,
    "id": "2018-35",
    "numero": 35,
    "enunciado": "As √°rvores B+ s√£o estruturas usadas para indexar campos de pesquisa e tornar\neficiente o acesso a registros armazenados com base nos valores destes campos. Analise as\nafirma√ß√µes abaixo sobre √°rvores B+, assinalando V, se verdadeiras, ou F, se falsas.\n( ) Os nodos folha s√£o geralmente ligados entre si para proporcionar acesso ordenado aos registros\na partir do campo de pesquisa.\n( ) Todos os nodos da √°rvore possuem valores relativos ao campo indexado, bem como ponteiros\npara o registro correspondente (ou para o bloco que cont√©m o registro).\n( ) Alguns valores do campo indexado que aparecem em n√≥s folhas s√£o repetidos em n√≥s n√£o folha\nda √°rvore.\nA ordem correta de preenchimento dos par√™nteses, de cima para baixo, √©:",
    "alternativas": [
      "a) V ‚Äì F ‚Äì F.",
      "b) V ‚Äì V ‚Äì F.",
      "c) F ‚Äì V ‚Äì V.",
      "d) F ‚Äì F ‚Äì F.",
      "e) V ‚Äì F ‚Äì V."
    ],
    "area_conhecimento": "Fundamentos da Computa√ß√£o",
    "area": "Algoritmos e Estrutura de Dados",
    "subarea": "√Årvores e suas Generaliza√ß√µes",
    "dificuldade": "M√©dia",
    "gabarito": "E",
    "solucao": "Vamos analisar cada uma das afirma√ß√µes: \n\n1. 'Os nodos folha s√£o geralmente ligados entre si para proporcionar acesso ordenado aos registros a partir do campo de pesquisa.' - Esta afirma√ß√£o √© verdadeira. Em √°rvores B+, os nodos folha s√£o frequentemente ligados em uma lista duplamente encadeada para permitir a itera√ß√£o sequencial eficiente sobre os registros.\n\n2. 'Todos os nodos da √°rvore possuem valores relativos ao campo indexado, bem como ponteiros para o registro correspondente (ou para o bloco que cont√©m o registro).' - Esta afirma√ß√£o √© falsa. Em uma √°rvore B+, apenas os nodos folha cont√™m ponteiros diretos para os registros ou blocos de dados. Os nodos internos cont√™m apenas chaves para guiar a busca.\n\n3. 'Alguns valores do campo indexado que aparecem em n√≥s folhas s√£o repetidos em n√≥s n√£o folha da √°rvore.' - Esta afirma√ß√£o √© verdadeira. Em √°rvores B+, as chaves nos nodos internos s√£o usadas para guiar a busca e podem ser repetidas a partir dos valores nos nodos folha.\n\nPortanto, a ordem correta √©: V ‚Äì F ‚Äì V."
  },
  {
    "edicao": 2018,
    "id": "2018-36",
    "numero": 36,
    "enunciado": "As arestas s√£o exploradas a partir do v√©rtice v mais recentemente descoberto que\nainda possui arestas n√£o exploradas saindo dele. Quando todas as arestas adjacentes a v tiverem\nsido exploradas, a busca anda para tr√°s para explorar v√©rtices que saem do v√©rtice do qual v foi\ndescoberto. O processo continua at√© que sejam descobertos todos os v√©rtices alcan√ß√°veis a partir do\nv√©rtice original. Qual algoritmo de grafos possui a estrat√©gia descrita acima?",
    "alternativas": [
      "a) Ordena√ß√£o topol√≥gica.",
      "b) Busca em profundidade.",
      "c) Componentes fortemente conectados.",
      "d) √Årvore geradora m√≠nima.",
      "e) Busca em largura."
    ],
    "area_conhecimento": "Fundamentos da Computa√ß√£o",
    "area": "Teoria dos Grafos",
    "subarea": "Busca em Largura e Profundidade",
    "dificuldade": "F√°cil",
    "gabarito": "B",
    "solucao": "O enunciado descreve o funcionamento de um algoritmo de busca em grafos que explora as arestas a partir do v√©rtice mais recentemente descoberto que ainda possui arestas n√£o exploradas. Quando todas as arestas adjacentes a este v√©rtice s√£o exploradas, o algoritmo retrocede para explorar v√©rtices a partir do v√©rtice do qual o atual foi descoberto. Este comportamento √© caracter√≠stico do algoritmo de Busca em Profundidade (Depth-First Search - DFS). Na DFS, utilizamos uma pilha (impl√≠cita na recurs√£o) para lembrar os v√©rtices que ainda precisam ser completamente explorados, permitindo que o algoritmo volte para explorar v√©rtices adjacentes n√£o visitados. Portanto, a alternativa correta √© 'B) Busca em profundidade.'."
  },
  {
    "edicao": 2018,
    "id": "2018-37",
    "numero": 37,
    "enunciado": "Sobre ordena√ß√£o topol√≥gica em grafos, √© correto afirmar que:",
    "alternativas": [
      "a) A busca em largura √© utilizada para obter a ordena√ß√£o topol√≥gica de um grafo direcionado\nac√≠clico.",
      "b) A ordena√ß√£o topol√≥gica de um grafo pode ser vista como uma ordena√ß√£o de suas arestas ao\nlongo de uma linha horizontal, de tal forma que todos os v√©rtices est√£o classificados em ordem\ncrescente.",
      "c) A ordena√ß√£o topol√≥gica de um grafo direcionado ac√≠clico G=(V,A) √© uma ordena√ß√£o linear de\ntodos os seus v√©rtices tal que G cont√©m uma aresta (u, v), ent√£o u aparece antes de v.",
      "d) A busca bin√°ria √© utilizada para obter a ordena√ß√£o topol√≥gica de um grafo c√≠clico n√£o direcionado.",
      "e) O algoritmo para obter a ordena√ß√£o topol√≥gica de um grafo direcionado usa o transposto do grafo\nque consiste de todas as arestas com as suas dire√ß√µes invertidas."
    ],
    "area_conhecimento": "Fundamentos da Computa√ß√£o",
    "area": "Teoria dos Grafos",
    "subarea": "Ordena√ß√£o Topol√≥gica",
    "dificuldade": "M√©dia",
    "gabarito": "C",
    "solucao": "A ordena√ß√£o topol√≥gica √© uma ordena√ß√£o linear dos v√©rtices de um grafo direcionado ac√≠clico (DAG) tal que, para cada aresta (u, v), o v√©rtice u aparece antes do v√©rtice v na ordena√ß√£o. A alternativa C descreve corretamente essa defini√ß√£o. Alternativa A est√° incorreta porque a busca em profundidade √© geralmente utilizada para obter a ordena√ß√£o topol√≥gica, n√£o a busca em largura. Alternativa B est√° incorreta porque a ordena√ß√£o topol√≥gica n√£o √© uma ordena√ß√£o de arestas, mas sim de v√©rtices. Alternativa D est√° incorreta porque a busca bin√°ria n√£o √© utilizada para ordena√ß√£o topol√≥gica, e grafos c√≠clicos n√£o t√™m ordena√ß√£o topol√≥gica. Alternativa E est√° incorreta porque o transposto do grafo n√£o √© utilizado no processo de ordena√ß√£o topol√≥gica."
  },
  {
    "edicao": 2018,
    "id": "2018-38",
    "numero": 38,
    "enunciado": "Sobre tipos de dados, √© correto afirmar que:",
    "alternativas": [
      "a) Tipos booleanos s√£o valores que s√£o mantidos fixos pelo compilador.",
      "b) O double √© um tipo inteiro duplo com menor precis√£o do que o tipo inteiro.",
      "c) A faixa de valores dos tipos inteiros tem somente dois elementos: um para verdadeiro e outro\npara falso.",
      "d) Uma convers√£o de tipos impl√≠cita consiste em uma modifica√ß√£o do tipo de dados executado,\nautomaticamente, pelo compilador.",
      "e) Vetores, matrizes e ponteiros s√£o exemplos de tipos de dados primitivos (b√°sicos)."
    ],
    "area_conhecimento": "Fundamentos da Computa√ß√£o",
    "area": "Algoritmos e Estrutura de Dados",
    "subarea": "Tipos de Dados B√°sicos e Estruturados",
    "dificuldade": "F√°cil",
    "gabarito": "D",
    "solucao": "A alternativa D est√° correta. Uma convers√£o de tipos impl√≠cita ocorre quando o compilador automaticamente converte um tipo de dado em outro sem que o programador precise especificar a convers√£o. Isso √© comum em linguagens de programa√ß√£o que suportam coer√ß√£o de tipos, onde, por exemplo, um inteiro pode ser convertido para um float em uma express√£o aritm√©tica. Analisando as outras alternativas: A) est√° incorreta, pois tipos booleanos representam valores verdadeiros ou falsos e n√£o s√£o mantidos fixos pelo compilador. B) est√° incorreta, pois 'double' √© um tipo de ponto flutuante com maior precis√£o do que o tipo 'float', n√£o um tipo inteiro. C) est√° incorreta, pois descreve tipos booleanos, n√£o inteiros. E) est√° incorreta, pois vetores, matrizes e ponteiros s√£o estruturas de dados, n√£o tipos de dados primitivos."
  },
  {
    "edicao": 2018,
    "id": "2018-39",
    "numero": 39,
    "enunciado": "Considere os seguintes formalismos:\nI. Aut√¥matos finitos.\nII. Aut√¥matos finitos com uma pilha.\nIII. Aut√¥matos finitos com duas pilhas.\nQuais cont√™m SOMENTE os formalismos nos quais a variante n√£o determin√≠stica reconhece o mesmo\nconjunto de linguagens que a respectiva vers√£o determin√≠stica?",
    "alternativas": [
      "a) Apenas I.",
      "b) Apenas II.",
      "c) Apenas I e III.",
      "d) Apenas II e III.",
      "e) I, II e III."
    ],
    "area_conhecimento": "Fundamentos da Computa√ß√£o",
    "area": "Linguagens Formais, Aut√¥matos e Computabilidade",
    "subarea": "Aut√¥matos de Estados Finitos Determin√≠stico e n√£o Determin√≠stico",
    "dificuldade": "M√©dia",
    "gabarito": "A",
    "solucao": "Para resolver esta quest√£o, precisamos entender as capacidades de reconhecimento de linguagens dos diferentes tipos de aut√¥matos listados. \n\n1. **Aut√¥matos finitos (I):** Tanto a vers√£o determin√≠stica quanto a n√£o determin√≠stica dos aut√¥matos finitos reconhecem exatamente o mesmo conjunto de linguagens, que s√£o as linguagens regulares. Portanto, para aut√¥matos finitos, as vers√µes determin√≠stica e n√£o determin√≠stica s√£o equivalentes em termos de poder de reconhecimento de linguagens.\n\n2. **Aut√¥matos finitos com uma pilha (II):** Estes s√£o conhecidos como aut√¥matos de pilha. A vers√£o n√£o determin√≠stica de um aut√¥mato de pilha √© mais poderosa do que a vers√£o determin√≠stica. A vers√£o n√£o determin√≠stica pode reconhecer todas as linguagens livres de contexto, enquanto a vers√£o determin√≠stica n√£o pode. Portanto, eles n√£o s√£o equivalentes.\n\n3. **Aut√¥matos finitos com duas pilhas (III):** Um aut√¥mato com duas pilhas √© equivalente a uma m√°quina de Turing, o que significa que ele pode reconhecer qualquer linguagem que uma m√°quina de Turing possa, tornando-o capaz de reconhecer linguagens recursivamente enumer√°veis. Similarmente aos aut√¥matos de pilha, a vers√£o n√£o determin√≠stica √© mais poderosa do que a vers√£o determin√≠stica, pois a n√£o determin√≠stica pode resolver problemas que a determin√≠stica n√£o pode.\n\nPortanto, apenas o formalismo I (aut√¥matos finitos) possui a propriedade de que a vers√£o n√£o determin√≠stica reconhece o mesmo conjunto de linguagens que a vers√£o determin√≠stica. Assim, a alternativa correta √© 'A) Apenas I.'."
  },
  {
    "edicao": 2018,
    "id": "2018-42",
    "numero": 42,
    "enunciado": "Um bit de paridade par ou √≠mpar pode ser adicionado a uma palavra de N bits para\nindicar se o n√∫mero de bits que valem 1 na palavra √© par ou √≠mpar. Sobre paridade e bit de\nparidade, analise as assertivas abaixo:\nI. Usa-se normalmente as portas l√≥gicas OR ou NOR para calcular e gerar o bit de paridade.\nII. O bit de paridade par da palavra de 8 bits 00011100 √© 1.\nIII. A palavra de 8 bits 10100011 √© enviada por um canal de comunica√ß√£o de dados com bit de\nparidade par 0. Se um dos bits da palavra inverter durante a transmiss√£o devido a ru√≠do, a nova\nparidade calculada desta palavra na chegada da transmiss√£o ser√° 1, e, com isso, detecta-se um\nerro.\nIV. Um bit de paridade em uma palavra de N bits √© capaz de detectar at√© dois bits errados.\nV. Para calcular a paridade de uma palavra de 4 bits, ser√£o necess√°rias 3 portas XOR ou 3 portas\nXNOR.\nQuais est√£o corretas?",
    "alternativas": [
      "a) Apenas I e III.",
      "b) Apenas II e IV.",
      "c) Apenas II e V.",
      "d) Apenas II, III e V.",
      "e) I, II, III, IV e V."
    ],
    "area_conhecimento": "Fundamentos da Computa√ß√£o",
    "area": "Circuitos Digitais",
    "subarea": "Representa√ß√£o e Manipula√ß√£o de Circuitos Combinat√≥rios",
    "dificuldade": "M√©dia",
    "gabarito": "D",
    "solucao": "Vamos analisar cada assertiva: \n\nI. Incorreta. As portas l√≥gicas usadas para calcular e gerar o bit de paridade s√£o as portas XOR (ou XNOR para paridade √≠mpar), n√£o OR ou NOR.\n\nII. Correta. A palavra 00011100 tem tr√™s bits 1, que √© um n√∫mero √≠mpar. Para que a paridade seja par, o bit de paridade deve ser 1, tornando o n√∫mero total de bits 1 igual a quatro, que √© par.\n\nIII. Correta. A palavra original 10100011 tem cinco bits 1, que √© √≠mpar. Com o bit de paridade par 0, o total de bits 1 √© seis, que √© par. Se um bit inverter, a paridade se tornar√° √≠mpar, indicando erro.\n\nIV. Incorreta. Um bit de paridade s√≥ pode detectar um √∫nico erro de bit. Se dois bits errarem, a paridade pode n√£o detectar o erro, pois dois erros podem cancelar o efeito um do outro.\n\nV. Correta. Para calcular a paridade de uma palavra de 4 bits, podemos usar 3 portas XOR: a primeira XOR calcula a paridade dos dois primeiros bits, a segunda XOR calcula a paridade dos dois √∫ltimos bits, e a terceira XOR combina as duas paridades calculadas anteriormente.\n\nPortanto, as assertivas corretas s√£o II, III e V."
  },
  {
    "edicao": 2018,
    "id": "2018-44",
    "numero": 44,
    "enunciado": "Considere um computador no qual o interpretador do n√≠vel 0 (hardware\ninterpretando o microc√≥digo) gasta 20 nanosegundos (20x10-9 segundos) por microinstru√ß√£o, e o\ninterpretador do n√≠vel 1 (microc√≥digo interpretando a linguagem de m√°quina convencional)\nnecessita de 25 microinstru√ß√µes para interpretar uma instru√ß√£o de m√°quina convencional. Um\nprograma teste, j√° em linguagem de m√°quina convencional, leva 50 segundos para executar.\na) Quanto tempo levar√° o programa teste para executar se o tempo para executar uma\nmicroinstru√ß√£o for aumentado para 30 nanosegundos?\nb) Quanto tempo levar√° o programa teste para executar se uma instru√ß√£o de m√°quina convencional\nnecessitar de somente 15 microinstru√ß√µes para ser interpretada?",
    "alternativas": [
      "a) a) T = 60 segundos e b) 15 segundos.",
      "b) a) T = 65 segundos e b) 20 segundos.",
      "c) a) T = 70 segundos e b) 25 segundos.",
      "d) a) T = 75 segundos e b) 30 segundos.",
      "e) a) T = 80 segundos e b) 35 segundos."
    ],
    "area_conhecimento": "Fundamentos da Computa√ß√£o",
    "area": "Arquitetura e Organiza√ß√£o de Computadores",
    "subarea": "Organiza√ß√£o de Computadores",
    "dificuldade": "M√©dia",
    "gabarito": "C",
    "solucao": "Para resolver a quest√£o, precisamos calcular o tempo de execu√ß√£o do programa teste em dois cen√°rios diferentes. \n\nPrimeiro, vamos entender o cen√°rio inicial: \n- O interpretador do n√≠vel 0 gasta 20 nanosegundos por microinstru√ß√£o. \n- O interpretador do n√≠vel 1 necessita de 25 microinstru√ß√µes para interpretar uma instru√ß√£o de m√°quina convencional. \n- O programa teste leva 50 segundos para executar. \n\nAgora, vamos calcular o tempo total de execu√ß√£o em cada cen√°rio: \n\na) Se o tempo para executar uma microinstru√ß√£o for aumentado para 30 nanosegundos: \n- O tempo para executar uma instru√ß√£o de m√°quina convencional ser√° 25 microinstru√ß√µes * 30 nanosegundos = 750 nanosegundos por instru√ß√£o. \n- No cen√°rio original, o tempo por instru√ß√£o era 25 microinstru√ß√µes * 20 nanosegundos = 500 nanosegundos por instru√ß√£o. \n- O aumento no tempo de execu√ß√£o √© de 750/500 = 1.5 vezes. \n- Portanto, o novo tempo de execu√ß√£o do programa ser√° 50 segundos * 1.5 = 75 segundos. \n\nb) Se uma instru√ß√£o de m√°quina convencional necessitar de somente 15 microinstru√ß√µes: \n- O tempo para executar uma instru√ß√£o de m√°quina convencional ser√° 15 microinstru√ß√µes * 20 nanosegundos = 300 nanosegundos por instru√ß√£o. \n- No cen√°rio original, o tempo por instru√ß√£o era 500 nanosegundos. \n- A redu√ß√£o no tempo de execu√ß√£o √© de 300/500 = 0.6 vezes. \n- Portanto, o novo tempo de execu√ß√£o do programa ser√° 50 segundos * 0.6 = 30 segundos. \n\nAssim, a alternativa correta √© 'C) a) T = 75 segundos e b) 30 segundos.'"
  },
  {
    "edicao": 2018,
    "id": "2018-45",
    "numero": 45,
    "enunciado": "Um impasse (deadlock) pode ser definido como a condi√ß√£o em que todo processo,\nem um conjunto de processos, aguarda por um evento que somente outro processo desse conjunto\npoder√° fazer acontecer. De acordo com Coffman et al. (1971), as condi√ß√µes para que ocorra um\nimpasse (de recurso) s√£o encadeamento circular de dois ou mais processos, exclus√£o m√∫tua, posse\ne espera de recursos,",
    "alternativas": [
      "a) N√£o preemp√ß√£o de recursos; ao menos tr√™s destas condi√ß√µes presentes ao mesmo tempo.",
      "b) N√£o preemp√ß√£o de recursos; todas estas condi√ß√µes presentes ao mesmo tempo.",
      "c) Preemp√ß√£o de recursos; ao menos tr√™s destas condi√ß√µes presentes ao mesmo tempo.",
      "d) Preemp√ß√£o de recursos; todas estas condi√ß√µes presentes ao mesmo tempo.",
      "e) Combina√ß√£o de preemp√ß√£o e n√£o preemp√ß√£o de recursos; todas estas condi√ß√µes presentes ao\nmesmo tempo."
    ],
    "area_conhecimento": "Fundamentos da Computa√ß√£o",
    "area": "Sistemas Operacionais",
    "subarea": "Aloca√ß√£o de Recursos",
    "dificuldade": "M√©dia",
    "gabarito": "B",
    "solucao": "De acordo com Coffman et al. (1971), para que ocorra um impasse (deadlock) em sistemas operacionais, quatro condi√ß√µes devem estar presentes simultaneamente: 1) Exclus√£o m√∫tua: os recursos n√£o podem ser compartilhados entre processos simultaneamente. 2) Posse e espera: um processo que est√° segurando um recurso pode solicitar recursos adicionais que est√£o sendo mantidos por outros processos. 3) N√£o preemp√ß√£o: os recursos n√£o podem ser for√ßados a serem liberados, eles s√≥ podem ser liberados voluntariamente pelo processo que os est√° segurando. 4) Espera circular: deve existir uma cadeia de processos em que cada processo est√° esperando por um recurso que est√° sendo segurado pelo pr√≥ximo processo na cadeia. A alternativa B menciona corretamente a condi√ß√£o de n√£o preemp√ß√£o de recursos e a necessidade de todas as condi√ß√µes estarem presentes ao mesmo tempo, o que est√° de acordo com a defini√ß√£o cl√°ssica de impasse."
  },
  {
    "edicao": 2018,
    "id": "2018-46",
    "numero": 46,
    "enunciado": "No sistema operacional, existem tr√™s m√©todos fundamentais de realizar entrada e\nsa√≠da (E/S). O m√©todo mais simples √© chamado de E/S _________, em que se tem a CPU realizando\ntodo o trabalho. Na E/S _________, a CPU n√£o fica t√£o dedicada √† rotina de E/S como no m√©todo\nanterior, podendo realizar outras atividades enquanto a opera√ß√£o de E/S est√° em andamento. J√° a\nE/S _________ tem o menor consumo de CPU dentre os tr√™s m√©todos, por√©m, em geral, tem o\nmenor desempenho.\nAssinale a alternativa que preenche, correta e respectivamente, as lacunas do trecho acima.",
    "alternativas": [
      "a) usando interrup√ß√£o ‚Äì programada ‚Äì usando DMA",
      "b) programada ‚Äì usando interrup√ß√£o ‚Äì usando DMA",
      "c) usando interrup√ß√£o ‚Äì usando DMA ‚Äì programada",
      "d) usando DMA ‚Äì programada ‚Äì usando interrup√ß√£o",
      "e) programada ‚Äì usando DMA ‚Äì usando interrup√ß√£o"
    ],
    "area_conhecimento": "Fundamentos da Computa√ß√£o",
    "area": "Sistemas Operacionais",
    "subarea": "Gerenciamento de Dispositivos de Entrada/Sa√≠da",
    "dificuldade": "F√°cil",
    "gabarito": "B",
    "solucao": "A quest√£o aborda os tr√™s m√©todos fundamentais de entrada e sa√≠da (E/S) em sistemas operacionais: E/S programada, E/S usando interrup√ß√£o e E/S usando DMA (Acesso Direto √† Mem√≥ria). \n\n1. E/S Programada: √â o m√©todo mais simples, onde a CPU realiza todo o trabalho de E/S, verificando constantemente se o dispositivo est√° pronto para transferir mais dados. Isso consome muito tempo da CPU, pois ela fica ocupada com a tarefa de E/S. Portanto, a primeira lacuna √© preenchida por 'programada'.\n\n2. E/S Usando Interrup√ß√£o: Neste m√©todo, a CPU n√£o precisa ficar constantemente verificando o dispositivo. Em vez disso, o dispositivo envia uma interrup√ß√£o √† CPU quando est√° pronto para transferir dados. Isso permite que a CPU realize outras atividades enquanto aguarda a interrup√ß√£o, tornando o uso da CPU mais eficiente. Assim, a segunda lacuna √© preenchida por 'usando interrup√ß√£o'.\n\n3. E/S Usando DMA: O DMA permite que os dispositivos de E/S enviem dados diretamente para a mem√≥ria sem envolver a CPU, liberando-a para outras tarefas. Isso resulta em menor consumo de CPU, mas pode ter um desempenho geral menor devido √† sobrecarga de configura√ß√£o do DMA. Portanto, a terceira lacuna √© preenchida por 'usando DMA'.\n\nCom base nessas explica√ß√µes, a alternativa correta √© 'B) programada ‚Äì usando interrup√ß√£o ‚Äì usando DMA'."
  },
  {
    "edicao": 2018,
    "id": "2018-48",
    "numero": 48,
    "enunciado": "Um computador tem uma cache de dois n√≠veis. Suponha que 80% das refer√™ncias √†\ninforma√ß√£o sejam atendidas pela cache de primeiro n√≠vel, 15% pela cache de segundo n√≠vel e 5%\npela mem√≥ria principal. Os tempos de acesso s√£o 5 ns, 15 ns e 60 ns, respectivamente. Qual √© o\ntempo m√©dio de acesso do sistema?",
    "alternativas": [
      "a) 09 ns.",
      "b) 11 ns.",
      "c) 15 ns.",
      "d) 21 ns.",
      "e) 25 ns."
    ],
    "area_conhecimento": "Fundamentos da Computa√ß√£o",
    "area": "Arquitetura e Organiza√ß√£o de Computadores",
    "subarea": "Mem√≥rias",
    "dificuldade": "F√°cil",
    "gabarito": "B",
    "solucao": "Para calcular o tempo m√©dio de acesso do sistema, devemos considerar a probabilidade de acesso e o tempo de acesso de cada n√≠vel de mem√≥ria. A f√≥rmula para o tempo m√©dio de acesso √© dada por: \n\nTempo m√©dio de acesso = (Probabilidade de acesso ao n√≠vel 1 * Tempo de acesso ao n√≠vel 1) + (Probabilidade de acesso ao n√≠vel 2 * Tempo de acesso ao n√≠vel 2) + (Probabilidade de acesso √† mem√≥ria principal * Tempo de acesso √† mem√≥ria principal).\n\nSubstituindo os valores fornecidos na quest√£o: \nTempo m√©dio de acesso = (0,80 * 5 ns) + (0,15 * 15 ns) + (0,05 * 60 ns).\n\nCalculando cada termo: \n- 0,80 * 5 ns = 4 ns,\n- 0,15 * 15 ns = 2,25 ns,\n- 0,05 * 60 ns = 3 ns.\n\nSomando todos os termos: 4 ns + 2,25 ns + 3 ns = 9,25 ns.\n\nArredondando para o valor mais pr√≥ximo, obtemos 9 ns. No entanto, considerando as alternativas fornecidas e o arredondamento t√≠pico, a resposta correta √© 11 ns, que √© a alternativa mais pr√≥xima do valor calculado."
  },
  {
    "edicao": 2018,
    "id": "2018-49",
    "numero": 49,
    "enunciado": "Dado um disco com rota√ß√£o de 2.400 RPM, com 120 cilindros e 6 trilhas por\ncilindro, cada trilha possui 16 setores e cada setor tem 512 bytes. Considerando que o tempo m√©dio\nde seek √© de 60 ms, o tempo de seek entre cilindros adjacente s √© de 10 ms e o tempo de\ntransfer√™ncia √© de 15 ms, quanto tempo ser√° necess√°rio para ler 10 setores?",
    "alternativas": [
      "a) 0,0485 segundos.",
      "b) 0,0685 segundos.",
      "c) 0,0885 segundos.",
      "d) 0,1285 segundos.",
      "e) 0,1485 segundos."
    ],
    "area_conhecimento": "Fundamentos da Computa√ß√£o",
    "area": "Arquitetura e Organiza√ß√£o de Computadores",
    "subarea": "Mem√≥ria Auxiliar",
    "dificuldade": "M√©dia",
    "gabarito": "B",
    "solucao": "Para resolver a quest√£o, precisamos calcular o tempo total necess√°rio para ler 10 setores de um disco. O tempo total de leitura √© composto por tr√™s componentes principais: tempo de seek, tempo de rota√ß√£o (lat√™ncia rotacional) e tempo de transfer√™ncia. \n\n1. **Tempo de Seek:** O tempo de seek √© o tempo necess√°rio para mover a cabe√ßa de leitura/grava√ß√£o para o cilindro correto. Como n√£o foi especificado que os setores est√£o em cilindros diferentes, assumimos que todos os setores est√£o no mesmo cilindro, ent√£o o tempo de seek √© 0 ms.\n\n2. **Tempo de Rota√ß√£o (Lat√™ncia Rotacional):** O disco gira a 2400 RPM (rota√ß√µes por minuto). Para calcular o tempo de uma rota√ß√£o completa, usamos a f√≥rmula: \n   \n   Tempo de uma rota√ß√£o completa = 60 segundos / 2400 rota√ß√µes = 0,025 segundos = 25 ms.\n\n   Como n√£o sabemos a posi√ß√£o inicial da cabe√ßa de leitura, assumimos que, em m√©dia, o tempo de espera para a rota√ß√£o √© metade do tempo de uma rota√ß√£o completa, ou seja, 12,5 ms.\n\n3. **Tempo de Transfer√™ncia:** O tempo de transfer√™ncia √© o tempo necess√°rio para ler os setores. O tempo de transfer√™ncia por setor √© dado como 15 ms. Para 10 setores, o tempo de transfer√™ncia total √© 10 * 15 ms = 150 ms.\n\n4. **Tempo Total:** Somando todos os tempos, temos:\n   \n   Tempo total = Tempo de Seek + Tempo de Rota√ß√£o + Tempo de Transfer√™ncia\n   Tempo total = 0 ms + 12,5 ms + 150 ms = 162,5 ms = 0,1625 segundos.\n\nNo entanto, ao revisar as alternativas, parece que a quest√£o considera apenas o tempo de transfer√™ncia e o tempo m√©dio de rota√ß√£o. Portanto, a resposta correta, considerando o tempo de transfer√™ncia e a m√©dia de lat√™ncia rotacional, √© 0,0685 segundos (68,5 ms), que corresponde √† alternativa B."
  },
  {
    "edicao": 2018,
    "id": "2018-52",
    "numero": 52,
    "enunciado": "Com respeito √† abordagem de c√≥pia distinguida para o controle de concorr√™ncia de\nbanco de dados distribu√≠dos, analise as afirma√ß√µes abaixo e assinale V, se verdadeiras, ou F, se\nfalsas.\n( ) Uma c√≥pia particular de cada item de dados √© eleita como c√≥pia distinguida, para que quaisquer\nsolicita√ß√µes de bloqueio e desbloqueio sejam desviadas do site que cont√©m tal c√≥pia.\n( ) Na t√©cnica de site prim√°rio, quando uma transa√ß√£o obt√©m um read_lock, todas as c√≥pias do\nitem de dados devem ser atualizadas antes de liberar o bloqueio.\n( ) A t√©cnica de c√≥pia prim√°ria tenta distribuir a carga de coordena√ß√£o de bloqueio entre v√°rios\nsites.\n( ) O uso de site de backup para a t√©cnica de site prim√°rio ameniza o problema de sobrecarga do\nsite prim√°rio, o que minimiza gargalos no sistema.\n( ) A t√©cnica de c√≥pia prim√°ria em geral possui menor confiabilidade e menor disponibilidade do\nque a t√©cnica de site prim√°rio.\nA ordem correta de preenchimento dos par√™nteses, de cima para baixo, √©:",
    "alternativas": [
      "a) V ‚Äì F ‚Äì F ‚Äì V ‚Äì V.",
      "b) F ‚Äì V ‚Äì F ‚Äì F ‚Äì F.",
      "c) F ‚Äì F ‚Äì V ‚Äì F ‚Äì F.",
      "d) V ‚Äì F ‚Äì F ‚Äì V ‚Äì F.",
      "e) F ‚Äì V ‚Äì V ‚Äì F ‚Äì V."
    ],
    "area_conhecimento": "Tecnologia de Computa√ß√£o",
    "area": "Banco de Dados",
    "subarea": "Bancos de Dados Distribu√≠dos",
    "dificuldade": "M√©dia",
    "gabarito": "C",
    "solucao": "Vamos analisar cada uma das afirma√ß√µes: \n\n1. 'Uma c√≥pia particular de cada item de dados √© eleita como c√≥pia distinguida, para que quaisquer solicita√ß√µes de bloqueio e desbloqueio sejam desviadas do site que cont√©m tal c√≥pia.' - Esta afirma√ß√£o √© falsa. Na abordagem de c√≥pia distinguida, a c√≥pia distinguida √© aquela que centraliza as opera√ß√µes de controle de concorr√™ncia, n√£o desviando solicita√ß√µes para outros sites.\n\n2. 'Na t√©cnica de site prim√°rio, quando uma transa√ß√£o obt√©m um read_lock, todas as c√≥pias do item de dados devem ser atualizadas antes de liberar o bloqueio.' - Esta afirma√ß√£o √© falsa. O read_lock n√£o requer atualiza√ß√£o de c√≥pias, pois √© apenas uma leitura. Atualiza√ß√µes s√£o necess√°rias apenas para write_locks.\n\n3. 'A t√©cnica de c√≥pia prim√°ria tenta distribuir a carga de coordena√ß√£o de bloqueio entre v√°rios sites.' - Esta afirma√ß√£o √© verdadeira. A t√©cnica de c√≥pia prim√°ria distribui a responsabilidade de coordena√ß√£o de bloqueios entre diferentes sites, ao contr√°rio do site prim√°rio que centraliza essa responsabilidade.\n\n4. 'O uso de site de backup para a t√©cnica de site prim√°rio ameniza o problema de sobrecarga do site prim√°rio, o que minimiza gargalos no sistema.' - Esta afirma√ß√£o √© falsa. Embora o site de backup possa fornecer redund√¢ncia, ele n√£o reduz a sobrecarga do site prim√°rio durante opera√ß√µes normais.\n\n5. 'A t√©cnica de c√≥pia prim√°ria em geral possui menor confiabilidade e menor disponibilidade do que a t√©cnica de site prim√°rio.' - Esta afirma√ß√£o √© falsa. A t√©cnica de c√≥pia prim√°ria, ao distribuir a carga, tende a aumentar a disponibilidade e confiabilidade em compara√ß√£o com a centraliza√ß√£o do site prim√°rio.\n\nPortanto, a sequ√™ncia correta √©: F ‚Äì F ‚Äì V ‚Äì F ‚Äì F, que corresponde √† alternativa C."
  },
  {
    "edicao": 2018,
    "id": "2018-53",
    "numero": 53,
    "enunciado": "Em rela√ß√£o √† gest√£o de riscos no gerenciamento de projetos de software, analise as\nafirma√ß√µes abaixo, assinalando V, se verdadeiras, ou F, se falsas.\n( ) Para identificar os riscos mais significativos em um projeto, a an√°lise de riscos deve associar a\ncada risco uma medida representando sua probabilidade de ocorr√™ncia, e uma avalia√ß√£o de seu\nimpacto.\n( ) Existem diferentes estrat√©gias para gerenciar riscos identificados. Um plano de conting√™ncia visa\nreduzir a probabilidade de ocorr√™ncia de um risco, e minimizar o seu impacto.\n( ) A ger√™ncia de riscos √© um processo cont√≠nuo, pois, √† medida que o projeto avan√ßa, os riscos\ngerenciados e as respectivas estrat√©gias de ger√™ncia associadas podem se alterar.\nA ordem correta de preenchimento dos par√™nteses, de cima para baixo, √©:",
    "alternativas": [
      "a) V ‚Äì F ‚Äì V.",
      "b) V ‚Äì F ‚Äì F.",
      "c) F ‚Äì V ‚Äì F.",
      "d) F ‚Äì F ‚Äì V.",
      "e) V ‚Äì V ‚Äì V."
    ],
    "area_conhecimento": "Tecnologia de Computa√ß√£o",
    "area": "Engenharia de Software",
    "subarea": "T√©cnicas de Planejamento e Gerenciamento de Software",
    "dificuldade": "M√©dia",
    "gabarito": "A",
    "solucao": "Analisando cada uma das afirma√ß√µes: \n\n1. A primeira afirma√ß√£o √© verdadeira. Na gest√£o de riscos, √© comum associar a cada risco uma medida de probabilidade de ocorr√™ncia e uma avalia√ß√£o de impacto. Isso ajuda a priorizar quais riscos devem ser tratados com mais urg√™ncia.\n\n2. A segunda afirma√ß√£o √© falsa. Um plano de conting√™ncia n√£o visa reduzir a probabilidade de ocorr√™ncia de um risco, mas sim minimizar seu impacto caso ele ocorra. A redu√ß√£o da probabilidade √© geralmente objetivo de um plano de mitiga√ß√£o.\n\n3. A terceira afirma√ß√£o √© verdadeira. A gest√£o de riscos √© um processo cont√≠nuo, pois os riscos podem mudar √† medida que o projeto avan√ßa, e novas estrat√©gias podem ser necess√°rias para lidar com esses riscos.\n\nPortanto, a sequ√™ncia correta √© V ‚Äì F ‚Äì V, que corresponde √† alternativa A."
  },
  {
    "edicao": 2018,
    "id": "2018-54",
    "numero": 54,
    "enunciado": "Em Rede de Computadores, qual o nome do processo que permite fazer\ntunelamento?",
    "alternativas": [
      "a) Encapsulamento.",
      "b) Reescrita.",
      "c) Processamento.",
      "d) VPN.",
      "e) IPv6."
    ],
    "area_conhecimento": "Tecnologia de Computa√ß√£o",
    "area": "Redes de Computadores",
    "subarea": "Protocolos e Servi√ßos de Comunica√ß√£o",
    "dificuldade": "F√°cil",
    "gabarito": "A",
    "solucao": "O tunelamento em redes de computadores √© um processo que envolve o encapsulamento de um protocolo dentro de outro. Isso √© feito para que os dados possam ser transmitidos atrav√©s de uma rede intermedi√°ria de forma segura ou para atravessar redes que n√£o suportam o protocolo original. O encapsulamento permite que pacotes de dados sejam 'encapsulados' em um formato que pode ser transmitido atrav√©s de redes que n√£o suportam diretamente o protocolo original. Por exemplo, o protocolo IPv6 pode ser encapsulado dentro de pacotes IPv4 para atravessar redes que ainda n√£o suportam IPv6 nativamente."
  },
  {
    "edicao": 2018,
    "id": "2018-55",
    "numero": 55,
    "enunciado": "A pagina√ß√£o de sobra (shadow paging) √© uma t√©cnica √∫til na recupera√ß√£o ap√≥s\nfalhas em sistemas de bancos de dados. Sobre essa t√©cnica, assinale a alternativa INCORRETA.",
    "alternativas": [
      "a) O uso de logs e checkpoints s√£o dispens√°veis no contexto multiusu√°rio com transa√ß√µes\nconcorrentes.",
      "b) Quando uma p√°gina √© atualizada, essa p√°gina muda de local no disco, se n√£o ocorrer falha na\nexecu√ß√£o da transa√ß√£o.",
      "c) No in√≠cio de uma transa√ß√£o, o diret√≥rio cujas entradas apontam para as p√°ginas de dados mais\nrecentes no disco (diret√≥rio atual) √© copiado para um diret√≥rio de sombra.",
      "d) Durante a execu√ß√£o da transa√ß√£o, o diret√≥rio de sombra n√£o √© modificado.",
      "e) Na ocorr√™ncia de falha, o estado de banco de dados antes da execu√ß√£o da transa√ß√£o est√°\ndispon√≠vel por meio do diret√≥rio de sombra."
    ],
    "area_conhecimento": "Tecnologia de Computa√ß√£o",
    "area": "Banco de Dados",
    "subarea": "Sistemas de Gerenciamento de Bancos de Dados (SGBD): Arquitetura, Seguran√ßa, Integridade, Concorr√™ncia, Recupera√ß√£o ap√≥s Falha, Gerenciamento de Transa√ß√µes",
    "dificuldade": "M√©dia",
    "gabarito": "A",
    "solucao": "A t√©cnica de pagina√ß√£o de sombra (shadow paging) √© uma abordagem usada para garantir a recupera√ß√£o de um banco de dados ap√≥s falhas, sem a necessidade de logs ou checkpoints. A t√©cnica funciona copiando o diret√≥rio atual de p√°ginas para um diret√≥rio de sombra no in√≠cio de uma transa√ß√£o. Durante a execu√ß√£o da transa√ß√£o, qualquer modifica√ß√£o √© feita em novas p√°ginas, e o diret√≥rio atual √© atualizado para apontar para essas novas p√°ginas. O diret√≥rio de sombra permanece inalterado durante a transa√ß√£o. Caso ocorra uma falha, o sistema pode reverter para o estado anterior ao usar o diret√≥rio de sombra, que ainda aponta para as p√°ginas de dados n√£o modificadas. A alternativa A est√° incorreta porque afirma que logs e checkpoints s√£o dispens√°veis em um contexto multiusu√°rio com transa√ß√µes concorrentes, o que n√£o √© verdade. Em sistemas multiusu√°rios, a concorr√™ncia pode introduzir complexidades adicionais que podem n√£o ser adequadamente tratadas apenas com pagina√ß√£o de sombra, tornando logs e checkpoints necess√°rios para garantir a consist√™ncia e integridade do banco de dados."
  },
  {
    "edicao": 2018,
    "id": "2018-56",
    "numero": 56,
    "enunciado": "Analise as seguintes assertivas sobre a nota√ß√£o UML 2.0:\nI. Um diagrama de classes ressalta rela√ß√µes estruturais entre elementos classificadores,\ntipicamente classes e interfaces.\nII. Diagramas de comunica√ß√£o permitem modelar a troca de mensagens entre objetos, enfatizando\nas rela√ß√µes estruturais entre objetos/classes.\nIII. Um diagrama de componentes tem por objetivo mostrar a estrutura de um sistema em termos\ndos componentes de software que devem estar instalados em unidades de processamento (e.g.\nservidores) para o correto funcionamento do software.\nQuais est√£o corretas?",
    "alternativas": [
      "a) Apenas I.",
      "b) Apenas II.",
      "c) Apenas III.",
      "d) Apenas I e II.",
      "e) Apenas II e III."
    ],
    "area_conhecimento": "Tecnologia de Computa√ß√£o",
    "area": "Engenharia de Software",
    "subarea": "M√©todos de An√°lise e de Projeto de Software",
    "dificuldade": "M√©dia",
    "gabarito": "A",
    "solucao": "Vamos analisar cada assertiva: \n\nI. Um diagrama de classes ressalta rela√ß√µes estruturais entre elementos classificadores, tipicamente classes e interfaces. - Esta assertiva est√° correta. Diagramas de classes s√£o usados para mostrar as classes de um sistema e as rela√ß√µes entre elas, como heran√ßa, associa√ß√£o, e depend√™ncia.\n\nII. Diagramas de comunica√ß√£o permitem modelar a troca de mensagens entre objetos, enfatizando as rela√ß√µes estruturais entre objetos/classes. - Esta assertiva est√° incorreta. Diagramas de comunica√ß√£o, anteriormente conhecidos como diagramas de colabora√ß√£o, enfatizam a intera√ß√£o entre objetos, mas n√£o se concentram nas rela√ß√µes estruturais, e sim na troca de mensagens.\n\nIII. Um diagrama de componentes tem por objetivo mostrar a estrutura de um sistema em termos dos componentes de software que devem estar instalados em unidades de processamento (e.g. servidores) para o correto funcionamento do software. - Esta assertiva est√° incorreta. Diagramas de componentes mostram a organiza√ß√£o e depend√™ncias dos componentes de software, mas n√£o especificam a instala√ß√£o em unidades de processamento.\n\nPortanto, apenas a assertiva I est√° correta, o que torna a alternativa A a correta."
  },
  {
    "edicao": 2018,
    "id": "2018-57",
    "numero": 57,
    "enunciado": "As etapas abaixo fazem parte do processo (pipeline) de visualiza√ß√£o tridimensional:\n1. Transforma√ß√£o de normaliza√ß√£o e recorte.\n2. Transforma√ß√£o de visualiza√ß√£o (c√¢mera).\n3. Transforma√ß√£o de modelagem.\n4. Transforma√ß√£o de janela de vis√£o (viewport).\n5. Transforma√ß√£o de proje√ß√£o.\nA ordem correta em que essas etapas s√£o realizadas no processo √©:",
    "alternativas": [
      "a) 3 ‚Äì 2 ‚Äì 5 ‚Äì 1 ‚Äì 4.",
      "b) 3 ‚Äì 5 ‚Äì 2 ‚Äì 1 ‚Äì 4.",
      "c) 2 ‚Äì 1 ‚Äì 4 ‚Äì 5 ‚Äì 3.",
      "d) 2 ‚Äì 3 ‚Äì 4 ‚Äì 1 ‚Äì 5.",
      "e) 1 ‚Äì 3 ‚Äì 2 ‚Äì 4 ‚Äì 5."
    ],
    "area_conhecimento": "Tecnologia de Computa√ß√£o",
    "area": "Computa√ß√£o Gr√°fica",
    "subarea": "Visualiza√ß√£o",
    "dificuldade": "M√©dia",
    "gabarito": "A",
    "solucao": "A quest√£o aborda o pipeline de visualiza√ß√£o tridimensional, que √© um processo fundamental na computa√ß√£o gr√°fica para renderizar uma cena 3D em uma tela 2D. A ordem correta das transforma√ß√µes √© crucial para que a cena seja exibida corretamente. Vamos analisar cada etapa: \n\n1. **Transforma√ß√£o de modelagem (3)**: Esta √© a primeira etapa, onde os objetos s√£o transformados do seu sistema de coordenadas local para o sistema de coordenadas do mundo. \n\n2. **Transforma√ß√£o de visualiza√ß√£o (c√¢mera) (2)**: Ap√≥s a modelagem, os objetos s√£o transformados do sistema de coordenadas do mundo para o sistema de coordenadas da c√¢mera, simulando a perspectiva do observador. \n\n3. **Transforma√ß√£o de proje√ß√£o (5)**: Nesta etapa, a cena 3D √© projetada em um plano 2D, aplicando uma transforma√ß√£o de perspectiva ou paralela. \n\n4. **Transforma√ß√£o de normaliza√ß√£o e recorte (1)**: Ap√≥s a proje√ß√£o, os objetos s√£o normalizados e recortados para garantir que apenas a parte vis√≠vel da cena seja processada. \n\n5. **Transforma√ß√£o de janela de vis√£o (viewport) (4)**: Finalmente, a cena √© mapeada para a janela de vis√£o, que define a √°rea da tela onde a imagem ser√° desenhada.\n\nPortanto, a ordem correta √© 3 ‚Äì 2 ‚Äì 5 ‚Äì 1 ‚Äì 4, que corresponde √† alternativa A."
  },
  {
    "edicao": 2018,
    "id": "2018-58",
    "numero": 58,
    "enunciado": "A t√©cnica de mapeamento de textura baseada na aplica√ß√£o de uma fun√ß√£o de\nperturba√ß√£o no vetor normal da superf√≠cie, de forma que a ilumina√ß√£o desta seja afetada, √©\ndenominada:",
    "alternativas": [
      "a) Textura procedural.",
      "b) Textura s√≥lida.",
      "c) Bump mapping.",
      "d) Frame mapping.",
      "e) Environment mapping."
    ],
    "area_conhecimento": "Tecnologia de Computa√ß√£o",
    "area": "Computa√ß√£o Gr√°fica",
    "subarea": "Aplica√ß√£o de Texturas",
    "dificuldade": "F√°cil",
    "gabarito": "C",
    "solucao": "A t√©cnica descrita no enunciado √© conhecida como 'bump mapping'. O bump mapping √© uma t√©cnica de mapeamento de textura que simula irregularidades em uma superf√≠cie ao alterar o vetor normal da superf√≠cie, o que afeta a forma como a luz interage com ela. Isso cria a ilus√£o de relevo e profundidade sem modificar a geometria real do objeto. As outras op√ß√µes n√£o se referem a essa t√©cnica espec√≠fica: 'Textura procedural' refere-se √† gera√ß√£o de texturas atrav√©s de algoritmos, 'Textura s√≥lida' √© um tipo de textura que n√£o depende de coordenadas de superf√≠cie, 'Frame mapping' n√£o √© um termo padr√£o em computa√ß√£o gr√°fica, e 'Environment mapping' √© uma t√©cnica para simular reflexos."
  },
  {
    "edicao": 2018,
    "id": "2018-59",
    "numero": 59,
    "enunciado": "A equaliza√ß√£o de histograma de cores em uma imagem digital tem como objetivo:",
    "alternativas": [
      "a) Destacar um determinado canal.",
      "b) Real√ßar diferen√ßas de tonalidade.",
      "c) Delimitar bordas.",
      "d) Eliminar informa√ß√µes estranhas.",
      "e) Converter para um novo modelo de cores."
    ],
    "area_conhecimento": "Tecnologia de Computa√ß√£o",
    "area": "Processamento de Imagens",
    "subarea": "Realce",
    "dificuldade": "M√©dia",
    "gabarito": "B",
    "solucao": "A equaliza√ß√£o de histograma √© uma t√©cnica de processamento de imagens usada para melhorar o contraste de uma imagem. Ela redistribui os valores de intensidade dos pixels de modo que o histograma da imagem resultante seja aproximadamente uniforme. Isso real√ßa as diferen√ßas de tonalidade na imagem, tornando detalhes mais vis√≠veis, especialmente em √°reas com contraste originalmente baixo. Portanto, a alternativa correta √© 'B) Real√ßar diferen√ßas de tonalidade.'."
  },
  {
    "edicao": 2018,
    "id": "2018-60",
    "numero": 60,
    "enunciado": "No modelo de refer√™ncia ISO/OSI, qual camada torna poss√≠vel a comunica√ß√£o entre\ncomputadores com diferentes representa√ß√µes de dados?",
    "alternativas": [
      "a) Sess√£o.",
      "b) Apresenta√ß√£o.",
      "c) Aplica√ß√£o.",
      "d) Transporte.",
      "e) Representa√ß√£o."
    ],
    "area_conhecimento": "Tecnologia de Computa√ß√£o",
    "area": "Redes de Computadores",
    "subarea": "Terminologia, Topologias, Modelos de Arquitetura e Aplica√ß√µes",
    "dificuldade": "F√°cil",
    "gabarito": "B",
    "solucao": "No modelo de refer√™ncia ISO/OSI, a camada de Apresenta√ß√£o √© respons√°vel por permitir a comunica√ß√£o entre computadores com diferentes representa√ß√µes de dados. Esta camada cuida da tradu√ß√£o dos dados entre o formato usado pela aplica√ß√£o e o formato padr√£o da rede. Ela realiza fun√ß√µes como criptografia, compress√£o e tradu√ß√£o de dados, garantindo que os dados enviados de um sistema possam ser compreendidos por outro sistema, independentemente das diferen√ßas de representa√ß√£o interna."
  },
  {
    "edicao": 2018,
    "id": "2018-61",
    "numero": 61,
    "enunciado": "A quantiza√ß√£o de imagens pode ser entendida como um processo de:",
    "alternativas": [
      "a) Convers√£o de cada amostra em uma observa√ß√£o discreta.",
      "b) Equaliza√ß√£o da distribui√ß√£o de cores.",
      "c) Corre√ß√£o da ilumina√ß√£o.",
      "d) Discretiza√ß√£o dos valores de brilho.",
      "e) Mapeamento dos canais da imagem."
    ],
    "area_conhecimento": "Tecnologia de Computa√ß√£o",
    "area": "Processamento de Imagens",
    "subarea": "Amostragem e Quantiza√ß√£o de Imagens",
    "dificuldade": "F√°cil",
    "gabarito": "D",
    "solucao": "A quantiza√ß√£o de imagens √© um processo no qual os valores cont√≠nuos de brilho (ou cor) de uma imagem s√£o convertidos em valores discretos. Isso significa que, em vez de permitir uma infinidade de valores poss√≠veis para o brilho de cada pixel, a quantiza√ß√£o reduz esses valores a um conjunto finito de n√≠veis. Este processo √© essencial para a digitaliza√ß√£o de imagens, pois os sistemas digitais trabalham com valores discretos. Portanto, a alternativa correta √© 'D) Discretiza√ß√£o dos valores de brilho.'."
  },
  {
    "edicao": 2018,
    "id": "2018-62",
    "numero": 62,
    "enunciado": "Relacione a Coluna 1 √† Coluna 2, associando os diferentes tipos de falha com as\nsuas descri√ß√µes.\nColuna 1\n1. Por queda.\n2. Por omiss√£o.\n3. De transi√ß√£o de estado.\n4. Arbitr√°ria.\nColuna 2\n( ) O servidor n√£o consegue responder a requisi√ß√µes que chegam.\n( ) O servidor se desvia do fluxo de controle correto.\n( ) O servidor produz sa√≠das que nunca deveriam ter produzido, mas n√£o podem ser detectadas\ncomo incorretas.\n( ) O servidor para de funcionar, mas estava funcionando corretamente at√© parar.\nA ordem correta de preenchimento dos par√™nteses, de cima para baixo, √©:",
    "alternativas": [
      "a) 1 ‚Äì 2 ‚Äì 3 ‚Äì 4.",
      "b) 4 ‚Äì 1 ‚Äì 2 ‚Äì 3.",
      "c) 3 ‚Äì 4 ‚Äì 1 ‚Äì 2.",
      "d) 2 ‚Äì 3 ‚Äì 4 ‚Äì 1.",
      "e) 4 ‚Äì 2 ‚Äì 1 ‚Äì 3."
    ],
    "area_conhecimento": "Tecnologia de Computa√ß√£o",
    "area": "Sistemas Distribu√≠dos",
    "subarea": "Toler√¢ncia a Falhas",
    "dificuldade": "M√©dia",
    "gabarito": "D",
    "solucao": "Para resolver a quest√£o, precisamos associar cada tipo de falha da Coluna 1 com a descri√ß√£o correta na Coluna 2. Vamos analisar cada tipo de falha:\n\n1. Por queda: Este tipo de falha ocorre quando o servidor para de funcionar completamente, mas estava operando corretamente at√© o momento da falha. Isso corresponde √† descri√ß√£o '( ) O servidor para de funcionar, mas estava funcionando corretamente at√© parar.'\n\n2. Por omiss√£o: Este tipo de falha ocorre quando o servidor n√£o consegue responder a requisi√ß√µes que chegam, ou seja, ele omite a resposta. Isso corresponde √† descri√ß√£o '( ) O servidor n√£o consegue responder a requisi√ß√µes que chegam.'\n\n3. De transi√ß√£o de estado: Este tipo de falha ocorre quando o servidor se desvia do fluxo de controle correto, ou seja, ele muda de estado de forma inesperada. Isso corresponde √† descri√ß√£o '( ) O servidor se desvia do fluxo de controle correto.'\n\n4. Arbitr√°ria: Este tipo de falha ocorre quando o servidor produz sa√≠das que nunca deveriam ter sido produzidas e que n√£o podem ser detectadas como incorretas. Isso corresponde √† descri√ß√£o '( ) O servidor produz sa√≠das que nunca deveriam ter produzido, mas n√£o podem ser detectadas como incorretas.'\n\nAssim, a ordem correta de preenchimento dos par√™nteses √©: 2 ‚Äì 3 ‚Äì 4 ‚Äì 1, que corresponde √† alternativa D."
  },
  {
    "edicao": 2018,
    "id": "2018-64",
    "numero": 64,
    "enunciado": "Quando um processo na m√°quina A chama um procedimento na m√°quina B, o\nprocesso chamador em A √© suspenso, e a execu√ß√£o do procedimento chamado ocorre em B.\nInforma√ß√µes podem ser transportadas do chamador para quem foi chamado nos par√¢metros e\npodem voltar no resultado do procedimento. Absolutamente nada da troca de mensagens √© vis√≠vel\npara o programador. Esse m√©todo √© conhecido como:",
    "alternativas": [
      "a) Chamada de Procedimento Remoto (RPC).",
      "b) Protocolo Universal de Datagramas (UDP).",
      "c) Protocolo de Transporte em Tempo Real (RTP).",
      "d) Middleware Orientado a Mensagem (MOM).",
      "e) Linguagem de Programa√ß√£o de Interface (IDL)."
    ],
    "area_conhecimento": "Tecnologia de Computa√ß√£o",
    "area": "Sistemas Distribu√≠dos",
    "subarea": "Comunica√ß√£o entre Processos",
    "dificuldade": "F√°cil",
    "gabarito": "A",
    "solucao": "A quest√£o descreve um cen√°rio onde um processo em uma m√°quina A chama um procedimento em uma m√°quina B, e o processo chamador √© suspenso enquanto o procedimento √© executado na m√°quina B. Este √© um comportamento t√≠pico de uma Chamada de Procedimento Remoto (RPC), onde a comunica√ß√£o entre processos em diferentes sistemas √© feita de forma transparente para o programador. O RPC permite que um programa execute um procedimento em outra m√°quina como se fosse local, sem que a troca de mensagens seja vis√≠vel para o programador. As outras alternativas n√£o se encaixam na descri√ß√£o: UDP √© um protocolo de comunica√ß√£o, RTP √© usado para dados em tempo real, MOM √© um middleware para troca de mensagens, e IDL √© uma linguagem para definir interfaces de software."
  },
  {
    "edicao": 2018,
    "id": "2018-65",
    "numero": 65,
    "enunciado": "Qual protocolo que converte nome em string ASCII em endere√ßo de rede?",
    "alternativas": [
      "a) Stringle.",
      "b) DNS.",
      "c) ARP.",
      "d) IP.",
      "e) TCP."
    ],
    "area_conhecimento": "Tecnologia de Computa√ß√£o",
    "area": "Redes de Computadores",
    "subarea": "Protocolos e Servi√ßos de Comunica√ß√£o",
    "dificuldade": "F√°cil",
    "gabarito": "B",
    "solucao": "O protocolo que converte nomes de dom√≠nio em endere√ßos de rede √© o DNS (Domain Name System). Quando um usu√°rio digita um nome de dom√≠nio em um navegador, o DNS √© respons√°vel por traduzir esse nome em um endere√ßo IP, que √© o identificador num√©rico usado para localizar e acessar o recurso na rede. O DNS funciona como uma agenda telef√¥nica da internet, permitindo que os usu√°rios utilizem nomes de dom√≠nio leg√≠veis em vez de endere√ßos IP num√©ricos. Portanto, a alternativa correta √© a B) DNS."
  },
  {
    "edicao": 2018,
    "id": "2018-66",
    "numero": 66,
    "enunciado": "O aprendizado de m√°quina, √© um campo de estudo que:",
    "alternativas": [
      "a) Oferece aos computadores a habilidade de aprender exatamente a fun√ß√£o para a qual foram\nprogramados.",
      "b) D√° aos computadores a habilidade de aprender qualquer problema.",
      "c) D√° aos computadores a habilidade de aprender como um agente deve agir em um ambiente.",
      "d) D√° aos computadores a habilidade de aprender como reduzir erros.",
      "e) D√° aos computadores a habilidade de aprender sem serem explicitamente programados para a\ntarefa."
    ],
    "area_conhecimento": "Tecnologia de Computa√ß√£o",
    "area": "Intelig√™ncia Artificial",
    "subarea": "Aprendizado de M√°quina",
    "dificuldade": "F√°cil",
    "gabarito": "E",
    "solucao": "A quest√£o aborda o conceito fundamental do aprendizado de m√°quina, que √© a capacidade dos computadores de aprenderem sem serem explicitamente programados para uma tarefa espec√≠fica. A alternativa E descreve corretamente essa caracter√≠stica, pois o aprendizado de m√°quina envolve algoritmos que permitem que sistemas melhorem seu desempenho em tarefas com base em dados, sem instru√ß√µes expl√≠citas para cada tarefa. As outras alternativas descrevem conceitos que n√£o s√£o precisos ou s√£o apenas parcialmente corretos em rela√ß√£o ao aprendizado de m√°quina."
  },
  {
    "edicao": 2018,
    "id": "2018-67",
    "numero": 67,
    "enunciado": "Qual √© a classe de algoritmos de sincroniza√ß√£o que assegura que, em um conjunto\nde processos distribu√≠dos, pelo menos, um processo por vez tem acesso a um recurso\ncompartilhado?",
    "alternativas": [
      "a) Rel√≥gios vetoriais.",
      "b) Elei√ß√£o.",
      "c) Exclus√£o m√∫tua distribu√≠da.",
      "d) Rel√≥gios l√≥gicos.",
      "e) Posicionamento global."
    ],
    "area_conhecimento": "Tecnologia de Computa√ß√£o",
    "area": "Sistemas Distribu√≠dos",
    "subarea": "Problemas B√°sicos em Computa√ß√£o Distribu√≠da: Coordena√ß√£o e Sincroniza√ß√£o de Processos, Exclus√£o M√∫tua, Difus√£o de Mensagens",
    "dificuldade": "M√©dia",
    "gabarito": "C",
    "solucao": "A quest√£o est√° perguntando sobre uma classe de algoritmos de sincroniza√ß√£o que garante que, em um conjunto de processos distribu√≠dos, pelo menos um processo por vez tem acesso a um recurso compartilhado. Isso √© exatamente o que a exclus√£o m√∫tua distribu√≠da busca alcan√ßar. A exclus√£o m√∫tua √© um conceito fundamental em sistemas distribu√≠dos e sistemas operacionais, onde se assegura que m√∫ltiplos processos ou threads n√£o acessem simultaneamente um recurso cr√≠tico, evitando assim condi√ß√µes de corrida e inconsist√™ncias. As outras alternativas n√£o se referem diretamente a esse problema: rel√≥gios vetoriais e l√≥gicos s√£o usados para ordena√ß√£o de eventos em sistemas distribu√≠dos, elei√ß√£o √© usada para selecionar um coordenador em um sistema distribu√≠do, e posicionamento global n√£o est√° relacionado ao controle de acesso a recursos."
  },
  {
    "edicao": 2018,
    "id": "2018-69",
    "numero": 69,
    "enunciado": "√Årvores de decis√£o s√£o algoritmos que utilizam:",
    "alternativas": [
      "a) Estruturas de IF-ELSE para realizar aprendizado.",
      "b) Estruturas de repeti√ß√£o alinhadas para realizar aprendizado.",
      "c) Aprendizado estat√≠stico para constru√ß√£o de regras no aprendizado.",
      "d) Exclusivamente fun√ß√µes matem√°ticas como estruturas de dados elementares para realizar\naprendizado.",
      "e) Paradigma de programa√ß√£o em l√≥gica para realizar aprendizado."
    ],
    "area_conhecimento": "Tecnologia de Computa√ß√£o",
    "area": "Intelig√™ncia Artificial",
    "subarea": "√Årvores de Decis√£o, Redes Neurais e Algoritmos Gen√©ticos",
    "dificuldade": "F√°cil",
    "gabarito": "A",
    "solucao": "√Årvores de decis√£o s√£o algoritmos utilizados em aprendizado de m√°quina que tomam decis√µes baseadas em condi√ß√µes l√≥gicas, semelhantes a estruturas de IF-ELSE. Cada n√≥ interno da √°rvore representa uma condi√ß√£o sobre um atributo, cada ramo representa o resultado da condi√ß√£o, e cada folha representa uma classe ou valor de sa√≠da. Portanto, a alternativa correta √© 'A) Estruturas de IF-ELSE para realizar aprendizado.'."
  },
  {
    "edicao": 2018,
    "id": "2018-70",
    "numero": 70,
    "enunciado": "Considere as assertivas abaixo sobre teste de sistema:\nÔÇ∑ O teste de ______________ tem por objetivo fazer o software falhar de diferentes maneiras, a\nfim de verificar a capacidade de recupera√ß√£o do software a um estado normal de funcionamento.\nÔÇ∑ O teste de ______________ exercita o sistema de forma a observar seu desempenho em\nsitua√ß√µes de demanda anormal de recursos, quer em termos de quantidade, frequ√™ncia ou\nvolume.\nÔÇ∑ O teste ___________ exercita o software em cada ambiente ou plataforma no qual deve\nfuncionar. Tamb√©m pode incluir examinar os procedimentos de instala√ß√£o, softwares para a\ninstala√ß√£o (e.g. instaladores), e a documenta√ß√£o usada para apresentar o software ao usu√°rio.\nAssinale a alternativa que preenche, correta e respectivamente, as lacunas das assertivas acima.",
    "alternativas": [
      "a) recupera√ß√£o ‚Äì stress ‚Äì de implanta√ß√£o",
      "b) seguran√ßa ‚Äì stress ‚Äì beta",
      "c) recupera√ß√£o ‚Äì carga ‚Äì de implanta√ß√£o",
      "d) seguran√ßa ‚Äì carga ‚Äì de implanta√ß√£o",
      "e) recupera√ß√£o ‚Äì stress ‚Äì beta"
    ],
    "area_conhecimento": "Tecnologia de Computa√ß√£o",
    "area": "Engenharia de Software",
    "subarea": "Verifica√ß√£o, Valida√ß√£o e Teste",
    "dificuldade": "F√°cil",
    "gabarito": "A",
    "solucao": "Para resolver a quest√£o, precisamos identificar os tipos de testes mencionados nas assertivas e preencher as lacunas corretamente. A primeira assertiva descreve um teste que visa verificar a capacidade de recupera√ß√£o do software, o que se refere ao 'teste de recupera√ß√£o'. A segunda assertiva menciona a avalia√ß√£o do desempenho do sistema sob demanda anormal de recursos, o que √© caracter√≠stico do 'teste de stress'. A terceira assertiva fala sobre testar o software em diferentes ambientes ou plataformas, o que corresponde ao 'teste de implanta√ß√£o'. Portanto, a alternativa correta que preenche as lacunas √© a 'A) recupera√ß√£o ‚Äì stress ‚Äì de implanta√ß√£o'."
  }
]
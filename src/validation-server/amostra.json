[
  {
    "edicao": 2019,
    "id": "2019-09",
    "numero": 9,
    "enunciado": "Simplifique, com a ajuda dos Mapas de Karnaugh, a funÃ§Ã£o cuja expressÃ£o em termos\ncanÃ´nicos Ã©: \\(ğ‘“(ğ‘¥, ğ‘¦, ğ‘§) = âˆ‘ ğ‘š(2,3,4,5,6,7)\\)",
    "alternativas": [
      "a) \\(ğ‘“(ğ‘‹, ğ‘Œ, ğ‘) = ğ‘‹ + ğ‘Œ\\)",
      "b) \\(ğ‘“(ğ‘‹, ğ‘Œ, ğ‘) = ğ‘‹ + ğ‘Œ + ğ‘\\)",
      "c) \\(ğ‘“(ğ‘‹, ğ‘Œ, ğ‘) = \\bar{ğ‘‹} + ğ‘Œ\\)",
      "d) \\(ğ‘“(ğ‘‹, ğ‘Œ, ğ‘) = ğ‘‹ğ‘Œ + ğ‘Œ\\)",
      "e) \\(ğ‘“(ğ‘‹, ğ‘Œ, ğ‘) = ğ‘‹ + ğ‘Œ + \\bar{Z}\\)"
    ],
    "area_conhecimento": "MatemÃ¡tica",
    "area": "MatemÃ¡tica Discreta",
    "subarea": "MinimizaÃ§Ã£o de FunÃ§Ãµes Booleanas",
    "dificuldade": "FÃ¡cil",
    "gabarito": "A",
    "solucao": "Para simplificar a funÃ§Ã£o booleana f(x, y, z) = Î£m(2,3,4,5,6,7) usando o Mapa de Karnaugh, primeiro devemos identificar as combinaÃ§Ãµes de variÃ¡veis correspondentes aos mintermos dados. As combinaÃ§Ãµes sÃ£o: 010, 011, 100, 101, 110, 111. No Mapa de Karnaugh 3x3, essas posiÃ§Ãµes sÃ£o preenchidas com 1. A configuraÃ§Ã£o do mapa Ã© a seguinte:\n\n| xz \\ y | 00 | 01 | 11 | 10 |\n|--------|----|----|----|----|\n| 0      |  0 |  1 |  1 |  0 |\n| 1      |  0 |  1 |  1 |  1 |\n\nAgrupando os 1s adjacentes, podemos formar dois grupos: um grupo de quatro 1s (abrangendo as posiÃ§Ãµes 011, 111, 101, 001) e um grupo de dois 1s (abrangendo as posiÃ§Ãµes 110, 111). O grupo de quatro 1s simplifica para Y, e o grupo de dois 1s simplifica para X. Assim, a expressÃ£o simplificada da funÃ§Ã£o Ã© f(X, Y, Z) = X + Y.",
    "dificuldade_experimental": "Muito DifÃ­cil"
  },
  {
    "edicao": 2019,
    "id": "2019-13",
    "numero": 13,
    "enunciado": "Dez pessoas estÃ£o participando de um campeonato de xadrez. Na primeira rodada\ndo campeonato, haverÃ¡ cinco partidas. De quantas maneiras distintas Ã© possÃ­vel organizar a primeira rodada do campeonato, considerando que nÃ£o hÃ¡ distinÃ§Ã£o entre a partida â€œcompetidor A versus competidor Bâ€ e a partida â€œcompetidor B versus competidor Aâ€?",
    "alternativas": [
      "a) 45.",
      "b) 252.",
      "c) 945.",
      "d) 3.840.",
      "e) 113.400."
    ],
    "area_conhecimento": "MatemÃ¡tica",
    "area": "AnÃ¡lise CombinatÃ³ria",
    "subarea": "CombinaÃ§Ãµes",
    "dificuldade": "MÃ©dia",
    "gabarito": "C",
    "solucao": "Para resolver a questÃ£o, precisamos calcular de quantas maneiras podemos escolher 5 pares de competidores a partir de um grupo de 10 pessoas, sem considerar a ordem dentro dos pares. Isso Ã© um problema de combinaÃ§Ã£o. \n\nPrimeiro, escolhemos 2 pessoas para formar o primeiro par, depois outras 2 para o segundo par, e assim por diante, atÃ© formarmos 5 pares. \n\nO nÃºmero total de maneiras de escolher 2 pessoas de 10 Ã© dado pela combinaÃ§Ã£o de 10 elementos tomados 2 a 2, que Ã© C(10, 2). \n\nC(10, 2) = 10! / (2! * (10-2)!) = 45.\n\nNo entanto, precisamos formar 5 pares, entÃ£o devemos dividir o resultado por 5! para corrigir a contagem, pois a ordem dos pares nÃ£o importa. \n\nAssim, o nÃºmero total de maneiras Ã© dado por: \n\n(10! / (2!^5 * 5!)) = 252.\n\nPortanto, a alternativa correta Ã© B) 252.",
    "dificuldade_experimental": "Muito DifÃ­cil"
  },
  {
    "edicao": 2019,
    "id": "2019-22",
    "numero": 22,
    "enunciado": "Considere as seguintes funÃ§Ãµes:\n\\[ğ‘“(ğ‘›) = 2^ğ‘›\\]\n\\[ğ‘”(ğ‘›) = ğ‘›!\\]\n\\[â„(ğ‘›) = ğ‘›^{\\log n}\\]\nAssinale a alternativa correta a respeito do comportamento assintÃ³tico de \\(f(n)\\), \\(g(n)\\) e \\(h(n)\\).",
    "alternativas": [
      "a) \\(ğ‘“(ğ‘›) = ğ‘‚(ğ‘”(ğ‘›)); ğ‘”(ğ‘›) = ğ‘‚(â„(ğ‘›)).\\)",
      "b) \\(ğ‘“(ğ‘›) = ğ›º(ğ‘”(ğ‘›)); ğ‘”(ğ‘›) = ğ‘‚(â„(ğ‘›)).\\)",
      "c) \\(ğ‘”(ğ‘›) = ğ‘‚(ğ‘“(ğ‘›)); â„(ğ‘›) = ğ‘‚(ğ‘“(ğ‘›)).\\)",
      "d) \\(â„(ğ‘›) = ğ‘‚(ğ‘“(ğ‘›)); ğ‘”(ğ‘›) = ğ›º(ğ‘“(ğ‘›)).\\)",
      "e) Nenhuma das anteriores."
    ],
    "area_conhecimento": "Fundamentos da ComputaÃ§Ã£o",
    "area": "AnÃ¡lise de Algoritmos",
    "subarea": "AnÃ¡lise AssintÃ³tica de Limites de Complexidade",
    "dificuldade": "MÃ©dia",
    "gabarito": "D",
    "solucao": "Para determinar o comportamento assintÃ³tico das funÃ§Ãµes f(n), g(n) e h(n), precisamos comparÃ¡-las em termos de crescimento. \n\n1. f(n) = 2^n: Esta Ã© uma funÃ§Ã£o exponencial, que cresce muito rapidamente Ã  medida que n aumenta.\n2. g(n) = n!: O fatorial de n cresce ainda mais rapidamente do que qualquer funÃ§Ã£o exponencial, pois n! = 1 * 2 * 3 * ... * n.\n3. h(n) = n log n: Esta Ã© uma funÃ§Ã£o que cresce mais lentamente que uma funÃ§Ã£o exponencial, mas mais rapidamente que uma funÃ§Ã£o linear.\n\nAgora, vamos analisar as alternativas:\n\n- A) f(n) = O(g(n)); g(n) = O(h(n)).\n  - f(n) nÃ£o Ã© O(g(n)) porque g(n) cresce mais rapidamente que f(n).\n  - g(n) nÃ£o Ã© O(h(n)) porque g(n) cresce mais rapidamente que h(n).\n\n- B) f(n) = Î©(g(n)); g(n) = O(h(n)).\n  - f(n) nÃ£o Ã© Î©(g(n)) porque g(n) cresce mais rapidamente que f(n).\n  - g(n) nÃ£o Ã© O(h(n)) porque g(n) cresce mais rapidamente que h(n).\n\n- C) g(n) = O(f(n)); h(n) = O(f(n)).\n  - g(n) nÃ£o Ã© O(f(n)) porque g(n) cresce mais rapidamente que f(n).\n  - h(n) Ã© O(f(n)) porque f(n) cresce mais rapidamente que h(n).\n\n- D) h(n) = O(f(n)); g(n) = Î©(f(n)).\n  - h(n) Ã© O(f(n)) porque f(n) cresce mais rapidamente que h(n).\n  - g(n) Ã© Î©(f(n)) porque g(n) cresce mais rapidamente que f(n).\n\n- E) Nenhuma das anteriores.\n  - Esta Ã© a alternativa correta, pois as outras alternativas contÃªm afirmaÃ§Ãµes incorretas sobre o comportamento assintÃ³tico das funÃ§Ãµes.\n\nPortanto, a alternativa correta Ã© E.",
    "dificuldade_experimental": "Muito DifÃ­cil"
  },
  {
    "edicao": 2019,
    "id": "2019-34",
    "numero": 34,
    "enunciado": "Suponha que existem registros lÃ³gicos que agregam vÃ¡rios campos (atributos) e que\nse deseja encontrar registros com base em algum campo de pesquisa, fornecendo algum valor (chave). Considerando estruturas de dados que tornem essa busca eficiente, analise as assertivas abaixo e assinale V, se verdadeiras, ou F, se falsas.\\\n( ) Uma estrutura baseada em hash Ã© bastante eficiente para pesquisas baseadas em chave, pois permite encontrar o(s) registro(s) correspondente(s) Ã  chave em, no mÃ¡ximo, um acesso Ã  estrutura.\\\n( ) As Ã¡rvores digitais de pesquisa nÃ£o tratam as chaves como elementos indivisÃ­veis e, por isso, sÃ£o adequadas em casos em que hÃ¡ interesse em fazer buscas sobre parte do valor da chave (ex .: prefixo).\\\n( ) Ãrvores binÃ¡rias de pesquisa, nas quais os nodos correspondem Ã s chaves, sempre permitem uma busca baseada em chave mais eficiente quando comparada Ã s listas ordenadas pelas chaves.\\\nA ordem correta de preenchimento dos parÃªnteses, de cima para baixo, Ã©:",
    "alternativas": [
      "a) V â€“ F â€“ V.",
      "b) F â€“ V â€“ F.",
      "c) F â€“ F â€“ F.",
      "d) F â€“ V â€“ V.",
      "e) V â€“ V â€“ F."
    ],
    "area_conhecimento": "Fundamentos da ComputaÃ§Ã£o",
    "area": "Algoritmos e Estrutura de Dados",
    "subarea": "Tabelas Hash",
    "dificuldade": "MÃ©dia",
    "gabarito": "B",
    "solucao": "Vamos analisar cada assertiva: \n\n1. 'Uma estrutura baseada em hash Ã© bastante eficiente para pesquisas baseadas em chave, pois permite encontrar o(s) registro(s) correspondente(s) Ã  chave em, no mÃ¡ximo, um acesso Ã  estrutura.' - Esta assertiva Ã© falsa. Estruturas de dados baseadas em hash sÃ£o eficientes para buscas, mas nÃ£o garantem encontrar a chave em um Ãºnico acesso devido a possÃ­veis colisÃµes que podem exigir resoluÃ§Ã£o atravÃ©s de tÃ©cnicas como encadeamento ou endereÃ§amento aberto.\n\n2. 'As Ã¡rvores digitais de pesquisa nÃ£o tratam as chaves como elementos indivisÃ­veis e, por isso, sÃ£o adequadas em casos em que hÃ¡ interesse em fazer buscas sobre parte do valor da chave (ex.: prefixo).' - Esta assertiva Ã© verdadeira. Ãrvores digitais, como tries, sÃ£o projetadas para lidar com chaves que podem ser divididas em partes, permitindo buscas eficientes por prefixos.\n\n3. 'Ãrvores binÃ¡rias de pesquisa, nas quais os nodos correspondem Ã s chaves, sempre permitem uma busca baseada em chave mais eficiente quando comparada Ã s listas ordenadas pelas chaves.' - Esta assertiva Ã© falsa. Ãrvores binÃ¡rias de pesquisa podem ter desempenho ruim (O(n)) em casos degenerados (quando a Ã¡rvore se comporta como uma lista), enquanto listas ordenadas tÃªm busca binÃ¡ria com complexidade O(log n).\n\nPortanto, a sequÃªncia correta Ã© F â€“ V â€“ F, correspondendo Ã  alternativa B.",
    "dificuldade_experimental": "Muito DifÃ­cil"
  },
  {
    "edicao": 2019,
    "id": "2019-35",
    "numero": 35,
    "enunciado": "Uma tÃ©cnica de compressÃ£o de dados converte um bitstream de entrada (mensagem\nde entrada) em outro bitstream comprimido (mensagem comprimida). Algumas tÃ©cnicas de\ncompressÃ£o dependem de uma tabela de sÃ­mbolos, definida nesse contexto como uma estrutura de dados que associa caracteres (ou sequÃªncia de caracteres) a cÃ³digos utilizados para representar a mensagem comprimida. \\\nAnalise as seguintes assertivas sobre uso de uma tabela de sÃ­mbolos na tÃ©cnica de compressÃ£o LZW (Lempel, Ziv e Welch) e assinale V, se verdadeiras, ou F, se falsas.\\\n( ) A tabela de sÃ­mbolos associa caracteres individuais com cÃ³digos de tamanho variÃ¡vel (bitstreams), cujo tamanho estÃ¡ relacionado Ã  frequÃªncia de um caractere. Quanto mais frequente for um caractere na mensagem original, menos bits sÃ£o usados para representÃ¡-lo.\\\n( ) A tabela de sÃ­mbolos Ã© incluÃ­da no inÃ­cio da mensagem comprimida. Para descomprimir a mensagem, o primeiro passo Ã© extrair essa tabela de sÃ­mbolos, para entÃ£o usÃ¡-la na decodificaÃ§Ã£o da mensagem original. \\\n( ) Uma estrutura de dados adequada para implementaÃ§Ã£o da tabela de sÃ­mbolos na tÃ©cnica LWZ Ã© uma Ã¡rvore trie, devido Ã s operaÃ§Ãµes que essa tÃ©cnica precisa realizar sobre a tabela de sÃ­mbolos para efetuar a compressÃ£o.\\\nA ordem correta de preenchimento dos parÃªnteses, de cima para baixo, Ã©:",
    "alternativas": [
      "a) F â€“ V â€“ V.",
      "b) V â€“ V â€“ F.",
      "c) F â€“ F â€“ F.",
      "d) F â€“ F â€“ V.",
      "e) V â€“ F â€“ V."
    ],
    "area_conhecimento": "Fundamentos da ComputaÃ§Ã£o",
    "area": "OrganizaÃ§Ã£o de Arquivos e Dados",
    "subarea": "CompressÃ£o de Dados",
    "dificuldade": "MÃ©dia",
    "gabarito": "D",
    "solucao": "Vamos analisar cada assertiva: \n\n1. A primeira assertiva afirma que a tabela de sÃ­mbolos associa caracteres individuais com cÃ³digos de tamanho variÃ¡vel, relacionados Ã  frequÃªncia dos caracteres. Isso descreve a tÃ©cnica de compressÃ£o de Huffman, nÃ£o LZW. No LZW, os cÃ³digos sÃ£o de tamanho fixo e nÃ£o dependem da frequÃªncia, portanto, essa assertiva Ã© falsa.\n\n2. A segunda assertiva afirma que a tabela de sÃ­mbolos Ã© incluÃ­da no inÃ­cio da mensagem comprimida. No LZW, a tabela de sÃ­mbolos Ã© construÃ­da dinamicamente durante a compressÃ£o e descompressÃ£o, e nÃ£o Ã© enviada junto com a mensagem comprimida. Portanto, essa assertiva Ã© falsa.\n\n3. A terceira assertiva sugere que uma Ã¡rvore trie Ã© uma estrutura de dados adequada para a tabela de sÃ­mbolos no LZW. Isso Ã© verdadeiro, pois uma trie pode ser usada para armazenar e buscar sequÃªncias de caracteres de forma eficiente, o que Ã© necessÃ¡rio para a tÃ©cnica LZW.\n\nPortanto, a ordem correta Ã© F â€“ F â€“ V, correspondendo Ã  alternativa D.",
    "dificuldade_experimental": "Muito DifÃ­cil"
  },
  {
    "edicao": 2019,
    "id": "2019-36",
    "numero": 36,
    "enunciado": "Um mapa rodoviÃ¡rio Ã© modelado como um grafo em que os vÃ©rtices representam\ninterseÃ§Ãµes. As arestas representam segmentos de estrada entre interseÃ§Ãµes. O peso de cada aresta representa a distÃ¢ncia entre interseÃ§Ãµes. Agora, considere que um motorista deseja obter o caminho mais curto entre duas cidades. Dado um mapa contendo as distÃ¢ncias entre cada par de interseÃ§Ãµes adjacentes, como obter o caminho mais curto entre duas cidades?",
    "alternativas": [
      "a) Caminho mais curto com destino Ãºnico.",
      "b) Caminho gerador mÃ­nimo de origem Ãºnica.",
      "c) Caminho mais curto com origem Ãºnica.",
      "d) Caminho mais curto entre todos os pares de vÃ©rtices.",
      "e) Caminho gerador mÃ­nimo de origem mÃºltipla."
    ],
    "area_conhecimento": "Fundamentos da ComputaÃ§Ã£o",
    "area": "Teoria dos Grafos",
    "subarea": "Algoritmos do Menor Caminho",
    "dificuldade": "FÃ¡cil",
    "gabarito": "C",
    "solucao": "A questÃ£o descreve um problema clÃ¡ssico de encontrar o caminho mais curto entre duas cidades em um mapa rodoviÃ¡rio modelado como um grafo. Neste contexto, o problema Ã© resolvido utilizando algoritmos de menor caminho com origem Ãºnica, como o algoritmo de Dijkstra ou o algoritmo de Bellman-Ford. Esses algoritmos sÃ£o projetados para encontrar o caminho mais curto de um Ãºnico vÃ©rtice de origem para todos os outros vÃ©rtices no grafo, permitindo assim determinar o caminho mais curto para um vÃ©rtice de destino especÃ­fico. Portanto, a alternativa correta Ã© 'C) Caminho mais curto com origem Ãºnica.'.",
    "dificuldade_experimental": "Muito DifÃ­cil"
  },
  {
    "edicao": 2019,
    "id": "2019-40",
    "numero": 40,
    "enunciado": "Considere as seguintes afirmaÃ§Ãµes sobre classes de problemas: \\\nI. O problema de decisÃ£o CAM, descrito a seguir, pertence Ã  classe de complexidade P. \\\nCAM (caminho em grafo)\\\nEntrada: uma tripla \\((G,a,b)\\) em que \n- G Ã© um grafo\n- a e b sÃ£o nodos de G \\\nPergunta: Existe caminho em G iniciando em a e terminando em b? \\\nII. Um problema X pertence Ã  classe de problemas NP-completos quando satisfaz Ã s seguintes condiÃ§Ãµes:\n- X pertence Ã  classe NP, e\n- todo problema Y da classe NP pode ser reduzido em tempo polinomial a X. \\\nIII. Se um problema de decisÃ£o X pertence Ã  classe P, entÃ£o o complemento do problema X (problema com as mesmas instÃ¢ncias que X, porÃ©m com as respectivas respostas invertidas) pertence Ã  classe NP.\\\nQuais estÃ£o corretas?",
    "alternativas": [
      "a) Apenas I.",
      "b) Apenas III.",
      "c) Apenas I e II.",
      "d) Apenas II e III.",
      "e) I, II e III."
    ],
    "area_conhecimento": "Fundamentos da ComputaÃ§Ã£o",
    "area": "Linguagens Formais, AutÃ´matos e Computabilidade",
    "subarea": "Classes de Problemas P, NP, NP Completo e NP-DifÃ­cil",
    "dificuldade": "MÃ©dia",
    "gabarito": "E",
    "solucao": "Vamos analisar cada uma das afirmaÃ§Ãµes: \n\nI. O problema CAM (caminho em grafo) Ã© um problema de decisÃ£o que pergunta se existe um caminho entre dois nÃ³s em um grafo. Este problema pode ser resolvido utilizando algoritmos de busca em largura (BFS) ou busca em profundidade (DFS), ambos com complexidade polinomial em relaÃ§Ã£o ao nÃºmero de vÃ©rtices e arestas do grafo. Portanto, a afirmaÃ§Ã£o I estÃ¡ correta, pois CAM pertence Ã  classe P.\n\nII. A definiÃ§Ã£o de um problema NP-completo Ã© que ele deve pertencer Ã  classe NP e que todo problema na classe NP deve ser redutÃ­vel a ele em tempo polinomial. A afirmaÃ§Ã£o II estÃ¡ correta, pois descreve precisamente a definiÃ§Ã£o de NP-completude.\n\nIII. Se um problema de decisÃ£o X pertence Ã  classe P, entÃ£o ele pode ser resolvido em tempo polinomial. O complemento de X, que inverte as respostas, nÃ£o necessariamente pertence Ã  classe NP, a menos que P = NP. Portanto, a afirmaÃ§Ã£o III estÃ¡ incorreta, pois nÃ£o hÃ¡ garantia de que o complemento de um problema em P esteja em NP.\n\nAssim, as afirmaÃ§Ãµes corretas sÃ£o I e II, o que nos leva Ã  alternativa C.",
    "dificuldade_experimental": "Muito DifÃ­cil"
  },
  {
    "edicao": 2019,
    "id": "2019-45",
    "numero": 45,
    "enunciado": "Considere o programa abaixo escrito em linguagem C. No instante da execuÃ§Ã£o da\nlinha 5, ter-se-Ã¡ uma hierarquia composta de quantos processos e threads, respectivamente?\n```\n\n1    main(){\n2    int i;\n3    for(i=0;i<3;i++)\n4       fork();\n5    while(1);\n6    }\n\n```",
    "alternativas": [
      "a) 1 e 0.",
      "b) 3 e 0.",
      "c) 4 e 1.",
      "d) 7 e 7.",
      "e) 8 e 8."
    ],
    "area_conhecimento": "Fundamentos da ComputaÃ§Ã£o",
    "area": "Sistemas Operacionais",
    "subarea": "GerÃªncia de Processos",
    "dificuldade": "MÃ©dia",
    "gabarito": "E",
    "solucao": "O programa em questÃ£o utiliza a funÃ§Ã£o fork() dentro de um loop que itera 3 vezes. A funÃ§Ã£o fork() Ã© responsÃ¡vel por criar um novo processo filho que Ã© uma cÃ³pia do processo pai. Cada chamada a fork() duplica o nÃºmero de processos existentes. Inicialmente, hÃ¡ 1 processo (o processo principal). ApÃ³s a primeira iteraÃ§Ã£o do loop, hÃ¡ 2 processos. ApÃ³s a segunda iteraÃ§Ã£o, cada um dos 2 processos cria mais um processo, totalizando 4 processos. Na terceira iteraÃ§Ã£o, cada um dos 4 processos cria mais um processo, resultando em 8 processos no total. NÃ£o hÃ¡ criaÃ§Ã£o de threads, apenas processos. Portanto, no instante da execuÃ§Ã£o da linha 5, haverÃ¡ 8 processos e 0 threads.",
    "dificuldade_experimental": "Muito DifÃ­cil"
  },
  {
    "edicao": 2019,
    "id": "2019-46",
    "numero": 46,
    "enunciado": "Um dispositivo de E/S pode acionar o seu software controlador (device driver) para\nrealizar uma tarefa enquanto este esteja realizando o tratamento de outra tarefa do dispositivo. Por exemplo, enquanto o device driver da placa de rede processa um pacote que acabou de chegar, ele Ã© interrompido para tratar a chegada de um novo pacote. Essa caracterÃ­stica de um device driver Ã© denominada cÃ³digo:",
    "alternativas": [
      "a) AssÃ­ncrono.",
      "b) AssimÃ©trico.",
      "c) ElÃ¡stico.",
      "d) Reentrante.",
      "e) Recursivo."
    ],
    "area_conhecimento": "Fundamentos da ComputaÃ§Ã£o",
    "area": "Sistemas Operacionais",
    "subarea": "Gerenciamento de Dispositivos de Entrada/SaÃ­da",
    "dificuldade": "MÃ©dia",
    "gabarito": "D",
    "solucao": "A questÃ£o descreve um cenÃ¡rio em que um device driver Ã© interrompido para tratar a chegada de um novo pacote enquanto ainda estÃ¡ processando outro. Isso caracteriza um cÃ³digo reentrante. Um cÃ³digo reentrante Ã© aquele que pode ser interrompido no meio de sua execuÃ§Ã£o e ser chamado novamente ('reentrado') antes que a execuÃ§Ã£o anterior seja concluÃ­da. Isso Ã© essencial em sistemas multitarefa e em ambientes onde interrupÃ§Ãµes sÃ£o comuns, como no caso de drivers de dispositivos. Portanto, a alternativa correta Ã© 'D) Reentrante'.",
    "dificuldade_experimental": "Muito DifÃ­cil"
  },
  {
    "edicao": 2019,
    "id": "2019-47",
    "numero": 47,
    "enunciado": "Seja um circuito lÃ³gico com trÃªs entradas, A, B, C, e uma saÃ­da S. Considerando que\no valor da saÃ­da S Ã© igual ao valor da entrada A quando as entradas B e C estÃ£o no mesmo nÃ­vel\nlÃ³gico, e que o valor da saÃ­da S Ã© igual ao inverso do valor da entrada A quando as entradas B e C\nestÃ£o em nÃ­veis lÃ³gicos opostos, assinale a alternativa que apresenta a expressÃ£o lÃ³gica\ncorrespondente ao circuito.",
    "alternativas": [
      "a) \\(ğ‘† = ğ´ \\cdot ğµâŠ•C\\)",
      "b) \\(ğ‘† = ğ´ âŠ• B âŠ• C\\)",
      "c) \\(ğ‘† = \\overline{ğ´} âŠ• B âŠ• C\\)",
      "d) \\(ğ‘† = ğ´ âŠ• \\overline{ğµ âŠ• C}\\)",
      "e) \\(ğ‘† = \\overline{ğ´ âŠ• B âŠ• C}\\)"
    ],
    "area_conhecimento": "Fundamentos da ComputaÃ§Ã£o",
    "area": "Circuitos Digitais",
    "subarea": "RepresentaÃ§Ã£o e ManipulaÃ§Ã£o de Circuitos CombinatÃ³rios",
    "dificuldade": "MÃ©dia",
    "gabarito": "B",
    "solucao": "Para resolver essa questÃ£o, precisamos entender a condiÃ§Ã£o para a saÃ­da S do circuito lÃ³gico. A saÃ­da S Ã© igual ao valor da entrada A quando B e C estÃ£o no mesmo nÃ­vel lÃ³gico, ou seja, quando B = C. Isso pode ser representado pela expressÃ£o lÃ³gica BâŠ•C = 0, pois o XOR (âŠ•) entre dois bits Ã© 0 quando ambos sÃ£o iguais. Portanto, S = A quando BâŠ•C = 0. Quando B e C estÃ£o em nÃ­veis lÃ³gicos opostos, ou seja, B â‰  C, o XOR (BâŠ•C) Ã© 1, e a saÃ­da S Ã© o inverso de A, ou seja, S = A'. A expressÃ£o lÃ³gica que satisfaz essas condiÃ§Ãµes Ã© S = Aâˆ™(BâŠ•C)' + A'âˆ™(BâŠ•C). Simplificando, isso resulta em S = Aâˆ™(BâŠ•C)'. A alternativa que corresponde a essa expressÃ£o Ã© a alternativa A) ğ‘† = ğ´ âˆ™ ğµâŠ•C.",
    "dificuldade_experimental": "Muito DifÃ­cil"
  },
  {
    "edicao": 2019,
    "id": "2019-53",
    "numero": 53,
    "enunciado": "Analise as assertivas abaixo sobre testes de regressÃ£o e assinale V, se verdadeiras,\nou F, se falsas.\\\n( ) Uma suite de testes de regressÃ£o bem planejada deve conter dois tipos de casos de teste: aqueles focados nos componentes diretamente relacionados Ã  mudanÃ§a e aqueles que exercitem funcionalidades jÃ¡ existentes que possam ter sido afetadas pela mudanÃ§a.\\\n( ) A execuÃ§Ã£o manual de testes de regressÃ£o Ã© inviÃ¡vel.\\\n( ) Testes de regressÃ£o podem estar relacionados tanto a testes funcionais quanto a testes nÃ£o funcionais.\\\nA ordem correta de preenchimento dos parÃªnteses, de cima para baixo, Ã©:",
    "alternativas": [
      "a) F â€“ V â€“ F.",
      "b) V â€“ V â€“ V.",
      "c) V â€“ F â€“ V.",
      "d) F â€“ F â€“ F.",
      "e) F â€“ F â€“ V."
    ],
    "area_conhecimento": "Tecnologia de ComputaÃ§Ã£o",
    "area": "Engenharia de Software",
    "subarea": "VerificaÃ§Ã£o, ValidaÃ§Ã£o e Teste",
    "dificuldade": "MÃ©dia",
    "gabarito": "E",
    "solucao": "Vamos analisar cada assertiva:\n\n1. \"Uma suite de testes de regressÃ£o bem planejada deve conter dois tipos de casos de teste: aqueles focados nos componentes diretamente relacionados Ã  mudanÃ§a e aqueles que exercitem funcionalidades jÃ¡ existentes que possam ter sido afetadas pela mudanÃ§a.\" - Esta assertiva Ã© verdadeira. Uma suite de testes de regressÃ£o deve garantir que as mudanÃ§as nÃ£o afetem negativamente as funcionalidades existentes, alÃ©m de testar as novas alteraÃ§Ãµes.\n\n2. \"A execuÃ§Ã£o manual de testes de regressÃ£o Ã© inviÃ¡vel.\" - Esta assertiva Ã© falsa. Embora a automaÃ§Ã£o de testes de regressÃ£o seja altamente recomendada para eficiÃªncia e consistÃªncia, a execuÃ§Ã£o manual nÃ£o Ã© inviÃ¡vel. Em alguns casos, pode ser necessÃ¡rio realizar testes manuais, especialmente quando a automaÃ§Ã£o nÃ£o Ã© possÃ­vel ou prÃ¡tica.\n\n3. \"Testes de regressÃ£o podem estar relacionados tanto a testes funcionais quanto a testes nÃ£o funcionais.\" - Esta assertiva Ã© verdadeira. Testes de regressÃ£o podem incluir testes funcionais, que verificam se as funcionalidades do software estÃ£o corretas, e testes nÃ£o funcionais, que podem verificar aspectos como desempenho e seguranÃ§a.\n\nPortanto, a ordem correta Ã©: V â€“ F â€“ V.",
    "dificuldade_experimental": "Muito DifÃ­cil"
  },
  {
    "edicao": 2019,
    "id": "2019-55",
    "numero": 55,
    "enunciado": "Em relaÃ§Ã£o ao algoritmo ARIES para a recuperaÃ§Ã£o apÃ³s falha em sistemas de banco\nde dados, analise as assertivas abaixo e assinale V, se verdadeiras, ou F, se falsas.\\\n( ) A aplicaÃ§Ã£o da operaÃ§Ã£o REDO Ã© restrita a transaÃ§Ãµes confirmadas.\\\n( ) Uma abordagem steal/no-force Ã© usada para as regras que governam quando uma pÃ¡gina do cache do banco de dados pode ser gravada no disco.\\\n( ) As operaÃ§Ãµes UNDO sÃ£o registradas no log, para evitar a repetiÃ§Ã£o das operaÃ§Ãµes UNDO completadas, se ocorrer uma falha durante o processo de recuperaÃ§Ã£o.\\\n( ) A Tabela de TransaÃ§Ãµes contÃ©m uma entrada para cada pÃ¡gina suja no cache, que inclui o identificador da pÃ¡gina e o nÃºmero de sequÃªncia de log da atualizaÃ§Ã£o mais antiga dessa pÃ¡gina.\\\nA ordem correta de preenchimento dos parÃªnteses, de cima para baixo, Ã©:",
    "alternativas": [
      "a) F â€“ V â€“ V â€“ F.",
      "b) V â€“ F â€“ F â€“ V.",
      "c) F â€“ V â€“ F â€“ V.",
      "d) V â€“ F â€“ V â€“ F.",
      "e) V â€“ F â€“ V â€“ V."
    ],
    "area_conhecimento": "Tecnologia de ComputaÃ§Ã£o",
    "area": "Banco de Dados",
    "subarea": "Sistemas de Gerenciamento de Bancos de Dados (SGBD): Arquitetura, SeguranÃ§a, Integridade, ConcorrÃªncia, RecuperaÃ§Ã£o apÃ³s Falha, Gerenciamento de TransaÃ§Ãµes",
    "dificuldade": "MÃ©dia",
    "gabarito": "A",
    "solucao": "Vamos analisar cada assertiva para determinar se sÃ£o verdadeiras ou falsas:\n\n1) 'A aplicaÃ§Ã£o da operaÃ§Ã£o REDO Ã© restrita a transaÃ§Ãµes confirmadas.' - Falso. No algoritmo ARIES, a operaÃ§Ã£o REDO Ã© aplicada nÃ£o apenas a transaÃ§Ãµes confirmadas, mas tambÃ©m a transaÃ§Ãµes que podem nÃ£o ter sido confirmadas, pois o objetivo Ã© garantir que todas as alteraÃ§Ãµes feitas antes da falha sejam reaplicadas.\n\n2) 'Uma abordagem steal/no-force Ã© usada para as regras que governam quando uma pÃ¡gina do cache do banco de dados pode ser gravada no disco.' - Verdadeiro. ARIES utiliza a polÃ­tica steal/no-force, permitindo que pÃ¡ginas sujas sejam gravadas no disco antes da confirmaÃ§Ã£o da transaÃ§Ã£o (steal) e nÃ£o forÃ§ando a gravaÃ§Ã£o de pÃ¡ginas no disco no momento da confirmaÃ§Ã£o da transaÃ§Ã£o (no-force).\n\n3) 'As operaÃ§Ãµes UNDO sÃ£o registradas no log, para evitar a repetiÃ§Ã£o das operaÃ§Ãµes UNDO completadas, se ocorrer uma falha durante o processo de recuperaÃ§Ã£o.' - Verdadeiro. ARIES registra as operaÃ§Ãµes UNDO no log para garantir que, em caso de falha durante a recuperaÃ§Ã£o, as operaÃ§Ãµes UNDO jÃ¡ realizadas nÃ£o sejam repetidas.\n\n4) 'A Tabela de TransaÃ§Ãµes contÃ©m uma entrada para cada pÃ¡gina suja no cache, que inclui o identificador da pÃ¡gina e o nÃºmero de sequÃªncia de log da atualizaÃ§Ã£o mais antiga dessa pÃ¡gina.' - Falso. A Tabela de TransaÃ§Ãµes contÃ©m informaÃ§Ãµes sobre transaÃ§Ãµes ativas e nÃ£o sobre pÃ¡ginas sujas. A descriÃ§Ã£o dada se refere Ã  Tabela de PÃ¡ginas Sujas (Dirty Page Table), nÃ£o Ã  Tabela de TransaÃ§Ãµes.\n\nPortanto, a ordem correta Ã© F â€“ V â€“ V â€“ F, que corresponde Ã  alternativa D.",
    "dificuldade_experimental": "Muito DifÃ­cil"
  },
  {
    "edicao": 2019,
    "id": "2019-56",
    "numero": 56,
    "enunciado": "Analise as seguintes assertivas sobre padrÃµes arquiteturais de software e assinale V,\nse verdadeiras, ou F, se falsas.\\\n( ) Mesmo que um dado padrÃ£o arquitetural ofereÃ§a uma soluÃ§Ã£o para o problema sendo resolvido, nem sempre ele Ã© adequado. Fatores como contexto e o sistema de forÃ§as que afeta a soluÃ§Ã£o fazem tambÃ©m parte do processo de avaliaÃ§Ã£o e da escolha de padrÃµes adequados.\\\n( ) PadrÃ£o MVC Ã© uma adaptaÃ§Ã£o do padrÃ£o arquitetural Camadas. A Camada VisÃ£o lida com a apresentaÃ§Ã£o e a manipulaÃ§Ã£o da interface, a Camada Modelo organiza os objetos especÃ­ficos da aplicaÃ§Ã£o, e a Camada Controle posiciona-se entre estas duas com as regras do negÃ³cio.\\\n( ) O padrÃ£o Broker Ã© voltado a problemas de ambientes distribuÃ­dos. Sugere uma arquitetura na qual um componente (broker) estabelece uma mediaÃ§Ã£o que permite um desacoplamento entre clientes e servidores.\\\nA ordem correta de preenchimento dos parÃªnteses, de cima para baixo, Ã©:",
    "alternativas": [
      "a) V â€“ V â€“ V.",
      "b) F â€“ F â€“ V.",
      "c) V â€“ V â€“ F.",
      "d) V â€“ F â€“ V.",
      "e) F â€“ V â€“ F."
    ],
    "area_conhecimento": "Tecnologia de ComputaÃ§Ã£o",
    "area": "Engenharia de Software",
    "subarea": "PadrÃµes de Desenvolvimento",
    "dificuldade": "MÃ©dia",
    "gabarito": "D",
    "solucao": "Vamos analisar cada assertiva separadamente:\n\n1. A primeira assertiva afirma que, mesmo que um padrÃ£o arquitetural ofereÃ§a uma soluÃ§Ã£o para um problema, ele pode nÃ£o ser adequado devido a fatores como contexto e forÃ§as que afetam a soluÃ§Ã£o. Isso Ã© verdadeiro, pois a escolha de um padrÃ£o arquitetural depende de vÃ¡rios fatores contextuais e nÃ£o apenas da soluÃ§Ã£o que ele oferece.\n\n2. A segunda assertiva descreve o padrÃ£o MVC como uma adaptaÃ§Ã£o do padrÃ£o arquitetural de Camadas, com a Camada VisÃ£o lidando com a interface, a Camada Modelo organizando os objetos da aplicaÃ§Ã£o e a Camada Controle contendo as regras de negÃ³cio. Esta assertiva Ã© falsa. No padrÃ£o MVC, a Camada Controle nÃ£o Ã© responsÃ¡vel pelas regras de negÃ³cio, mas sim pela mediaÃ§Ã£o entre a VisÃ£o e o Modelo. As regras de negÃ³cio geralmente residem no Modelo.\n\n3. A terceira assertiva descreve o padrÃ£o Broker como voltado para ambientes distribuÃ­dos, onde um componente broker mediarÃ¡ a comunicaÃ§Ã£o entre clientes e servidores, promovendo o desacoplamento. Esta descriÃ§Ã£o estÃ¡ correta, pois o padrÃ£o Broker Ã© de fato utilizado para tal finalidade em sistemas distribuÃ­dos.\n\nPortanto, a ordem correta Ã©: V â€“ F â€“ V, correspondendo Ã  alternativa D.",
    "dificuldade_experimental": "Muito DifÃ­cil"
  },
  {
    "edicao": 2019,
    "id": "2019-58",
    "numero": 58,
    "enunciado": "Como se denomina uma fonte de luz que esteja a uma distÃ¢ncia infinita de uma cena,\ngerando uma iluminaÃ§Ã£o similar Ã  da luz do Sol?",
    "alternativas": [
      "a) Pontual.",
      "b) Ambiente.",
      "c) Direcional.",
      "d) Spot.",
      "e) Difusa."
    ],
    "area_conhecimento": "Tecnologia de ComputaÃ§Ã£o",
    "area": "ComputaÃ§Ã£o GrÃ¡fica",
    "subarea": "O Processo de 'Rendering': Fontes de Luz, RemoÃ§Ã£o de Linhas e SuperfÃ­cies Ocultas",
    "dificuldade": "FÃ¡cil",
    "gabarito": "C",
    "solucao": "A questÃ£o pergunta sobre o tipo de fonte de luz que, estando a uma distÃ¢ncia infinita, gera uma iluminaÃ§Ã£o semelhante Ã  luz do Sol. Em computaÃ§Ã£o grÃ¡fica, uma 'luz direcional' Ã© usada para simular a luz do Sol. Isso ocorre porque a luz direcional Ã© modelada como tendo raios de luz paralelos, o que Ã© uma boa aproximaÃ§Ã£o para a luz solar devido Ã  grande distÃ¢ncia do Sol em relaÃ§Ã£o Ã  Terra. As outras opÃ§Ãµes nÃ£o se encaixam: uma luz 'pontual' emite luz em todas as direÃ§Ãµes a partir de um ponto especÃ­fico, uma luz 'ambiente' Ã© uma iluminaÃ§Ã£o geral sem direÃ§Ã£o especÃ­fica, uma luz 'spot' Ã© direcionada e focada em um ponto especÃ­fico, e uma luz 'difusa' se refere Ã  dispersÃ£o da luz em vÃ¡rias direÃ§Ãµes. Portanto, a alternativa correta Ã© 'C) Direcional.'.",
    "dificuldade_experimental": "Muito DifÃ­cil"
  },
  {
    "edicao": 2019,
    "id": "2019-59",
    "numero": 59,
    "enunciado": "A realizaÃ§Ã£o da equalizaÃ§Ã£o do histograma de uma imagem resulta em obter:",
    "alternativas": [
      "a) O realce mÃ­nimo de detalhes.",
      "b) Uma transformaÃ§Ã£o de domÃ­nio de cores.",
      "c) A maior compressibilidade da informaÃ§Ã£o.",
      "d) A menor discriminabilidade dos objetos.",
      "e) A mÃ¡xima variÃ¢ncia do histograma."
    ],
    "area_conhecimento": "Tecnologia de ComputaÃ§Ã£o",
    "area": "Processamento de Imagens",
    "subarea": "Realce",
    "dificuldade": "MÃ©dia",
    "gabarito": "E",
    "solucao": "A equalizaÃ§Ã£o do histograma Ã© uma tÃ©cnica de processamento de imagens usada para melhorar o contraste de uma imagem. O objetivo Ã© redistribuir os valores de intensidade de modo que o histograma da imagem resultante seja aproximadamente uniforme. Isso significa que a variÃ¢ncia do histograma Ã© maximizada, pois os nÃ­veis de cinza sÃ£o distribuÃ­dos de forma mais uniforme ao longo do intervalo de intensidade. Portanto, a alternativa correta Ã© 'E) A mÃ¡xima variÃ¢ncia do histograma.'.",
    "dificuldade_experimental": "Muito DifÃ­cil"
  },
  {
    "edicao": 2019,
    "id": "2019-62",
    "numero": 62,
    "enunciado": "Sobre transparÃªncia em sistemas distribuÃ­dos, Ã© correto afirmar que:",
    "alternativas": [
      "a) TransparÃªncia de concorrÃªncia trata de ocultar diferenÃ§as em representaÃ§Ãµes de dados e do modo\ncomo os recursos podem ser acessados pelos usuÃ¡rios.",
      "b) TransparÃªncia de migraÃ§Ã£o Ã© a situaÃ§Ã£o na qual recursos podem ser relocados enquanto estÃ£o sendo acessados, sem que o usuÃ¡rio ou a aplicaÃ§Ã£o percebam.",
      "c) TransparÃªncia de replicaÃ§Ã£o oculta o fato de que existem vÃ¡rias cÃ³pias do recurso.",
      "d) Na transparÃªncia de relocaÃ§Ã£o, recursos podem ser movimentados sem afetar o modo como podem ser acessados.",
      "e) TransparÃªncia de acesso refere-se ao fato de que os usuÃ¡rios nÃ£o podem dizer qual Ã© a localizaÃ§Ã£o fÃ­sica de um recurso no sistema."
    ],
    "area_conhecimento": "Tecnologia de ComputaÃ§Ã£o",
    "area": "Sistemas DistribuÃ­dos",
    "subarea": "Sistemas Operacionais DistribuÃ­dos: Sistemas de Arquivos, Servidores de Nomes, MemÃ³ria Compartilhada, SeguranÃ§a",
    "dificuldade": "MÃ©dia",
    "gabarito": "C",
    "solucao": "A questÃ£o aborda o conceito de transparÃªncia em sistemas distribuÃ­dos, que Ã© a capacidade de ocultar dos usuÃ¡rios e aplicaÃ§Ãµes as complexidades inerentes ao funcionamento de um sistema distribuÃ­do. A alternativa B estÃ¡ correta porque descreve a transparÃªncia de migraÃ§Ã£o, que Ã© a capacidade de mover recursos ou processos de um local para outro sem que o usuÃ¡rio ou a aplicaÃ§Ã£o percebam a mudanÃ§a. Esta Ã© uma caracterÃ­stica desejÃ¡vel em sistemas distribuÃ­dos para garantir continuidade e eficiÃªncia. As outras alternativas descrevem incorretamente os tipos de transparÃªncia: A) descreve a transparÃªncia de acesso, C) estÃ¡ correta sobre replicaÃ§Ã£o, mas nÃ£o Ã© o foco da questÃ£o, D) descreve a transparÃªncia de relocaÃ§Ã£o, e E) descreve a transparÃªncia de localizaÃ§Ã£o.",
    "dificuldade_experimental": "Muito DifÃ­cil"
  },
  {
    "edicao": 2019,
    "id": "2019-63",
    "numero": 63,
    "enunciado": "Considere o esquema de traduÃ§Ã£o dirigida pela sintaxe apresentado a seguir, no qual as produÃ§Ãµes da gramÃ¡tica foram numeradas:\n| ProduÃ§Ãµes | AÃ§Ãµes SemÃ¢nticas |\n|-|-|\n|1) $L â†’ E n$|$L.val = E.val$|\n|2) $E â†’ E_1 + T$|$E.val = E_1.val + T.val$|\n|3) $E â†’ T$|$E.val = T.val$|\n|4) $T â†’ T_1 * F$|$T.val = T_1.val * F.val$|\n|5) $T â†’ F$|$T.val = F.val$|\n|6) $F â†’ (E)$|$F.val = E.val$|\n|7) $F â†’ \\text{digit}$|$F.val = \\text{digit}.lexval$|\n\nAssinale a alternativa correta sobre o esquema.",
    "alternativas": [
      "a) Na produÃ§Ã£o 4, \\(T.val\\) e \\(F.val\\) sÃ£o sintetizados.",
      "b) Na produÃ§Ã£o 4, \\(T_1.val\\) Ã© herdado.",
      "c) Na produÃ§Ã£o 5, \\(T.val\\) e \\(F.val\\) sÃ£o herdados.",
      "d) Na produÃ§Ã£o 2, \\(E.val\\) Ã© sintetizado e \\(T.val\\) Ã© herdado.",
      "e) Na produÃ§Ã£o 2, \\(E_1.val\\) Ã© sintetizado e \\(T.val\\) Ã© herdado."
    ],
    "area_conhecimento": "Tecnologia de ComputaÃ§Ã£o",
    "area": "Compliadores",
    "subarea": "Esquemas de TraduÃ§Ã£o",
    "dificuldade": "MÃ©dia",
    "gabarito": "A",
    "solucao": "Para determinar a alternativa correta, precisamos entender as definiÃ§Ãµes de atributos sintetizados e herdados em um esquema de traduÃ§Ã£o dirigida pela sintaxe. Atributos sintetizados sÃ£o aqueles que sÃ£o calculados a partir dos atributos dos filhos no nÃ³ da Ã¡rvore de derivaÃ§Ã£o, enquanto atributos herdados sÃ£o calculados a partir dos atributos dos irmÃ£os ou do pai do nÃ³. Na produÃ§Ã£o 4, 'T â†’ T1 * F', T.val Ã© calculado como T1.val * F.val, o que significa que tanto T.val quanto F.val sÃ£o calculados a partir dos valores dos nÃ³s filhos, caracterizando-os como atributos sintetizados. Portanto, a alternativa correta Ã© A) Na produÃ§Ã£o 4, T.val e F.val sÃ£o sintetizados.",
    "dificuldade_experimental": "Muito DifÃ­cil"
  },
  {
    "edicao": 2019,
    "id": "2019-68",
    "numero": 68,
    "enunciado": "Assinale a alternativa que apresenta a quantidade mÃ­nima de registradores\nnecessÃ¡rios para se fazer a alocaÃ§Ã£o no cÃ³digo apresentado abaixo:\\\nt1 := a â€“ mem[...]\\\nt2 := d / mem[...]\\\nt3 := t2 + mem[...]\\\nt4 := t1 + t3",
    "alternativas": [
      "a) 6",
      "b) 5",
      "c) 4",
      "d) 3",
      "e) 2"
    ],
    "area_conhecimento": "Tecnologia de ComputaÃ§Ã£o",
    "area": "Compliadores",
    "subarea": "GeraÃ§Ã£o de CÃ³digo",
    "dificuldade": "MÃ©dia",
    "gabarito": "E",
    "solucao": "Para determinar a quantidade mÃ­nima de registradores necessÃ¡rios, precisamos analisar as dependÃªncias entre as instruÃ§Ãµes e como os valores intermediÃ¡rios sÃ£o utilizados. \n\n1. A primeira instruÃ§Ã£o Ã© `t1 := a - mem[...]`. Aqui, um registrador Ã© necessÃ¡rio para armazenar o resultado de `t1`.\n2. A segunda instruÃ§Ã£o Ã© `t2 := d / mem[...]`. Outro registrador Ã© necessÃ¡rio para armazenar o resultado de `t2`.\n3. A terceira instruÃ§Ã£o Ã© `t3 := t2 + mem[...]`. `t3` depende de `t2`, entÃ£o precisamos de um registrador para `t3`. ApÃ³s essa operaÃ§Ã£o, `t2` nÃ£o Ã© mais necessÃ¡rio, entÃ£o o mesmo registrador pode ser reutilizado para `t3`.\n4. A quarta instruÃ§Ã£o Ã© `t4 := t1 + t3`. `t4` depende de `t1` e `t3`. Precisamos de um registrador para armazenar `t4`. \n\nPortanto, podemos usar 3 registradores: um para `t1`, um para `t3` (reutilizando o de `t2`), e um para `t4`. No entanto, a pergunta pede a quantidade mÃ­nima de registradores, e considerando a reutilizaÃ§Ã£o, 4 registradores sÃ£o suficientes para garantir que cada valor intermediÃ¡rio seja armazenado adequadamente sem conflito.",
    "dificuldade_experimental": "Muito DifÃ­cil"
  },
  {
    "edicao": 2019,
    "id": "2019-70",
    "numero": 70,
    "enunciado": "Considerando a gerÃªncia de projetos de software, analise as assertivas abaixo e\nassinale V, se verdadeiras, ou F, se falsas.\\\n( ) A gerÃªncia efetiva de projetos de software deve abranger trÃªs aspectos, a saber, produto,processo e projeto.\\\n( ) A anÃ¡lise de risco de um projeto visa a analisar a viabilidade de produzir software dentro do custo e esforÃ§o estimados.\\\n( ) O desenvolvimento de cronogramas de projetos pode ser desenvolvido com o auxÃ­lio de modelos como PERT (Program evaluation and review technique) ou CPM (Critical Path Method).\\\nA ordem correta de preenchimento dos parÃªnteses, de cima para baixo, Ã©:",
    "alternativas": [
      "a) V â€“ V â€“ V.",
      "b) V â€“ F â€“ V.",
      "c) F â€“ F â€“ F.",
      "d) F â€“ F â€“ V.",
      "e) V â€“ V â€“ F."
    ],
    "area_conhecimento": "Tecnologia de ComputaÃ§Ã£o",
    "area": "Engenharia de Software",
    "subarea": "TÃ©cnicas de Planejamento e Gerenciamento de Software",
    "dificuldade": "FÃ¡cil",
    "gabarito": "D",
    "solucao": "Vamos analisar cada assertiva: \n\n1) 'A gerÃªncia efetiva de projetos de software deve abranger trÃªs aspectos, a saber, produto, processo e projeto.' - Esta assertiva Ã© verdadeira. Na gerÃªncia de projetos de software, Ã© essencial considerar o produto (o que estÃ¡ sendo desenvolvido), o processo (como o desenvolvimento Ã© realizado) e o projeto (a gestÃ£o do prÃ³prio projeto em termos de cronograma, recursos, etc.).\n\n2) 'A anÃ¡lise de risco de um projeto visa a analisar a viabilidade de produzir software dentro do custo e esforÃ§o estimados.' - Esta assertiva tambÃ©m Ã© verdadeira. A anÃ¡lise de risco Ã© uma parte crucial da gerÃªncia de projetos, pois ajuda a identificar, avaliar e mitigar riscos que podem impactar o cumprimento dos objetivos do projeto, incluindo custo e esforÃ§o.\n\n3) 'O desenvolvimento de cronogramas de projetos pode ser desenvolvido com o auxÃ­lio de modelos como PERT (Program evaluation and review technique) ou CPM (Critical Path Method).' - Esta assertiva Ã© verdadeira. Tanto o PERT quanto o CPM sÃ£o tÃ©cnicas amplamente utilizadas para o planejamento e controle de cronogramas em projetos, ajudando a identificar o caminho crÃ­tico e a estimar a duraÃ§Ã£o do projeto.\n\nPortanto, a ordem correta Ã© V â€“ V â€“ V, que corresponde Ã  alternativa A.",
    "dificuldade_experimental": "Muito DifÃ­cil"
  },
  {
    "edicao": 2023,
    "id": "2023-08",
    "numero": 8,
    "enunciado": "Determine os intervalos da funÃ§Ã£o \\(ğ‘“(ğ‘¥) = 5ğ‘¥^2\\sqrt{ğ‘¥ + 1}\\).",
    "alternativas": [
      "a) \\(ğ¼ = (âˆ’1, âˆ’\\frac{4}{5}) ; ğ¼ = (âˆ’\\frac{4}{5}, 0) ; ğ¼ = (0, \\infty)\\)",
      "b) \\(ğ¼ = (âˆ’\\infty, âˆ’ \\frac{4}{5}) ; ğ¼ = (âˆ’\\frac{4}{5}, 0) ; ğ¼ = (0, \\infty)\\)",
      "c) \\(ğ¼ = (âˆ’1, 0); ğ¼ = (0, 1); ğ¼ = (1, \\infty)\\)",
      "d) \\(ğ¼ = (âˆ’1, 1); ğ¼ = (1,\\frac{5}{4}) ; ğ¼ = (\\frac{5}{4},\\infty)\\)",
      "e) \\(ğ¼ = (âˆ’âˆ, âˆ’1); ğ¼ = (âˆ’1, 1); ğ¼ = (1, âˆ)\\)"
    ],
    "area_conhecimento": "MatemÃ¡tica",
    "area": "CÃ¡lculo Diferencial e Integral",
    "subarea": "FunÃ§Ãµes Reais de uma VariÃ¡vel: Continuidade e Diferenciabilidade",
    "dificuldade": "FÃ¡cil",
    "gabarito": "A",
    "solucao": "Para determinar os intervalos de definiÃ§Ã£o da funÃ§Ã£o f(x) = 5xÂ²âˆšx + 1, precisamos analisar a expressÃ£o dentro da raiz quadrada, que Ã© x. A funÃ§Ã£o raiz quadrada estÃ¡ definida apenas para valores de x â‰¥ 0. Portanto, a funÃ§Ã£o f(x) sÃ³ estÃ¡ definida para x â‰¥ 0. AlÃ©m disso, nÃ£o hÃ¡ restriÃ§Ãµes adicionais na expressÃ£o, jÃ¡ que xÂ² Ã© sempre nÃ£o negativo e a soma com 1 nÃ£o afeta o domÃ­nio. Assim, o domÃ­nio da funÃ§Ã£o Ã© [0, âˆ). No entanto, a questÃ£o parece pedir uma anÃ¡lise dos intervalos de interesse para a funÃ§Ã£o, que sÃ£o (âˆ’âˆ, âˆ’1), (âˆ’1, 1) e (1, âˆ), considerando que a funÃ§Ã£o Ã© contÃ­nua e definida em x â‰¥ 0. Portanto, a alternativa correta Ã© a E.",
    "dificuldade_experimental": "Muito DifÃ­cil"
  },
  {
    "edicao": 2023,
    "id": "2023-09",
    "numero": 9,
    "enunciado": "Calcule o vetor gradiente da funÃ§Ã£o \\(ğ‘“(ğ‘¥,ğ‘¦) = ğ‘’^{âˆ’ğ‘¥} sen(ğ‘¥ + ğ‘¦)\\) no ponto \\(ğ‘ƒ (0, \\pi)\\).",
    "alternativas": [
      "a) \\(\\nablağ‘“(0, ğœ‹) =\\begin{pmatrix}0\\\\1\\end{pmatrix}\\)",
      "b) \\(\\nablağ‘“(0, ğœ‹) =\\begin{pmatrix}1\\\\1\\end{pmatrix}\\)",
      "c) \\(\\nablağ‘“(0, ğœ‹) =\\begin{pmatrix}-1\\\\1\\end{pmatrix}\\)",
      "d) \\(\\nablağ‘“(0, ğœ‹) =\\begin{pmatrix}-1\\\\-1\\end{pmatrix}\\)",
      "e) \\(\\nablağ‘“(0, ğœ‹) =\\begin{pmatrix}0\\\\0\\end{pmatrix}\\)"
    ],
    "area_conhecimento": "MatemÃ¡tica",
    "area": "CÃ¡lculo Diferencial e Integral",
    "subarea": "Gradientes",
    "dificuldade": "MÃ©dia",
    "gabarito": "D",
    "solucao": "Para calcular o vetor gradiente da funÃ§Ã£o f(x, y) = e^(-x) sen(x + y), precisamos encontrar as derivadas parciais de f em relaÃ§Ã£o a x e y. \n\nA derivada parcial de f em relaÃ§Ã£o a x Ã© dada por: \nâˆ‚f/âˆ‚x = âˆ‚/âˆ‚x [e^(-x) sen(x + y)] = -e^(-x) sen(x + y) + e^(-x) cos(x + y). \n\nA derivada parcial de f em relaÃ§Ã£o a y Ã© dada por: \nâˆ‚f/âˆ‚y = âˆ‚/âˆ‚y [e^(-x) sen(x + y)] = e^(-x) cos(x + y). \n\nNo ponto P(0, Ï€), temos: \nâˆ‚f/âˆ‚x (0, Ï€) = -e^(0) sen(0 + Ï€) + e^(0) cos(0 + Ï€) = 0 - 1 = -1. \nâˆ‚f/âˆ‚y (0, Ï€) = e^(0) cos(0 + Ï€) = -1. \n\nPortanto, o vetor gradiente âˆ‡f(0, Ï€) Ã© (-1, -1). \n\nAssim, a alternativa correta Ã© B) âˆ‡f(0, Ï€) = ( )\n1\nâˆ’1.",
    "dificuldade_experimental": "Muito DifÃ­cil"
  },
  {
    "edicao": 2023,
    "id": "2023-20",
    "numero": 20,
    "enunciado": "Em uma linha de produÃ§Ã£o, sabe-se que a probabilidade de ter uma peÃ§a com defeito Ã© de 0,05. Se o conjunto de unidades determinadas constitui um conjunto de ensaios independentes, qual Ã© a probabilidade de que pelo menos uma peÃ§a se encontre com defeito em um total de 10 unidades?",
    "alternativas": [
      "a) 10,0%",
      "b) 40,0%",
      "c) 50,0%",
      "d) 80,0%",
      "e) 100,0%"
    ],
    "area_conhecimento": "MatemÃ¡tica",
    "area": "Probabilidade e EstatÃ­stica",
    "subarea": "DistribuiÃ§Ãµes de Probabilidades",
    "dificuldade": "FÃ¡cil",
    "gabarito": "B",
    "solucao": "Para resolver essa questÃ£o, precisamos calcular a probabilidade de que pelo menos uma peÃ§a esteja com defeito em um total de 10 unidades. Primeiro, calculamos a probabilidade de que nenhuma peÃ§a esteja com defeito. A probabilidade de uma peÃ§a nÃ£o ter defeito Ã© 1 - 0,05 = 0,95. Como os ensaios sÃ£o independentes, a probabilidade de que todas as 10 peÃ§as nÃ£o tenham defeito Ã© 0,95^10. Calculando isso, temos 0,95^10 â‰ˆ 0,5987. Portanto, a probabilidade de que pelo menos uma peÃ§a esteja com defeito Ã© 1 - 0,5987 â‰ˆ 0,4013, ou aproximadamente 40,13%. No entanto, ao arredondar para uma das alternativas fornecidas, a opÃ§Ã£o mais prÃ³xima Ã© 40,0%, que corresponde Ã  alternativa D.",
    "dificuldade_experimental": "Muito DifÃ­cil"
  },
  {
    "edicao": 2023,
    "id": "2023-37",
    "numero": 37,
    "enunciado": "Qual Ã© a ExpressÃ£o Regular (ER) que denota a linguagem a seguir?\n\\(ğ¿ = \\{ğ‘¤ âˆˆ \\{ğ‘, ğ‘\\}âˆ— | w \\) nÃ£o pode terminar com \\(ba\\)\\(\\}\\)",
    "alternativas": [
      "a) \\(Â¬( (ğ‘ âˆª ğ‘)^âˆ—ğ‘ğ‘ )\\)",
      "b) \\((ğ‘ âˆª ğ‘)^âˆ—ğ‘ğ‘\\)",
      "c) \\((ğ‘ âˆª ğ‘)^âˆ— âˆ’ ( (ğ‘ âˆª ğ‘)^âˆ—ğ‘ğ‘ )\\)",
      "d) \\(( (ğ‘ âˆª ğ‘)^âˆ—(ğ‘ âˆª ğ‘ğ‘) ) âˆª ğ‘ âˆª ğœ†\\)",
      "e) A linguagem L nÃ£o Ã© regular e, portanto, nÃ£o pode ser denotada por uma ER."
    ],
    "area_conhecimento": "Fundamentos da ComputaÃ§Ã£o",
    "area": "Linguagens Formais, AutÃ´matos e Computabilidade",
    "subarea": "Linguagens Regulares",
    "dificuldade": "MÃ©dia",
    "gabarito": "D",
    "solucao": "A linguagem L Ã© definida como o conjunto de palavras sobre o alfabeto {a, b} que nÃ£o terminam com 'ba'. Para denotar essa linguagem usando uma expressÃ£o regular, precisamos considerar todas as palavras possÃ­veis sobre {a, b} e remover aquelas que terminam com 'ba'. A expressÃ£o regular para todas as palavras sobre {a, b} Ã© (a âˆª b)*. As palavras que terminam com 'ba' sÃ£o denotadas pela expressÃ£o regular (a âˆª b)*ba. Portanto, a expressÃ£o regular que denota a linguagem L Ã© a diferenÃ§a entre todas as palavras e aquelas que terminam com 'ba', que Ã© (a âˆª b)* âˆ’ ((a âˆª b)*ba). A alternativa C representa corretamente essa expressÃ£o.",
    "dificuldade_experimental": "Muito DifÃ­cil"
  },
  {
    "edicao": 2023,
    "id": "2023-42",
    "numero": 42,
    "enunciado": "Em um computador com suporte Ã  memÃ³ria virtual e paginaÃ§Ã£o, quando ocorre um\npage fault, o sistema operacional, Ã s vezes, precisa escolher uma pÃ¡gina da memÃ³ria principal (page frame) para dar lugar Ã  pÃ¡gina virtual que serÃ¡ carregada do disco como resultado do page fault. Dependendo do tipo de conteÃºdo presente na pÃ¡gina selecionada para substituiÃ§Ã£o, esse conteÃºdo precisa ser salvo no disco (page out) antes da substituiÃ§Ã£o. Assinale a alternativa que indica uma regiÃ£o de memÃ³ria tÃ­pica de um processo, cujo conteÃºdo nÃ£o exige salvamento prÃ©vio em casos de troca de pÃ¡ginas (page replacement).",
    "alternativas": [
      "a) Dados alocados dinamicamente (ex.: HEAP).",
      "b) Dados nÃ£o inicializados (ex.: BSS).",
      "c) Dados inicializados (ex.: DATA).",
      "d) CÃ³digo (ex.: TEXT).",
      "e) Pilha (ex.: STACK)."
    ],
    "area_conhecimento": "Fundamentos da ComputaÃ§Ã£o",
    "area": "Sistemas Operacionais",
    "subarea": "Gerenciamento de MemÃ³ria: MemÃ³ria Virtual, PaginaÃ§Ã£o, SegmentaÃ§Ã£o e 'Swap'",
    "dificuldade": "MÃ©dia",
    "gabarito": "D",
    "solucao": "Em sistemas operacionais que utilizam memÃ³ria virtual com paginaÃ§Ã£o, quando ocorre um page fault, o sistema precisa carregar a pÃ¡gina necessÃ¡ria do disco para a memÃ³ria principal. Se a memÃ³ria principal estiver cheia, uma pÃ¡gina existente deve ser substituÃ­da. No entanto, se a pÃ¡gina a ser substituÃ­da contiver dados que foram modificados (dirty page), ela precisa ser salva no disco (page out) antes de ser substituÃ­da. A regiÃ£o de memÃ³ria BSS (Block Started by Symbol) Ã© usada para armazenar variÃ¡veis nÃ£o inicializadas. Como essas variÃ¡veis nÃ£o tÃªm um valor inicial definido, seu conteÃºdo nÃ£o precisa ser salvo no disco antes de serem substituÃ­das, pois nÃ£o hÃ¡ dados Ãºteis a serem preservados. Portanto, a alternativa correta Ã© 'B) Dados nÃ£o inicializados (ex.: BSS)'.",
    "dificuldade_experimental": "Muito DifÃ­cil"
  },
  {
    "edicao": 2023,
    "id": "2023-48",
    "numero": 48,
    "enunciado": "Uma famÃ­lia de ligaÃ§Ãµes sucessivamente adjacentes, cada uma tendo uma\nextremidade adjacente Ã  anterior e outra Ã  subsequente (Ã  exceÃ§Ã£o da primeira e da Ãºltima) Ã© um(a):",
    "alternativas": [
      "a) Circuito.",
      "b) Percurso.",
      "c) Caminho.",
      "d) Ciclo.",
      "e) Corda."
    ],
    "area_conhecimento": "Fundamentos da ComputaÃ§Ã£o",
    "area": "Teoria dos Grafos",
    "subarea": "Caminhos",
    "dificuldade": "FÃ¡cil",
    "gabarito": "B",
    "solucao": "A questÃ£o descreve uma sequÃªncia de ligaÃ§Ãµes onde cada ligaÃ§Ã£o Ã© adjacente Ã  anterior e Ã  subsequente, exceto a primeira e a Ãºltima. Em teoria dos grafos, essa descriÃ§Ã£o corresponde a um 'caminho'. Um caminho Ã© uma sequÃªncia de arestas que conecta uma sequÃªncia de vÃ©rtices sem repetir arestas, onde cada vÃ©rtice (exceto o primeiro e o Ãºltimo) Ã© adjacente ao anterior e ao subsequente. Portanto, a resposta correta Ã© 'Caminho'.",
    "dificuldade_experimental": "Muito DifÃ­cil"
  },
  {
    "edicao": 2023,
    "id": "2023-52",
    "numero": 52,
    "enunciado": "Quando hÃ¡ impasse no controle de concorrÃªncia em sistemas de bancos de dados,\numa forma para o tratamento Ã© o emprego de protocolos de prevenÃ§Ã£o, que sÃ£o pessimistas quanto Ã  efetiva ocorrÃªncia de deadlock. Considere as seguintes tÃ©cnicas usadas em protocolos de prevenÃ§Ã£o:\\\n- I. Esperar-ou-morrer (wait-die).\n- II. Ferir-ou-esperar (wound-wait).\n- III. Espera-cautelosa (cautious-waiting).\n- IV. Sem-espera (no-waiting).\\\nAlgumas dessas tÃ©cnicas usam o conceito de timestamp (TS) de transaÃ§Ãµes: se TS(T1) < TS(T2), entÃ£o a transaÃ§Ã£o T1 foi iniciada antes da transaÃ§Ã£o T2. Dentre as tÃ©cnicas acima, as baseadas em timestamp sÃ£o:",
    "alternativas": [
      "a) Apenas I e II.",
      "b) Apenas I e III.",
      "c) Apenas II e III.",
      "d) Apenas II e IV.",
      "e) Apenas III e IV."
    ],
    "area_conhecimento": "Tecnologia de ComputaÃ§Ã£o",
    "area": "Banco de Dados",
    "subarea": "Sistemas de Gerenciamento de Bancos de Dados (SGBD): Arquitetura, SeguranÃ§a, Integridade, ConcorrÃªncia, RecuperaÃ§Ã£o apÃ³s Falha, Gerenciamento de TransaÃ§Ãµes",
    "dificuldade": "MÃ©dia",
    "gabarito": "A",
    "solucao": "As tÃ©cnicas de prevenÃ§Ã£o de deadlock 'esperar-ou-morrer' (wait-die) e 'ferir-ou-esperar' (wound-wait) sÃ£o baseadas no conceito de timestamp. No mÃ©todo 'esperar-ou-morrer', se uma transaÃ§Ã£o mais antiga (com timestamp menor) solicita um recurso que estÃ¡ sendo usado por uma transaÃ§Ã£o mais nova, ela espera; caso contrÃ¡rio, ela Ã© abortada. No mÃ©todo 'ferir-ou-esperar', se uma transaÃ§Ã£o mais nova solicita um recurso que estÃ¡ sendo usado por uma transaÃ§Ã£o mais antiga, a transaÃ§Ã£o mais nova espera; caso contrÃ¡rio, a transaÃ§Ã£o mais antiga Ã© abortada. As tÃ©cnicas 'espera-cautelosa' e 'sem-espera' nÃ£o utilizam timestamps para a prevenÃ§Ã£o de deadlocks. Portanto, as tÃ©cnicas baseadas em timestamp sÃ£o I (esperar-ou-morrer) e II (ferir-ou-esperar).",
    "dificuldade_experimental": "Muito DifÃ­cil"
  },
  {
    "edicao": 2023,
    "id": "2023-58",
    "numero": 58,
    "enunciado": "Analise as seguintes assertivas sobre reÃºso no contexto de engenharia de software:\n- I. Muitos desenvolvedores de software preferem reescrever eles mesmos seus componentes porque acreditam que seu trabalho serÃ¡ de melhor qualidade, se comparado Ã  adaptaÃ§Ã£o de componentes escritos por outros (sÃ­ndrome do â€œNÃ£o inventado aquiâ€).\n- II. O reÃºso pressupÃµe a existÃªncia de bibliotecas com componentes reutilizÃ¡veis. Criar, manter e assegurar que desenvolvedores de software usem essa biblioteca pode ser bastante custoso.\n- III. Desenvolver softwares atravÃ©s do reÃºso, por tipicamente adicionar uma complexidade muito grande ao cÃ³digo, exige desenvolvedores que sejam especialistas em reÃºso, o que torna o desenvolvimento baseado em reÃºso muito caro.\\\nDentre as assertivas acima, quais representam fatores que comprometem o reÃºso de software?",
    "alternativas": [
      "a) Apenas I.",
      "b) Apenas II.",
      "c) Apenas III.",
      "d) Apenas I e II.",
      "e) I, II e III."
    ],
    "area_conhecimento": "Tecnologia de ComputaÃ§Ã£o",
    "area": "Engenharia de Software",
    "subarea": "Reuso",
    "dificuldade": "MÃ©dia",
    "gabarito": "D",
    "solucao": "Vamos analisar cada assertiva: \n\nI. A sÃ­ndrome do 'NÃ£o inventado aqui' Ã© um fenÃ´meno real onde desenvolvedores preferem criar seus prÃ³prios componentes ao invÃ©s de reutilizar os existentes, acreditando que podem fazer melhor. Isso Ã© um fator que compromete o reÃºso de software, pois desencoraja a utilizaÃ§Ã£o de componentes jÃ¡ disponÃ­veis. Portanto, a assertiva I Ã© verdadeira.\n\nII. A criaÃ§Ã£o, manutenÃ§Ã£o e promoÃ§Ã£o do uso de bibliotecas de componentes reutilizÃ¡veis podem ser custosas, tanto em termos de tempo quanto de recursos. Isso pode desencorajar o reÃºso se os custos forem considerados muito altos em comparaÃ§Ã£o com os benefÃ­cios. Assim, a assertiva II tambÃ©m Ã© verdadeira.\n\nIII. Embora o reÃºso possa adicionar alguma complexidade, a afirmaÃ§Ã£o de que ele 'tipicamente adiciona uma complexidade muito grande ao cÃ³digo' e que exige 'desenvolvedores que sejam especialistas em reÃºso' Ã© um exagero. O reÃºso, quando bem feito, pode simplificar o desenvolvimento ao invÃ©s de complicÃ¡-lo. Portanto, a assertiva III nÃ£o Ã© um fator que compromete o reÃºso de software.\n\nCom base na anÃ¡lise, as assertivas I e II representam fatores que comprometem o reÃºso de software, tornando a alternativa D a correta.",
    "dificuldade_experimental": "Muito DifÃ­cil"
  },
  {
    "edicao": 2023,
    "id": "2023-59",
    "numero": 59,
    "enunciado": "Uma revisÃ£o tÃ©cnica formal (RTF) Ã© uma atividade de controle de qualidade de\nsoftware executada por engenheiros de software sobre um artefato de software (especificaÃ§Ãµes, cÃ³digo, etc.). As diretrizes para a realizaÃ§Ã£o de uma RTF devem ser estabelecidas com antecedÃªncia, distribuÃ­das a todos os revisores, e seguidas durante o processo de revisÃ£o. Assinale a alternativa que NÃƒO representa uma boa prÃ¡tica na conduÃ§Ã£o de uma RTF.",
    "alternativas": [
      "a) Revisar o produto (artefato), e nÃ£o quem o desenvolveu.",
      "b) Definir uma agenda de revisÃ£o inicial (reuniÃµes com datas e horÃ¡rios especÃ­ficas), mas estender as discussÃµes enquanto forem encontrados problemas nos artefatos revisados.",
      "c) Identificar Ã¡reas problemÃ¡ticas, sem tentar resolver os problemas apontados.",
      "d) Limitar o nÃºmero de participantes e exigir preparaÃ§Ã£o prÃ©via de todos.",
      "e) Fornecer treinamento adequado a todos os revisores."
    ],
    "area_conhecimento": "Tecnologia de ComputaÃ§Ã£o",
    "area": "Engenharia de Software",
    "subarea": "Garantia de Qualidade de Software",
    "dificuldade": "FÃ¡cil",
    "gabarito": "B",
    "solucao": "A questÃ£o aborda boas prÃ¡ticas na conduÃ§Ã£o de uma RevisÃ£o TÃ©cnica Formal (RTF), que Ã© uma atividade de controle de qualidade de software. Vamos analisar cada alternativa: \n\nA) 'Revisar o produto (artefato), e nÃ£o quem o desenvolveu.' - Esta Ã© uma boa prÃ¡tica, pois o foco deve ser no artefato e nÃ£o na pessoa que o criou.\n\nB) 'Definir uma agenda de revisÃ£o inicial (reuniÃµes com datas e horÃ¡rios especÃ­ficas), mas estender as discussÃµes enquanto forem encontrados problemas nos artefatos revisados.' - Esta prÃ¡tica nÃ£o Ã© recomendada, pois estender indefinidamente as discussÃµes pode levar a um processo ineficiente e sem controle. As revisÃµes devem ser bem planejadas e limitadas em tempo para garantir eficiÃªncia.\n\nC) 'Identificar Ã¡reas problemÃ¡ticas, sem tentar resolver os problemas apontados.' - Esta Ã© uma prÃ¡tica comum em revisÃµes, onde o objetivo Ã© identificar problemas, mas nÃ£o necessariamente resolvÃª-los durante a revisÃ£o.\n\nD) 'Limitar o nÃºmero de participantes e exigir preparaÃ§Ã£o prÃ©via de todos.' - Limitar os participantes e exigir preparaÃ§Ã£o sÃ£o prÃ¡ticas recomendadas para garantir que a revisÃ£o seja focada e produtiva.\n\nE) 'Fornecer treinamento adequado a todos os revisores.' - Treinamento adequado Ã© essencial para que os revisores saibam como conduzir a revisÃ£o de forma eficaz.\n\nPortanto, a alternativa B Ã© a que nÃ£o representa uma boa prÃ¡tica, pois sugere estender as discussÃµes indefinidamente, o que pode comprometer a eficiÃªncia do processo.",
    "dificuldade_experimental": "Muito DifÃ­cil"
  },
  {
    "edicao": 2023,
    "id": "2023-63",
    "numero": 63,
    "enunciado": "Em relaÃ§Ã£o aos mÃ©todos de interpolaÃ§Ã£o de intensidade de nÃ­veis de cinza ou cor\nde uma imagem, analise as assertivas abaixo e assinale V, se verdadeiras, ou F, se falsas.\\\n( ) O mÃ©todo do vizinho mais prÃ³ximo atribui a cada nova posiÃ§Ã£o a intensidade de seu vizinho mais prÃ³ximo na imagem original. O mÃ©todo pode causar distorÃ§Ãµes em detalhes finos ou criar formas serrilhadas em bordas retas de imagens.\\\n( ) Na interpolaÃ§Ã£o bilinear, os dois vizinhos mais prÃ³ximos sÃ£o utilizados para estimar a intensidade de uma dada posiÃ§Ã£o. O mÃ©todo se baseia na mÃ©dia aritmÃ©tica de distÃ¢ncia desses pixels e causa borramento devido Ã  sua caracterÃ­stica de suavizaÃ§Ã£o.\\\n( ) A interpolaÃ§Ã£o bicÃºbica inclui os dezesseis vizinhos mais prÃ³ximos de um ponto. Esse tipo de interpolaÃ§Ã£o preserva detalhes finos na imagem.\\\nA ordem correta de preenchimento dos parÃªnteses, de cima para baixo, Ã©:",
    "alternativas": [
      "a) F â€“ F â€“ V.",
      "b) F â€“ V â€“ F.",
      "c) V â€“ F â€“ V.",
      "d) V â€“ V â€“ V.",
      "e) V â€“ V â€“ F."
    ],
    "area_conhecimento": "Tecnologia de ComputaÃ§Ã£o",
    "area": "Processamento de Imagens",
    "subarea": "Amostragem e QuantizaÃ§Ã£o de Imagens",
    "dificuldade": "MÃ©dia",
    "gabarito": "C",
    "solucao": "Vamos analisar cada uma das assertivas:\n\n1) A primeira assertiva afirma que o mÃ©todo do vizinho mais prÃ³ximo atribui a cada nova posiÃ§Ã£o a intensidade de seu vizinho mais prÃ³ximo na imagem original e que pode causar distorÃ§Ãµes em detalhes finos ou criar formas serrilhadas em bordas retas de imagens. Esta afirmaÃ§Ã£o Ã© verdadeira. O mÃ©todo do vizinho mais prÃ³ximo Ã© simples e rÃ¡pido, mas pode introduzir artefatos visuais como serrilhamento (aliasing) em bordas.\n\n2) A segunda assertiva descreve a interpolaÃ§Ã£o bilinear como utilizando os dois vizinhos mais prÃ³ximos para estimar a intensidade de uma dada posiÃ§Ã£o e menciona que ela se baseia na mÃ©dia aritmÃ©tica de distÃ¢ncia desses pixels. Esta afirmaÃ§Ã£o Ã© falsa. A interpolaÃ§Ã£o bilinear utiliza quatro vizinhos (nÃ£o dois) e calcula a intensidade ponderando as distÃ¢ncias relativas, nÃ£o apenas a mÃ©dia aritmÃ©tica de distÃ¢ncias. O efeito de suavizaÃ§Ã£o e borramento Ã© correto, mas a descriÃ§Ã£o do mÃ©todo estÃ¡ errada.\n\n3) A terceira assertiva afirma que a interpolaÃ§Ã£o bicÃºbica inclui os dezesseis vizinhos mais prÃ³ximos de um ponto e preserva detalhes finos na imagem. Esta afirmaÃ§Ã£o Ã© verdadeira. A interpolaÃ§Ã£o bicÃºbica considera um total de 16 pixels ao redor do ponto de interesse e Ã© conhecida por produzir resultados mais suaves e detalhados em comparaÃ§Ã£o com mÃ©todos mais simples como o do vizinho mais prÃ³ximo e o bilinear.\n\nPortanto, a ordem correta Ã© V â€“ F â€“ V, o que corresponde Ã  alternativa E.",
    "dificuldade_experimental": "Muito DifÃ­cil"
  },
  {
    "edicao": 2023,
    "id": "2023-67",
    "numero": 67,
    "enunciado": "Considere um pacote de p bytes, enviados por um canal de d metros Ã  taxa de\nb bits por segundo. Suponha que a velocidade de propagaÃ§Ã£o no meio seja igual a da velocidade da luz no vÃ¡cuo (c). Qual Ã© a expressÃ£o para se determinar a largura/comprimento de um bit?",
    "alternativas": [
      "a) \\(c/b\\)",
      "b) \\(b/c\\)",
      "c) \\(8p/b\\)",
      "d) \\(d/c\\)",
      "e) \\(d/c + b/c\\)"
    ],
    "area_conhecimento": "Tecnologia de ComputaÃ§Ã£o",
    "area": "Redes de Computadores",
    "subarea": "Tipos de Enlace, CÃ³digos, Modos e Meios de TransmissÃ£o",
    "dificuldade": "FÃ¡cil",
    "gabarito": "A",
    "solucao": "Para determinar a largura/comprimento de um bit em um canal de comunicaÃ§Ã£o, precisamos considerar o tempo que um bit leva para ser transmitido e a distÃ¢ncia que ele percorre nesse tempo. A largura de um bit Ã© a distÃ¢ncia que ele ocupa no meio de transmissÃ£o. \n\nA taxa de transmissÃ£o Ã© dada em bits por segundo (b), entÃ£o o tempo para transmitir um bit Ã© 1/b segundos. \n\nA velocidade de propagaÃ§Ã£o do sinal Ã© a velocidade da luz no vÃ¡cuo (c). Portanto, a distÃ¢ncia que um bit percorre enquanto estÃ¡ sendo transmitido Ã© dada por c * (1/b) = c/b metros. \n\nPortanto, a expressÃ£o para determinar a largura/comprimento de um bit Ã© c/b, que corresponde Ã  alternativa A.",
    "dificuldade_experimental": "Muito DifÃ­cil"
  },
  {
    "edicao": 2023,
    "id": "2023-68",
    "numero": 68,
    "enunciado": "Uma transaÃ§Ã£o cliente se torna distribuÃ­da se ativa operaÃ§Ãµes em vÃ¡rios servidores\ndiferentes, isto Ã©, um cliente faz requisiÃ§Ãµes para mais de um servidor. A transaÃ§Ã£o cliente ______________ conclui cada uma de suas requisiÃ§Ãµes antes de passar para a prÃ³xima. Portanto, cada transaÃ§Ã£o acessa objetos dos servidores em sequÃªncia. Quando os servidores usam locks, uma transaÃ§Ã£o sÃ³ pode estar esperando um objeto por vez.\\\nAssinale a alternativa que preenche corretamente a lacuna do trecho acima.",
    "alternativas": [
      "a) plana",
      "b) aninhada",
      "c) coordenadora",
      "d) em duas fases",
      "e) hierÃ¡rquica"
    ],
    "area_conhecimento": "Tecnologia de ComputaÃ§Ã£o",
    "area": "Sistemas DistribuÃ­dos",
    "subarea": "Compartilhamento de InformaÃ§Ã£o: Controle de ConcorrÃªncia, TransaÃ§Ãµes DistribuÃ­das",
    "dificuldade": "MÃ©dia",
    "gabarito": "A",
    "solucao": "A questÃ£o descreve uma transaÃ§Ã£o cliente que conclui cada uma de suas requisiÃ§Ãµes antes de passar para a prÃ³xima, acessando objetos dos servidores em sequÃªncia. Isso caracteriza uma transaÃ§Ã£o 'plana', que Ã© uma transaÃ§Ã£o simples e linear, sem sub-transaÃ§Ãµes ou aninhamentos. Em um contexto de sistemas distribuÃ­dos, uma transaÃ§Ã£o plana acessa recursos de forma sequencial e nÃ£o simultÃ¢nea, o que se alinha com a descriÃ§Ã£o de que a transaÃ§Ã£o sÃ³ pode estar esperando por um objeto por vez quando os servidores usam locks. As outras alternativas, como transaÃ§Ãµes 'aninhadas' ou 'em duas fases', envolvem estruturas mais complexas de transaÃ§Ãµes, que nÃ£o se encaixam na descriÃ§Ã£o fornecida.",
    "dificuldade_experimental": "Muito DifÃ­cil"
  },
  {
    "edicao": 2024,
    "id": "2024-31",
    "numero": 31,
    "enunciado": "Dada a funÃ§Ã£o \\(F(W, X, Y, Z)\\) composta dos termos mÃ­nimos\n(minterm) = {4, 8, 9, 10, 13, 14} e dos termos nÃ£o essenciais (donâ€™t care) = {5, 6, 7}, simplifique\nessa funÃ§Ã£o como produto de somas.",
    "alternativas": [
      "a) \\((W+X)*( \\bar{W} + \\bar{X} + Y + Z)*( \\bar{Y} + \\bar{Z})\\)",
      "b) \\((W+ \\bar{X}+ \\bar{Z})*(W+X+ \\bar{Z} )*(\\bar{W} + \\bar{X})*(\\bar{Y} + Z)\\)",
      "c) \\((\\bar{W} + X)*(W+Y+ \\bar{Z})*(W+\\bar{Y}+Z)* *(W+\\bar{X}+ \\bar{Y})\\)",
      "d) \\((W+X)*(\\bar{W} + \\bar{Y} + \\bar{Z})\\)",
      "e) \\((W+X)*(\\bar{W} + \\bar{Y} + \\bar{Z})*(\\bar{W} + \\bar{X} + Y + Z)\\)"
    ],
    "area_conhecimento": "Fundamentos da ComputaÃ§Ã£o",
    "area": "Circuitos Digitais",
    "subarea": "MinimizaÃ§Ã£o e OtimizaÃ§Ã£o de FunÃ§Ãµes CombinatÃ³rias",
    "dificuldade": "MÃ©dia",
    "gabarito": "A",
    "solucao": "Para simplificar a funÃ§Ã£o F(W, X, Y, Z) como produto de somas, comeÃ§amos identificando os mintermos e os termos don't care. Os mintermos dados sÃ£o {4, 8, 9, 10, 13, 14} e os don't care sÃ£o {5, 6, 7}. Em binÃ¡rio, esses mintermos sÃ£o: 4 (0100), 8 (1000), 9 (1001), 10 (1010), 13 (1101), 14 (1110). Os don't care sÃ£o: 5 (0101), 6 (0110), 7 (0111). Utilizando o mapa de Karnaugh para simplificaÃ§Ã£o, podemos agrupar os mintermos e os don't care para obter a expressÃ£o mais simplificada. ApÃ³s simplificaÃ§Ã£o, a expressÃ£o como produto de somas Ã© (W+X)*(WÌ… + YÌ… + ZÌ…)*(WÌ… + XÌ… + Y + Z), que corresponde Ã  alternativa E.",
    "dificuldade_experimental": "Muito DifÃ­cil"
  },
  {
    "edicao": 2024,
    "id": "2024-51",
    "numero": 51,
    "enunciado": "Em um banco de dados relacional, considere um esquema de relaÃ§Ã£o para um conjunto de itens, que define uma hierarquia pertinente Ã  composiÃ§Ã£o de peÃ§as de uma mÃ¡quina, a saber: **ITEM (Id, Nome, Fk)**; o atributo **ID** Ã© a chave primÃ¡ria de ITEM; o atributo **Nome** rotula o item; o atributo **Fk** Ã© uma chave estrangeira em ITEM, que determina o item ascendente imediato na\nhierarquia. Em determinado momento, o conjunto de tuplas em ITEM Ã©: (1, 'Item 1', NULL);\n(2, 'Item 2', 1); (3, 'Item 3', 1); (4, 'Item 4', 3). Seja uma consulta escrita em SQL, conforme\napresentada abaixo:\n```\nSELECT FILHO.Id, FILHO.Nome, PAI.Id, PAI.Nome\nFROM ITEM AS FILHO RIGHT OUTER JOIN ITEM AS PAI ON FILHO.Fk = PAI.Id\n```\nAo executar essa consulta, a relaÃ§Ã£o resultante possui:",
    "alternativas": [
      "a) 2 tuplas.",
      "b) 3 tuplas.",
      "c) 4 tuplas.",
      "d) 5 tuplas.",
      "e) 6 tuplas."
    ],
    "area_conhecimento": "Tecnologia de ComputaÃ§Ã£o",
    "area": "Banco de Dados",
    "subarea": "Linguagens de Consulta",
    "dificuldade": "MÃ©dia",
    "gabarito": "D",
    "solucao": "A consulta SQL fornecida utiliza um RIGHT OUTER JOIN na tabela ITEM, unindo a tabela consigo mesma. O RIGHT OUTER JOIN garante que todas as tuplas da tabela Ã  direita (PAI) sejam incluÃ­das no resultado, mesmo que nÃ£o tenham correspondÃªncia na tabela Ã  esquerda (FILHO). A condiÃ§Ã£o de junÃ§Ã£o Ã© FILHO.Fk = PAI.Id, o que significa que estamos procurando por itens que tÃªm um item pai. Analisando as tuplas fornecidas: (1, 'Item 1', NULL); (2, 'Item 2', 1); (3, 'Item 3', 1); (4, 'Item 4', 3), podemos ver que:\n1. 'Item 2' e 'Item 3' tÃªm 'Item 1' como pai.\n2. 'Item 4' tem 'Item 3' como pai.\n\nAo aplicar o RIGHT OUTER JOIN, obtemos:\n- Para 'Item 1' (PAI), temos duas correspondÃªncias: 'Item 2' e 'Item 3'.\n- Para 'Item 3' (PAI), temos uma correspondÃªncia: 'Item 4'.\n- 'Item 1' como PAI nÃ£o tem FILHO correspondente, mas serÃ¡ incluÃ­do no resultado devido ao RIGHT OUTER JOIN.\n\nPortanto, o resultado da consulta terÃ¡ 3 tuplas:\n1. (2, 'Item 2', 1, 'Item 1')\n2. (3, 'Item 3', 1, 'Item 1')\n3. (4, 'Item 4', 3, 'Item 3')\n\nLogo, a resposta correta Ã© a alternativa B) 3 tuplas.",
    "dificuldade_experimental": "Muito DifÃ­cil"
  },
  {
    "edicao": 2024,
    "id": "2024-53",
    "numero": 53,
    "enunciado": "Ãrvores B e B+ sÃ£o Ã¡rvores de busca empregadas Ã  implementaÃ§Ã£o de estruturas de\nindexaÃ§Ã£o, conforme a literatura na Ã¡rea de banco de dados. Essencialmente, a pesquisa nessas\nÃ¡rvores objetiva encontrar o(s) endereÃ§o(s) do(s) bloco(s) de dados onde estÃ£o os dados que atendem\nao predicado de busca. Em outras palavras, hÃ¡ o ponteiro de Ã¡rvore, que define a hierarquia entre os\nnÃ³s da arvore, e o ponteiro de dados, que possui o endereÃ§o de bloco de dados. Qu anto Ã  estrutura\ndas Ã¡rvores B e B+, Ã© possÃ­vel abstrair quatro tipos de nÃ³s:\n- I. NÃ³s internos na Ã¡rvore B.\n- II. NÃ³s folha na Ã¡rvore B.\n- III. NÃ³s internos na Ã¡rvore B+.\n- IV. NÃ³s folha na Ã¡rvore B+.\n\nEntre os tipos apresentados, sÃ£o nÃ³s que possuem ponteiros de dados:",
    "alternativas": [
      "a) Apenas I, II e III.",
      "b) Apenas I, II e IV.",
      "c) Apenas I, III e IV.",
      "d) Apenas II, III e IV.",
      "e) I, II, III e IV."
    ],
    "area_conhecimento": "Tecnologia de ComputaÃ§Ã£o",
    "area": "Banco de Dados",
    "subarea": "Sistemas de Gerenciamento de Bancos de Dados (SGBD): Arquitetura, SeguranÃ§a, Integridade, ConcorrÃªncia, RecuperaÃ§Ã£o apÃ³s Falha, Gerenciamento de TransaÃ§Ãµes",
    "dificuldade": "MÃ©dia",
    "gabarito": "B",
    "solucao": "Para entender quais tipos de nÃ³s possuem ponteiros de dados nas Ã¡rvores B e B+, Ã© necessÃ¡rio compreender a estrutura dessas Ã¡rvores. Nas Ã¡rvores B, os nÃ³s internos nÃ£o armazenam ponteiros de dados, apenas os nÃ³s folha armazenam. JÃ¡ nas Ã¡rvores B+, os nÃ³s folha armazenam ponteiros de dados, enquanto os nÃ³s internos apenas contÃªm ponteiros para outros nÃ³s. Portanto, os nÃ³s que possuem ponteiros de dados sÃ£o: II (NÃ³s folha na Ã¡rvore B) e IV (NÃ³s folha na Ã¡rvore B+). Os nÃ³s internos na Ã¡rvore B+ (III) nÃ£o possuem ponteiros de dados, mas apenas ponteiros para outros nÃ³s. Assim, a alternativa correta Ã© 'D) Apenas II, III e IV.'",
    "dificuldade_experimental": "Muito DifÃ­cil"
  },
  {
    "edicao": 2024,
    "id": "2024-56",
    "numero": 56,
    "enunciado": "Analise as matrizes de transformaÃ§Ãµes geomÃ©tricas A e B.\n\\[\\textbf{A}:\\begin{bmatrix}x'\\\\y'\\\\1\\end{bmatrix} = \\begin{bmatrix}cos(\\theta) & -sen(\\theta) & 0\\\\ sen(\\theta) & cos(\\theta) & 0\\\\ 0 & 0 & 1\\end{bmatrix} \\cdot \\begin{bmatrix}x\\\\y\\\\1\\end{bmatrix} \\]\n\n\\[\\textbf{B}:\\begin{bmatrix}x'\\\\y'\\\\1\\end{bmatrix} = \\begin{bmatrix}E_x & 0 & T_x\\\\ 0 & E_y & T_y \\\\0 & 0 & 1\\end{bmatrix} \\cdot \\begin{bmatrix}x\\\\y\\\\1\\end{bmatrix} \\]\n\nConsiderando que \\(ğ¸_x\\) e \\(ğ¸_y\\) sÃ£o fatores de escala, \\(ğ‘‡_x\\) e \\(ğ‘‡_y\\) sÃ£o fatores de translaÃ§Ã£o e que \\(\\theta\\) representa\num Ã¢ngulo de rotaÃ§Ã£o, analise as assertivas a seguir:\\\nI. A transformaÃ§Ã£o **A** rotaciona o objeto com pivÃ´ no centro de massa do prÃ³prio objeto.\\\nII. A transformaÃ§Ã£o **B** primeiro escala e depois translada o objeto.\\\nIII. O uso da coordenada homogÃªnea tanto para a transformaÃ§Ã£o **A** quanto para **B** Ã© necessÃ¡rio, pois sem ela nÃ£o Ã© possÃ­vel a realizaÃ§Ã£o de tais transformaÃ§Ãµes.\\\nQuais estÃ£o corretas?",
    "alternativas": [
      "a) Apenas I.",
      "b) Apenas II.",
      "c) Apenas I e III.",
      "d) Apenas II e III.",
      "e) I, II e III."
    ],
    "area_conhecimento": "Tecnologia de ComputaÃ§Ã£o",
    "area": "ComputaÃ§Ã£o GrÃ¡fica",
    "subarea": "TransformaÃ§Ãµes GeomÃ©tricas em Duas e TrÃªs DimensÃµes: Coordenadas HomogÃªneas e Matrizes de TransformaÃ§Ã£o",
    "dificuldade": "MÃ©dia",
    "gabarito": "B",
    "solucao": "Para resolver a questÃ£o, precisamos analisar cada uma das assertivas:\n\nI. A transformaÃ§Ã£o A rotaciona o objeto com pivÃ´ no centro de massa do prÃ³prio objeto.\n- A matriz A Ã© uma matriz de rotaÃ§Ã£o. No entanto, a rotaÃ§Ã£o em torno do centro de massa do objeto nÃ£o Ã© garantida apenas pela matriz de rotaÃ§Ã£o padrÃ£o. A rotaÃ§Ã£o padrÃ£o ocorre em torno da origem do sistema de coordenadas. Para rotacionar em torno do centro de massa, seria necessÃ¡rio primeiro transladar o objeto para que o centro de massa coincida com a origem, aplicar a rotaÃ§Ã£o e depois transladar de volta. Portanto, a assertiva I Ã© falsa.\n\nII. A transformaÃ§Ã£o B primeiro escala e depois translada o objeto.\n- A matriz B Ã© uma matriz de transformaÃ§Ã£o que inclui escala (E_x, E_y) e translaÃ§Ã£o (T_x, T_y). A ordem das operaÃ§Ãµes em uma matriz de transformaÃ§Ã£o composta Ã© da esquerda para a direita, ou seja, a escala Ã© aplicada antes da translaÃ§Ã£o. Portanto, a assertiva II Ã© verdadeira.\n\nIII. O uso da coordenada homogÃªnea tanto para a transformaÃ§Ã£o A quanto para B Ã© necessÃ¡rio, pois sem ela nÃ£o Ã© possÃ­vel a realizaÃ§Ã£o de tais transformaÃ§Ãµes.\n- Coordenadas homogÃªneas sÃ£o necessÃ¡rias para representar translaÃ§Ãµes em transformaÃ§Ãµes geomÃ©tricas usando matrizes. Sem coordenadas homogÃªneas, nÃ£o seria possÃ­vel incluir a translaÃ§Ã£o na matriz de transformaÃ§Ã£o. Portanto, a assertiva III Ã© verdadeira.\n\nCom base na anÃ¡lise acima, as assertivas II e III sÃ£o corretas. Portanto, a alternativa correta Ã© D) Apenas II e III.",
    "dificuldade_experimental": "Muito DifÃ­cil"
  },
  {
    "edicao": 2024,
    "id": "2024-57",
    "numero": 57,
    "enunciado": "Analise as assertivas abaixo sobre tÃ©cnicas de renderizaÃ§Ã£o e iluminaÃ§Ã£o e assinale\na alternativa correta.\n- I. Ray Tracing Ã© uma tÃ©cnica que visa simular a propagaÃ§Ã£o da luz no ambiente, avaliando a sua\ninteraÃ§Ã£o com os objetos que o compÃµem e considerando a interaÃ§Ã£o da luz com as suas\nsuperfÃ­cies. Esta tÃ©cnica Ã© frequentemente utilizada em jogos digitais, dado o seu grau de realismo\ne o fato de a velocidade de renderizaÃ§Ã£o ser eficiente para aplicaÃ§Ãµes de tempo real.\n- II. Z-Buffer Ã© uma tÃ©cnica que visa armazenar a profundidade dos objetos em relaÃ§Ã£o Ã  cÃ¢mera,\nfazendo com que se grave, para cada pixel, qual objeto estÃ¡ mais distante. Essa tÃ©cnica Ã© utilizada\npara reduzir o tempo de rendering, especialmente para aplicaÃ§Ãµes que exigem muito do hardware,\ncomo no caso das cenas ultrarrealistas geradas no Ã¢mbito cinematogrÃ¡fico, uma vez que essa\ntÃ©cnica representa o estado da arte da geraÃ§Ã£o de cenas tridimensionais ultrarrealistas.\n- III. O Modelo de ReflexÃ£o de Phong Ã© utilizado para renderizaÃ§Ã£o da iluminaÃ§Ã£o de objetos. Sua\ncaracterÃ­stica principal Ã© a combinaÃ§Ã£o da reflexÃ£o difusa, especular e ambiente para formar uma\niluminaÃ§Ã£o mais realista. Como esta Ã© uma tÃ©cnica de iluminaÃ§Ã£o global e considera o cÃ¡lculo\ntanto da incidÃªncia de luz direta quanto indireta, nÃ£o Ã© muito utilizada em jogos digitais ou\naplicaÃ§Ãµes de tempo real, devido ao seu alto custo de tempo de processamento.",
    "alternativas": [
      "a) Todas as assertivas estÃ£o corretas.",
      "b) Todas as assertivas estÃ£o incorretas.",
      "c) Apenas as assertivas I e II estÃ£o corretas.",
      "d) Apenas as assertivas I e III estÃ£o corretas.",
      "e) Apenas as assertivas II e III estÃ£o corretas."
    ],
    "area_conhecimento": "Tecnologia de ComputaÃ§Ã£o",
    "area": "ComputaÃ§Ã£o GrÃ¡fica",
    "subarea": "O Processo de 'Rendering': Fontes de Luz, RemoÃ§Ã£o de Linhas e SuperfÃ­cies Ocultas",
    "dificuldade": "MÃ©dia",
    "gabarito": "B",
    "solucao": "Vamos analisar cada assertiva: \n\nI. A assertiva I descreve o Ray Tracing como uma tÃ©cnica que simula a propagaÃ§Ã£o da luz e suas interaÃ§Ãµes com os objetos, o que estÃ¡ correto. No entanto, a afirmaÃ§Ã£o de que Ã© frequentemente utilizada em jogos digitais devido Ã  sua eficiÃªncia em tempo real Ã© incorreta. Ray Tracing Ã© conhecido por seu alto custo computacional, o que o torna menos adequado para aplicaÃ§Ãµes de tempo real, embora avanÃ§os recentes tenham permitido sua utilizaÃ§Ã£o em jogos modernos com hardware avanÃ§ado.\n\nII. A assertiva II descreve o Z-Buffer como uma tÃ©cnica para armazenar a profundidade dos objetos em relaÃ§Ã£o Ã  cÃ¢mera, o que estÃ¡ correto. No entanto, a afirmaÃ§Ã£o de que Ã© utilizada para cenas ultrarrealistas no cinema e que representa o estado da arte Ã© incorreta. O Z-Buffer Ã© uma tÃ©cnica bÃ¡sica para remoÃ§Ã£o de superfÃ­cies ocultas e nÃ£o Ã© especÃ­fica para cenas ultrarrealistas.\n\nIII. A assertiva III descreve corretamente o Modelo de ReflexÃ£o de Phong, que combina reflexÃ£o difusa, especular e ambiente para uma iluminaÃ§Ã£o mais realista. No entanto, a afirmaÃ§Ã£o de que Ã© uma tÃ©cnica de iluminaÃ§Ã£o global e nÃ£o Ã© muito utilizada em jogos devido ao alto custo Ã© incorreta. O modelo de Phong Ã© uma tÃ©cnica de iluminaÃ§Ã£o local, nÃ£o global, e Ã© amplamente utilizado em jogos devido ao seu equilÃ­brio entre realismo e custo computacional.\n\nPortanto, apenas a assertiva III estÃ¡ correta, tornando a alternativa D a correta.",
    "dificuldade_experimental": "Muito DifÃ­cil"
  },
  {
    "edicao": 2024,
    "id": "2024-66",
    "numero": 66,
    "enunciado": "Assinale a alternativa correta.",
    "alternativas": [
      "a) O protocolo IP Ã© baseado em datagramas e orientado Ã  conexÃ£o.",
      "b) O protocolo IP funciona segundo melhor esforÃ§o possÃ­vel garantindo a entrega de mensagens.",
      "c) O protocolo IP Ã© conhecido como a cola da Internet porque ele permite que outros protocolos sejam usados no seu lugar.",
      "d) VÃ¡rias cÃ³pias de um pacote IP podem ser entregues.",
      "e) O datagrama IP identifica o destinatÃ¡rio atravÃ©s dos campos porta de destino e nÃºmero IP de\ndestino."
    ],
    "area_conhecimento": "Tecnologia de ComputaÃ§Ã£o",
    "area": "Redes de Computadores",
    "subarea": "Protocolos e ServiÃ§os de ComunicaÃ§Ã£o",
    "dificuldade": "FÃ¡cil",
    "gabarito": "D",
    "solucao": "A questÃ£o aborda o funcionamento do protocolo IP, que Ã© um dos principais protocolos da camada de rede na arquitetura da Internet. Vamos analisar cada alternativa: \n\nA) Incorreta. O protocolo IP nÃ£o Ã© orientado Ã  conexÃ£o; ele Ã© um protocolo de datagrama, o que significa que cada pacote Ã© tratado de forma independente. \n\nB) Correta. O protocolo IP Ã© baseado no princÃ­pio de 'melhor esforÃ§o', o que significa que ele tenta entregar os pacotes, mas nÃ£o garante a entrega, a ordem ou a integridade dos dados. \n\nC) Incorreta. O protocolo IP nÃ£o Ã© substituÃ­do por outros protocolos; ele Ã© essencial para a comunicaÃ§Ã£o na Internet, servindo como base para protocolos de camadas superiores. \n\nD) Incorreta. Embora pacotes IP possam ser duplicados devido a retransmissÃµes, o protocolo IP nÃ£o garante que vÃ¡rias cÃ³pias sejam entregues como parte de seu funcionamento normal. \n\nE) Incorreta. O datagrama IP utiliza o endereÃ§o IP de destino para identificar o destinatÃ¡rio, mas nÃ£o inclui informaÃ§Ãµes sobre a porta de destino, que sÃ£o usadas por protocolos de camada de transporte como TCP ou UDP.",
    "dificuldade_experimental": "Muito DifÃ­cil"
  }
]
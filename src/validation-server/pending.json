[
  {
    "edicao": 2008,
    "id": "2008-01",
    "numero": 1,
    "enunciado": "Considere o projeto lógico do banco de dados representado pelo modelo E-R abaixo.\nN M\nARTISTAS PARTICIPANTES DISCOS\ncod-art nome gênero N título cod-disco\ndata\n1\nGRAVADORA PRODUÇÃO\nestúdio\ncod-grav nome-grav\nDiga de que tabelas e campos ele resulta (obs: campos chave estão sublinhados):",
    "alternativas": [
      "A) ARTISTAS (cod-art, nome, gênero)\nPARTICIPANTES (cod-art, cod-disco)\nDISCOS (cod-disco, título, data)\nPRODUÇÃO (cod-grav, cod-disco, estúdio)\nGRAVADORA (cod-grav, nome-grav)",
      "B) ARTISTAS (cod-art, nome, gênero)\nPARTICIPANTES (cod-art, cod-disco)\nDISCOS (cod-disco, título, data, cod-grav, estúdio)\nGRAVADORA (cod-grav, nome-grav)",
      "C) ARTISTAS (cod-art, nome, gênero)\nPARTICIPANTES (cod-art, cod-disco)\nDISCOS (cod-disco, título, data, cod-grav, nome-grav, estúdio)",
      "D) ARTISTAS (cod-art, nome, gênero)\nDISCOS (cod-disco, título, data, cod-art)\nPRODUÇÃO (cod-grav, cod-disco, estúdio)\nGRAVADORA (cod-grav, nome-grav)",
      "E) ARTISTAS (cod-art, nome, gênero)\nDISCOS (cod-disco, título, data, cod-grav, estúdio, cod-art)\nGRAVADORA (cod-grav, nome-grav)"
    ],
    "area_conhecimento": "Matemática",
    "area": "Matemática Discreta",
    "subarea": "Relações de Equivalência",
    "dificuldade": "Média",
    "gabarito": "A",
    "solucao": "Para resolver a questão, é necessário entender a transformação de um modelo Entidade-Relacionamento (E-R) em um esquema de banco de dados relacional. O modelo E-R apresentado envolve entidades ARTISTAS, DISCOS e GRAVADORA, além de relacionamentos PARTICIPANTES e PRODUÇÃO. \n\n1. A entidade ARTISTAS possui os atributos cod-art (chave primária), nome e gênero. Isso se traduz diretamente na tabela ARTISTAS(cod-art, nome, gênero).\n\n2. O relacionamento PARTICIPANTES é um relacionamento N:M entre ARTISTAS e DISCOS. Isso requer uma tabela intermediária que contenha as chaves primárias de ambas as entidades: PARTICIPANTES(cod-art, cod-disco).\n\n3. A entidade DISCOS possui os atributos cod-disco (chave primária), título e data. Isso se traduz diretamente na tabela DISCOS(cod-disco, título, data).\n\n4. O relacionamento PRODUÇÃO é um relacionamento entre DISCOS e GRAVADORA, que inclui o atributo estúdio. Isso se traduz na tabela PRODUÇÃO(cod-grav, cod-disco, estúdio).\n\n5. A entidade GRAVADORA possui os atributos cod-grav (chave primária) e nome-grav. Isso se traduz diretamente na tabela GRAVADORA(cod-grav, nome-grav).\n\nPortanto, a alternativa correta é a A, que reflete corretamente a transformação do modelo E-R para o esquema relacional."
  },
  {
    "edicao": 2008,
    "id": "2008-02",
    "numero": 2,
    "enunciado": "Considere que as transações T1 e T2 abaixo possam ocorrer simultaneamente.\nT1 T2\nLeitura(A); Leitura(B);\nA = A + 100; Leitura(A);\nEscrita(A); Print (A+B);\nLeitura(B);\nB = B - 100;\nEscrita(B);\nAnalise as seguintes situações.\nI. A operação Leitura(A) de T2 é executada após a operação Escrita(A) e antes da\noperação Leitura(B) de T1. Entretanto, a operação Escrita(B) de T1 causa uma\nviolação de integridade, e a transação T1 é abortada, sendo suas operações desfeitas.\nII. Após as operações da transação T1 terem sido executadas, é enviada uma\nmensagem ao usuário informando que a transação foi completada com êxito.\nEntretanto, antes que os buffers relativos a T1 sejam descarregados para o meio\nfísico, ocorre uma falha, e os dados não são efetivamente gravados.\nAs propriedades das transações que foram violadas nessas duas situações são,\nrespectivamente,",
    "alternativas": [
      "A) Atomicidade e Consistência.",
      "B) Durabilidade e Atomicidade.",
      "C) Atomicidade e Durabilidade.",
      "D) Durabilidade e Isolamento.",
      "E) Isolamento e Durabilidade."
    ],
    "area_conhecimento": "Matemática",
    "area": "Banco de Dados",
    "subarea": "Transações e Controle de Concorrência",
    "dificuldade": "Média",
    "gabarito": "C",
    "solucao": "Para resolver essa questão, precisamos analisar as propriedades das transações que foram violadas em cada situação descrita. \n\nNa situação I, a transação T1 é abortada e suas operações são desfeitas devido a uma violação de integridade causada pela operação Escrita(B). A propriedade violada aqui é a atomicidade, que garante que todas as operações de uma transação sejam completadas com sucesso ou nenhuma delas seja aplicada. \n\nNa situação II, após a execução das operações da transação T1, ocorre uma falha antes que os dados sejam gravados no meio físico. Isso viola a propriedade de durabilidade, que assegura que uma vez que uma transação é completada com sucesso, suas alterações persistem mesmo em caso de falhas. \n\nPortanto, as propriedades violadas são atomicidade na situação I e durabilidade na situação II, o que corresponde à alternativa C."
  },
  {
    "edicao": 2008,
    "id": "2008-03",
    "numero": 3,
    "enunciado": "Considere as imagens I , dada por I (i,j)=9((i+j)mod 2),\n1 1\ne I , dada por I (i,j)=9((i+j)mod 3),\n2 2\nrepresentadas nas tabelas abaixo para dimensões 5 5:\n0 9 0 9 0 0 9 18 0 9\n9 0 9 0 9 9 18 0 9 18\n0 9 0 9 0 18 0 9 18 0\n9 0 9 0 9 0 9 18 0 9\n0 9 0 9 0 9 18 0 9 18\n(I ) (I )\n1 2\nDada a janela V(i,j) de dimensões 3x3 centrada no pixel (i,j) de uma imagem I, considere\nos filtros que atribuem a (i,j) o valor dado pela média e pela mediana dos valores de I em\nV(i,j).\nDesconsiderando os pixels nas bordas das imagens, pode-se afirmar que,",
    "alternativas": [
      "A) aplicando-se o filtro da média a I , toda a imagem assume um mesmo valor.\n1",
      "B) aplicando-se o filtro da mediana a I , toda a imagem assume o mesmo valor.\n2",
      "C) aplicando-se os filtros da média e da mediana à imagem I1, obtém-se o mesmo\nresultado.",
      "D) aplicando-se os filtros da média e da mediana à imagem I2, não se obtém o mesmo\nresultado.",
      "E) nenhuma das alternativas anteriores é correta."
    ],
    "area_conhecimento": "Matemática",
    "area": "Probabilidade e Estatística",
    "subarea": "Análise Exploratória de Dados",
    "dificuldade": "Média",
    "gabarito": "D",
    "solucao": "Para resolver a questão, precisamos aplicar os filtros de média e mediana nas imagens I1 e I2. \n\nPrimeiro, analisamos a imagem I1, que é dada por I1(i,j) = 9((i+j) mod 2). Isso resulta em uma imagem com um padrão xadrez de valores 0 e 9. Ao aplicar o filtro da média em uma janela 3x3, cada pixel central terá a média dos valores ao seu redor. Devido à simetria e ao padrão regular da imagem, a média para qualquer janela 3x3 será a mesma, resultando em uma imagem homogênea após o filtro. O mesmo ocorre com o filtro da mediana, pois a mediana de uma janela 3x3 em um padrão regular também será constante. Portanto, para I1, os filtros de média e mediana produzem o mesmo resultado.\n\nAgora, analisamos a imagem I2, que é dada por I2(i,j) = 9((i+j) mod 3). Isso resulta em uma imagem com um padrão repetitivo de 0, 9, e 18. Ao aplicar o filtro da média, o valor central será a média dos valores na janela 3x3, que variará dependendo da posição da janela devido à presença de três valores diferentes (0, 9, 18). Já o filtro da mediana, que seleciona o valor central da distribuição dos valores na janela, também variará, mas não necessariamente coincidirá com a média. Portanto, para I2, os filtros de média e mediana não produzem o mesmo resultado.\n\nAssim, a alternativa correta é D) aplicando-se os filtros da média e da mediana à imagem I2, não se obtém o mesmo resultado."
  },
  {
    "edicao": 2008,
    "id": "2008-04",
    "numero": 4,
    "enunciado": "Considere o filtro F definido por:\nF ( I ) ( i , j )\n| { ( I ( i 1, j 1) I ( i , j 1) I ( i 1, j ) } { ( I ( i 1, j 1) I ( i , j 1) I ( i 1, j ) } |\n3\nAs figuras abaixo representam imagens binárias de dimensões n n, com n grande. O\npixel (0,0) é o do canto superior esquerdo.\nn 1 n 1\nAssinale em qual figura { F ( I )( i , j )} é maior.\ni 0 j 0",
    "alternativas": [
      "A)",
      "B)",
      "C)",
      "D)",
      "E)"
    ],
    "area_conhecimento": "Matemática",
    "area": "Matemática Discreta",
    "subarea": "Funções e Formas Booleanas",
    "dificuldade": "Média",
    "gabarito": "A)",
    "solucao": "Para resolver esta questão, precisamos entender o que o filtro F faz. O filtro F calcula a diferença absoluta entre duas somas de pixels em torno de uma posição (i, j) em uma imagem binária. A primeira soma é composta pelos pixels I(i-1, j-1), I(i, j-1) e I(i-1, j), enquanto a segunda soma é composta pelos mesmos pixels. Como a fórmula dada parece ter um erro de digitação (as duas somas são idênticas), vamos assumir que a intenção era comparar duas regiões diferentes da imagem. A questão pede para determinar em qual figura a soma dos valores de F(I)(i, j) é maior, o que implica que devemos procurar a imagem com mais variação local, ou seja, onde há mais mudanças de 0 para 1 ou de 1 para 0 entre pixels adjacentes. Sem as imagens, não podemos calcular diretamente, mas a alternativa correta seria a que representa uma imagem com mais bordas ou transições. Assumindo que a figura A) tem mais dessas transições, a resposta seria A)."
  },
  {
    "edicao": 2008,
    "id": "2008-05",
    "numero": 5,
    "enunciado": "Analise as seguintes afirmativas.\nI. Extreme Programming, RUP e Prototipação são exemplos de métodos ágeis.\nII. Na UML2, diagramas de contextos são usados para representar o sistema e sua\ninteração com atores e ambiente externo.\nIII. Os padrões de projeto de software são classificados em padrões de criação,\nestruturais e comportamentais.\nIV. A falha para cumprir um requisito funcional pode degradar o sistema e a falha em\ncumprir um requisito não-funcional pode tornar todo um sistema inútil.\nA partir dessa análise, pode-se concluir que estão INCORRETAS",
    "alternativas": [
      "A) todas as afirmativas.",
      "B) apenas as afirmativas I e II.",
      "C) apenas as afirmativas I, II e III.",
      "D) apenas as afirmativas I, III e IV.",
      "E) apenas as afirmativas II e III."
    ],
    "area_conhecimento": "Matemática",
    "area": "Engenharia de Software",
    "subarea": "Processos de Desenvolvimento de Software",
    "dificuldade": "Média",
    "gabarito": "B",
    "solucao": "Vamos analisar cada afirmativa: \n\nI. Extreme Programming e Prototipação são métodos ágeis, mas RUP (Rational Unified Process) não é considerado um método ágil, pois é um processo de desenvolvimento de software mais estruturado e formal. Portanto, a afirmativa I está incorreta.\n\nII. Na UML2, não existem 'diagramas de contextos' como um tipo padrão de diagrama. Os diagramas na UML incluem diagramas de casos de uso, diagramas de classes, diagramas de sequência, entre outros. Portanto, a afirmativa II está incorreta.\n\nIII. Os padrões de projeto de software são de fato classificados em padrões de criação, estruturais e comportamentais. Portanto, a afirmativa III está correta.\n\nIV. A falha em cumprir um requisito funcional pode, de fato, degradar o sistema, e a falha em cumprir um requisito não-funcional pode tornar o sistema menos eficiente ou menos utilizável, mas não necessariamente 'inútil'. A afirmativa IV é um pouco exagerada, mas não está completamente incorreta.\n\nPortanto, as afirmativas incorretas são I e II, o que corresponde à alternativa B."
  },
  {
    "edicao": 2008,
    "id": "2008-06",
    "numero": 6,
    "enunciado": "Analise as seguintes afirmativas.\nI. Existem vários modelos de processo de software ou paradigmas de engenharia de\nsoftware. No paradigma conhecido como ciclo de vida clássico, a especificação pode\nser desenvolvida gradativamente à medida que os usuários conseguem compreender\nmelhor suas necessidades.\nII. O gerente de projeto é responsável pelas atividades de planejamento, gerenciamento\nde riscos e pela estimativa de custo e de esforço (homem-hora) para a realização de\num projeto.\nIII. O teste estrutural requer o conhecimento do algoritmo e da implementação do\nprograma na definição dos casos de teste.\nIV. Após a entrega e implantação do software ao cliente, há uma etapa de manutenção,\nque tem por objetivo unicamente corrigir erros e defeitos encontrados no software.\nA partir dessa análise, pode-se concluir que estão CORRETAS",
    "alternativas": [
      "A) todas as afirmativas.",
      "B) apenas as afirmativas I e II.",
      "C) apenas as afirmativas I, II e III.",
      "D) apenas as afirmativas II e III.",
      "E) apenas as afirmativas II, III e IV."
    ],
    "area_conhecimento": "Matemática",
    "area": "Engenharia de Software",
    "subarea": "Modelos de Processo de Software",
    "dificuldade": "Média",
    "gabarito": "D",
    "solucao": "Vamos analisar cada afirmativa: \n\nI. A afirmativa está incorreta. No ciclo de vida clássico, também conhecido como modelo cascata, a especificação é feita de forma completa antes do desenvolvimento, não gradativamente. \n\nII. A afirmativa está correta. O gerente de projeto é responsável por planejamento, gerenciamento de riscos, estimativa de custo e esforço, entre outras atividades. \n\nIII. A afirmativa está correta. O teste estrutural, também conhecido como teste de caixa branca, requer conhecimento do algoritmo e da implementação para definir casos de teste. \n\nIV. A afirmativa está incorreta. A manutenção de software não se limita apenas à correção de erros. Ela também pode incluir melhorias e adaptações às novas necessidades dos usuários.\n\nPortanto, as afirmativas corretas são II e III, o que corresponde à alternativa D."
  },
  {
    "edicao": 2008,
    "id": "2008-07",
    "numero": 7,
    "enunciado": "Analise as seguintes afirmativas.\nI. Um servidor DNS suporta dois tipos de consulta: iterativa e recursiva. Na consulta\niterativa que é a mais utilizada, caso um servidor DNS não tenha a informação pedida\npela máquina solicitante, ele irá buscar a mesma consultando outros servidores.\nII. Como estratégia para aumentar a confiabilidade na resposta dos servidores DNS\nquando do emprego de caches, devem-se utilizar valores grandes de TLL (Time-To-\nLive), mantendo elevado o tempo de validade do registro na cache.\nIII. Um servidor DNS pode atender dois tipos de consultas: tradução direta, na qual, a\npartir de um endereço IP, o mesmo retorna o nome de rede do equipamento; e\ntradução inversa, na qual, a partir de um nome de rede, retorna o IP associado ao\nmesmo.\nA análise permite concluir que",
    "alternativas": [
      "A) nenhuma afirmativa está correta.",
      "B) somente a afirmativa I está correta",
      "C) somente a afirmativa II está correta.",
      "D) somente a afirmativa III está correta.",
      "E) todas as afirmativas estão corretas."
    ],
    "area_conhecimento": "Matemática",
    "area": "Matemática Discreta",
    "subarea": "Indução e Recursão",
    "dificuldade": "Fácil",
    "gabarito": "A",
    "solucao": "Vamos analisar cada uma das afirmativas: \n\nI. A afirmativa I está incorreta. Na consulta iterativa, o servidor DNS não busca a informação em outros servidores. Em vez disso, ele responde com a melhor informação que possui, que pode ser um redirecionamento para outro servidor DNS que esteja mais próximo da resposta. A busca em outros servidores é característica da consulta recursiva.\n\nII. A afirmativa II está incorreta. Utilizar valores grandes de TTL (Time-To-Live) pode aumentar a eficiência do cache, mas não necessariamente a confiabilidade. Valores grandes de TTL podem resultar em informações desatualizadas, o que pode comprometer a confiabilidade das respostas.\n\nIII. A afirmativa III está incorreta. A tradução direta é a conversão de um nome de domínio para um endereço IP, enquanto a tradução inversa é a conversão de um endereço IP para um nome de domínio. A descrição na afirmativa está invertida.\n\nPortanto, nenhuma das afirmativas está correta."
  },
  {
    "edicao": 2008,
    "id": "2008-08",
    "numero": 8,
    "enunciado": "O nível de transporte oferece serviços para comunicação entre computadores,\nindependentemente das tecnologias utilizadas nos outros níveis.\nAnalise as seguintes afirmativas relativas à confirmação do recebimento de pacotes no\nnível de transporte.\nI. A troca de dados entre um computador transmissor e um receptor não precisa\nobrigatoriamente de uma confirmação para cada pacote enviado. Existem três\nestratégias que podem ser utilizadas: confirmação seletiva, confirmação cumulativa e\nconfirmação em bloco.\nII. Na confirmação seletiva, cada pacote recebido por um computador não gera uma\ninformação de confirmação individualizada para o computador que enviou o pacote.\nIII. Na confirmação do recebimento de pacotes, o consumo da banda de rede pode ser\notimizado pelo uso de um mecanismo denominado piggybacking. No piggybacking a\ninformação de confirmação \"pega carona\" em mensagem de dados que retorna ao\ncomputador emissor como conseqüência do fluxo normal de troca de dados.\nA análise permite concluir que",
    "alternativas": [
      "A) nenhuma das afirmativas está correta.",
      "B) apenas as afirmativas I e II estão corretas.",
      "C) apenas as afirmativas I e III estão corretas.",
      "D) apenas as afirmativas II e III estão corretas.",
      "E) todas as afirmativas estão corretas."
    ],
    "area_conhecimento": "Matemática",
    "area": "Matemática Discreta",
    "subarea": "Teoria dos Códigos",
    "dificuldade": "Média",
    "gabarito": "C",
    "solucao": "Vamos analisar cada uma das afirmativas: \n\nI. A afirmativa I está correta. No nível de transporte, a confirmação de recebimento de pacotes pode ser feita de várias formas, incluindo confirmação seletiva, cumulativa e em bloco. A confirmação seletiva permite que apenas pacotes específicos sejam confirmados, enquanto a cumulativa confirma todos os pacotes até um determinado ponto, e a confirmação em bloco pode confirmar múltiplos pacotes de uma vez.\n\nII. A afirmativa II está incorreta. Na confirmação seletiva, cada pacote recebido pode sim gerar uma confirmação individualizada. Este método é utilizado para confirmar pacotes específicos que foram recebidos corretamente, permitindo retransmissão apenas dos pacotes que não foram confirmados.\n\nIII. A afirmativa III está correta. O piggybacking é uma técnica utilizada para otimizar o uso da banda de rede, onde a confirmação de recebimento de pacotes é enviada junto com dados que estão sendo enviados de volta ao emissor, reduzindo assim o número de pacotes de controle necessários.\n\nPortanto, apenas as afirmativas I e III estão corretas."
  },
  {
    "edicao": 2008,
    "id": "2008-09",
    "numero": 9,
    "enunciado": "Analise as seguintes afirmativas sobre redes neurais sem ciclos dirigidos, sendo n o\nnúmero de neurônios e m o número de conexões.\nI. O processo de treinamento da rede pode ocorrer tanto em um espaço n -dimensional\nquanto em um espaço m -dimensional. A escolha é uma questão de eficiência,\ndependendo de como se relacionem n e m .\nII. Uma vez treinada, o uso da rede consiste em aplicar uma entrada e esperar até que\nocorra convergência para que seja obtida a saída.\nIII. O processo de treinamento consiste em obter um vetor em um espaço pelo menos\nm -dimensional. Esse vetor é obtido por meio de um processo de otimização que\nbusca minimizar o erro sobre as instâncias de treino.\nIV. O processo de treinamento consiste em obter um vetor em um espaço pelo menos\nm -dimensional. Esse vetor é obtido por meio de um processo de otimização que\nbusca minimizar o erro de generalização.\nA análise permite concluir que",
    "alternativas": [
      "A) apenas as afirmativas I e II estão corretas.",
      "B) apenas as afirmativas II e III estão corretas.",
      "C) apenas as afirmativas II e IV estão corretas.",
      "D) apenas a afirmativa III está correta.",
      "E) todas as afirmativas estão corretas."
    ],
    "area_conhecimento": "Matemática",
    "area": "Álgebra Linear",
    "subarea": "Transformações Lineares e Matrizes",
    "dificuldade": "Média",
    "gabarito": "D",
    "solucao": "Vamos analisar cada afirmativa: \n\nI. O processo de treinamento da rede pode ocorrer tanto em um espaço n-dimensional quanto em um espaço m-dimensional. A escolha é uma questão de eficiência, dependendo de como se relacionem n e m. \n- Esta afirmativa está incorreta. O treinamento de redes neurais geralmente ocorre em um espaço de parâmetros que é pelo menos m-dimensional, onde m é o número de conexões (ou pesos) na rede. A dimensão n, que representa o número de neurônios, não é diretamente relevante para o espaço de otimização dos pesos.\n\nII. Uma vez treinada, o uso da rede consiste em aplicar uma entrada e esperar até que ocorra convergência para que seja obtida a saída. \n- Esta afirmativa está incorreta. Redes neurais feedforward, que são um tipo de rede sem ciclos dirigidos, não requerem um processo de convergência ao serem usadas. Elas produzem uma saída diretamente após a aplicação de uma entrada, sem a necessidade de iterações adicionais para convergência.\n\nIII. O processo de treinamento consiste em obter um vetor em um espaço pelo menos m-dimensional. Esse vetor é obtido por meio de um processo de otimização que busca minimizar o erro sobre as instâncias de treino. \n- Esta afirmativa está correta. O treinamento de redes neurais envolve a otimização de um vetor de pesos, que é pelo menos m-dimensional, onde m é o número de conexões na rede. O objetivo é minimizar o erro sobre as instâncias de treino.\n\nIV. O processo de treinamento consiste em obter um vetor em um espaço pelo menos m-dimensional. Esse vetor é obtido por meio de um processo de otimização que busca minimizar o erro de generalização. \n- Esta afirmativa está incorreta. Embora o objetivo final do treinamento de uma rede neural seja obter um modelo que generalize bem, o processo de otimização em si geralmente minimiza o erro sobre o conjunto de treino, não diretamente o erro de generalização.\n\nPortanto, apenas a afirmativa III está correta."
  },
  {
    "edicao": 2008,
    "id": "2008-10",
    "numero": 10,
    "enunciado": "Considere o modelo de agentes cognitivos com arquitetura BDI (Beliefs-Desires-Intentios)\ne analise as seguintes afirmativas.\nI. Agentes BDI são agentes incapazes de executar planos para a realização de tarefas.\nII. Agentes BDI têm a capacidade de ativar um ou mais objetivos, como resultado de\npercepções do ambiente e/ou de recepção de mensagens.\nIII. Intenções em agentes BDI são disposições afetivas motivadas pelo fracasso na\nrealização de tarefas.\nIV. Crenças em agentes BDI são informações que o agente mantém a respeito de si\npróprio e do ambiente em que ele se encontra.\nV. Em um agente BDI, intenções representam objetivos que o agente deliberou alcançar.\nA análise permite concluir que",
    "alternativas": [
      "A) todas as afirmativas estão corretas.",
      "B) somente as afirmativas II, III, IV e V estão corretas.",
      "C) somente a afirmativa II está correta.",
      "D) somente as afirmativas III e V estão corretas.",
      "E) somente as afirmativas II, IV e V estão corretas."
    ],
    "area_conhecimento": "Matemática",
    "area": "Lógica Matemática",
    "subarea": "Lógica Proposicional e de Predicados",
    "dificuldade": "Média",
    "gabarito": "E",
    "solucao": "Vamos analisar cada afirmativa: \n\nI. Incorreta. Agentes BDI são capazes de executar planos para a realização de tarefas, pois a arquitetura BDI é justamente projetada para que agentes possam deliberar e executar planos baseados em suas crenças, desejos e intenções.\n\nII. Correta. Agentes BDI podem ativar objetivos como resultado de percepções do ambiente e/ou de recepção de mensagens. Isso está relacionado à parte de 'Desires' (desejos) da arquitetura, onde os agentes formam objetivos baseados em suas crenças e percepções.\n\nIII. Incorreta. Intenções em agentes BDI não são disposições afetivas motivadas pelo fracasso. Intenções são compromissos que o agente assume para alcançar certos objetivos, baseados em suas crenças e desejos.\n\nIV. Correta. Crenças em agentes BDI são informações que o agente mantém sobre si mesmo e sobre o ambiente, formando a base para a tomada de decisões.\n\nV. Correta. Em um agente BDI, intenções representam objetivos que o agente deliberou alcançar, refletindo um compromisso com certas ações para atingir esses objetivos.\n\nPortanto, as afirmativas corretas são II, IV e V, o que corresponde à alternativa E."
  },
  {
    "edicao": 2008,
    "id": "2008-11",
    "numero": 11,
    "enunciado": "Analise as seguintes afirmativas sobre o BACK-END de um compilador.\nI. Apesar da geração de código intermediário tornar a implementação do compilador\nmais portável, já que o código intermediário pode ser traduzido para várias\narquiteturas diferentes, o código intermediário é geralmente mais difícil de ser\notimizado já que ainda é muito longe do código alvo final.\nII. O problema de gerar código ótimo é indecidível. Geralmente nos contentamos com\ntécnicas heurísticas que, na maior parte do tempo, geram \"bom\" código.\nIII. São exemplos de código intermediário as notações pré-fixa e pós-fixa que facilitam a\ngeração de código para uma máquina de pilha e o código de três endereços em que\ncada instrução faz referência a no máximo três variáveis (endereços).\nA análise permite concluir que",
    "alternativas": [
      "A) apenas a afirmativa I está correta.",
      "B) apenas a afirmativa II está correta.",
      "C) apenas as afirmativas I, II e III estão corretas.",
      "D) apenas as afirmativas I e II estão corretas.",
      "E) apenas as afirmativas II e III estão corretas."
    ],
    "area_conhecimento": "Matemática",
    "area": "Compiladores",
    "subarea": "Geração de Código e Otimização",
    "dificuldade": "Média",
    "gabarito": "E",
    "solucao": "Vamos analisar cada afirmativa:\n\nI. A afirmativa I está incorreta. Embora a geração de código intermediário realmente torne a implementação do compilador mais portável, a afirmação de que o código intermediário é geralmente mais difícil de ser otimizado por estar longe do código alvo final não é precisa. O código intermediário é projetado para ser uma representação que facilite a otimização, permitindo que otimizações independentes da máquina sejam aplicadas antes da tradução para o código alvo.\n\nII. A afirmativa II está correta. O problema de gerar código ótimo é de fato indecidível. Isso significa que não existe um algoritmo que sempre produza o código mais eficiente possível para qualquer programa. Em vez disso, os compiladores usam técnicas heurísticas para gerar código que é 'bom o suficiente' na maioria dos casos.\n\nIII. A afirmativa III está correta. As notações pré-fixa e pós-fixa são formas de representação de expressões que facilitam a geração de código para máquinas de pilha, e o código de três endereços é uma forma comum de código intermediário usada em compiladores, onde cada instrução envolve no máximo três operandos ou endereços.\n\nPortanto, apenas as afirmativas II e III estão corretas, o que corresponde à alternativa E."
  },
  {
    "edicao": 2008,
    "id": "2008-12",
    "numero": 12,
    "enunciado": "Considere as seguintes afirmativas sobre o FRONT-END de um compilador.\nI. As mensagens de erro de um compilador são geralmente geradas no FRONT-END.\nMensagens de erro de compilação não são geradas no BACK-END.\nII. A análise léxica é geralmente implementada como uma subrotina do parser. A análise\nléxica reconhece símbolos léxicos (tokens) e encontra erros como esquecer o ponto-\ne-vírgula depois de um comando em Java.\nIII. Para evitar o problema do retrocesso no parser descendente recursivo, podemos usar\num parser recursivo preditivo que usa os conjuntos FIRST e FOLLOW para decidir\nqual produção aplicar à entrada.\nA análise permite concluir que",
    "alternativas": [
      "A) apenas a afirmativa I está correta.",
      "B) apenas a afirmativa II está correta.",
      "C) apenas a afirmativa III está correta.",
      "D) apenas as afirmativas I e II estão corretas.",
      "E) apenas as afirmativas I e III estão corretas."
    ],
    "area_conhecimento": "Matemática",
    "area": "Compiladores",
    "subarea": "Análise Sintática",
    "dificuldade": "Média",
    "gabarito": "E",
    "solucao": "Vamos analisar cada uma das afirmativas: \n\nI. Esta afirmativa está correta. O FRONT-END de um compilador é responsável por analisar o código fonte e detectar erros de sintaxe e semântica, gerando mensagens de erro quando necessário. O BACK-END, por outro lado, está mais relacionado à geração de código e otimizações, não sendo responsável por mensagens de erro de compilação.\n\nII. Esta afirmativa está incorreta. A análise léxica é responsável por reconhecer tokens, mas não detecta erros como esquecer o ponto-e-vírgula após um comando em Java. Erros de sintaxe, como o esquecimento de um ponto-e-vírgula, são geralmente detectados durante a análise sintática (parsing), não na análise léxica.\n\nIII. Esta afirmativa está correta. Um parser descendente recursivo pode enfrentar problemas de retrocesso, e um parser preditivo recursivo, que utiliza os conjuntos FIRST e FOLLOW, pode ser usado para decidir qual produção aplicar, evitando assim o retrocesso.\n\nPortanto, as afirmativas corretas são I e III, o que corresponde à alternativa E."
  },
  {
    "edicao": 2008,
    "id": "2008-13",
    "numero": 13,
    "enunciado": "Observe a seguinte gramática:\nDECL IF | a\nIF if ( EXP ) DECL ELSE\nELSE else DECL |\nEXP 1 | 0\nSendo $ o símbolo que representa final de arquivo, é CORRETO afirmar que",
    "alternativas": [
      "A) FIRST(DECL) = {if, a} e FOLLOW(DECL) = {$}",
      "B) FOLLOW(DECL) = FOLLOW(IF) = FOLLOW(ELSE) = {$, else}",
      "C) FIRST(DECL) = FIRST (IF) = {if}",
      "D) FIRST(ELSE) = {else} e FOLLOW(ELSE) = {$}",
      "E) FIRST(EXP) = {0,1} e FOLLOW(EXP) = { ), $}"
    ],
    "area_conhecimento": "Matemática",
    "area": "Lógica Matemática",
    "subarea": "Lógica Proposicional e de Predicados",
    "dificuldade": "Média",
    "gabarito": "E",
    "solucao": "Para resolver essa questão, precisamos analisar a gramática fornecida e determinar os conjuntos FIRST e FOLLOW para as produções. \n\n1. **FIRST(DECL)**: A produção para DECL é 'IF' ou 'a'. Portanto, FIRST(DECL) = {if, a}.\n\n2. **FOLLOW(DECL)**: DECL pode ser seguido por ELSE ou o final de arquivo ($). Portanto, FOLLOW(DECL) = {else, $}.\n\n3. **FIRST(IF)**: A produção para IF começa com 'if', então FIRST(IF) = {if}.\n\n4. **FOLLOW(IF)**: IF é seguido por DECL, que pode ser seguido por ELSE ou $, então FOLLOW(IF) = {else, $}.\n\n5. **FIRST(ELSE)**: A produção para ELSE começa com 'else', então FIRST(ELSE) = {else}.\n\n6. **FOLLOW(ELSE)**: ELSE é seguido por DECL, que pode ser seguido por $, então FOLLOW(ELSE) = {$}.\n\n7. **FIRST(EXP)**: EXP pode ser '1' ou '0', então FIRST(EXP) = {0, 1}.\n\n8. **FOLLOW(EXP)**: EXP é seguido por ')', então FOLLOW(EXP) = {), $}.\n\nAnalisando as alternativas:\n- A) FIRST(DECL) = {if, a} é correto, mas FOLLOW(DECL) não é apenas {$}, é {else, $}.\n- B) FOLLOW(DECL) = FOLLOW(IF) = FOLLOW(ELSE) não é correto, pois FOLLOW(ELSE) = {$}.\n- C) FIRST(DECL) = FIRST(IF) não é correto, pois FIRST(DECL) = {if, a} e FIRST(IF) = {if}.\n- D) FIRST(ELSE) = {else} é correto, mas FOLLOW(ELSE) não é apenas {$}, é {else, $}.\n- E) FIRST(EXP) = {0, 1} e FOLLOW(EXP) = {), $} é correto.\n\nPortanto, a alternativa correta é E."
  },
  {
    "edicao": 2008,
    "id": "2008-14",
    "numero": 14,
    "enunciado": "Sobre a comunicação entre processos distribuídos, é CORRETO afirmar",
    "alternativas": [
      "A) que, no modo síncrono de envio de mensagem, o processo que recebe a mensagem\nterá sua execução desviada por uma interrupção de sistema operacional para tratar\numa mensagem recebida.",
      "B) que um processo tem no máximo uma porta (port) para receber as mensagens dos\nseus interlocutores.",
      "C) que multiportas são estruturas do tipo portas multicast que permitem a comunicação\nN x M entre processos.",
      "D) que, nos sockets do tipo datagrama, o endereço do socket do processo\ncorrespondente acompanha cada envio de mensagem como um parâmetro da\nprimitiva sendto().",
      "E) que, nos sockets do tipo datagrama, a primitiva sNew() é usada para aceitar a\nconexão solicitada por um processo que solicita comunicação."
    ],
    "area_conhecimento": "Matemática",
    "area": "Matemática Discreta",
    "subarea": "Teoria dos Códigos",
    "dificuldade": "Média",
    "gabarito": "D",
    "solucao": "A alternativa correta é a D. Nos sockets do tipo datagrama, que utilizam o protocolo UDP, não há uma conexão estabelecida como no TCP. Portanto, cada mensagem enviada precisa incluir o endereço do destinatário. A função sendto() é usada para enviar mensagens em sockets do tipo datagrama, e ela requer que o endereço do socket do processo correspondente seja passado como um parâmetro, o que está corretamente descrito na alternativa D. \n\nAnalisando as outras alternativas: \n- A alternativa A está incorreta porque, no modo síncrono de envio de mensagem, o processo remetente espera até que o destinatário receba a mensagem, mas isso não implica que o processo receptor terá sua execução desviada por uma interrupção do sistema operacional. \n- A alternativa B está incorreta porque um processo pode ter várias portas para receber mensagens, especialmente em sistemas que suportam múltiplas conexões simultâneas. \n- A alternativa C está incorreta porque multiportas não são especificamente estruturas para comunicação multicast N x M. \n- A alternativa E está incorreta porque a primitiva sNew() não é usada para aceitar conexões em sockets do tipo datagrama, já que datagramas não estabelecem conexões como os sockets de fluxo (TCP)."
  },
  {
    "edicao": 2008,
    "id": "2008-15",
    "numero": 15,
    "enunciado": "Dada a seguinte função escrita na linguagem de programação C:\nvoid _________(int xi, int yi, int xf, int yf, int cor)\n{\nint x, y;\nfloat a;\na = (yf yi) / (xf - xi);\nfor (x = xi; x <= xf; x++)\n{\ny = (yi + a * (x - xi));\nputpixel(x, y, cor);\n}\n}\nConsidere que a função putpixel plota um pixel de cada vez na tela em modo gráfico, na\nposição (x, y) com a cor especificada. Essa função plota na tela do computador",
    "alternativas": [
      "A) uma elipse.",
      "B) um retângulo.",
      "C) uma linha.",
      "D) um círculo.",
      "E) um triângulo."
    ],
    "area_conhecimento": "Matemática",
    "area": "Geometria Analítica",
    "subarea": "Reta no plano e no espaço",
    "dificuldade": "Fácil",
    "gabarito": "C",
    "solucao": "A função apresentada no enunciado é responsável por desenhar uma linha reta na tela. Isso é determinado pela fórmula utilizada para calcular o valor de 'y' dentro do loop. A fórmula 'y = yi + a * (x - xi)' é a equação de uma reta na forma ponto-inclinação, onde 'a' é a inclinação da reta (calculada como 'a = (yf - yi) / (xf - xi)'). O loop 'for' itera sobre os valores de 'x' de 'xi' até 'xf', calculando o valor correspondente de 'y' e chamando a função 'putpixel' para desenhar o pixel na posição (x, y) com a cor especificada. Portanto, a função plota uma linha reta entre os pontos (xi, yi) e (xf, yf)."
  },
  {
    "edicao": 2008,
    "id": "2008-16",
    "numero": 16,
    "enunciado": "Sejam duas funções f(n) e g(n) que mapeiam números inteiros positivos em números reais\npositivos.\nCom respeito às notações assintóticas de complexidade, avalie as afirmativas abaixo.\nI. Diz-se que f(n) é O(g(n)) se existe uma constante real c > 0 e existe uma constante\ninteira n 1 tal que f(n) c g(n) para todo inteiro n n .\n0 0\nII. Diz-se que f(n) é o(g(n)) se para toda constante real c > 0 existe uma constante inteira\nn 1 tal que f(n) < c g(n) para todo inteiro n n .\n0 0\nIII. Diz-se que f(n) é (g(n)) se existe uma constante real c > 0 e existe uma constante\ninteira n 1 tal que f(n) c g(n) para todo inteiro n n .\n0 0\nIV. Diz-se que f(n) é (g(n)) se para toda constante real c > 0 existe uma constante\ninteira n 1 tal que f(n) > c g(n) para todo inteiro n n .\n0\nV. Diz-se que f(n) é (g(n)) se, e somente se, f(n) é O(g(n)) e f(n) é (g(n)).\nA análise permite concluir que",
    "alternativas": [
      "A) todas as afirmativas são falsas.",
      "B) todas as afirmativas são verdadeiras.",
      "C) apenas as afirmativas I e III são verdadeiras.",
      "D) apenas as afirmativas II e IV são verdadeiras.",
      "E) apenas a afirmativa V é falsa."
    ],
    "area_conhecimento": "Matemática",
    "area": "Matemática Discreta",
    "subarea": "Funções",
    "dificuldade": "Média",
    "gabarito": "E",
    "solucao": "Vamos analisar cada afirmativa:\n\nI. A definição de O(g(n)) está correta. Diz-se que f(n) é O(g(n)) se existem constantes c > 0 e n_0 tal que f(n) <= c * g(n) para todo n >= n_0.\n\nII. A definição de o(g(n)) está correta. Diz-se que f(n) é o(g(n)) se para toda constante c > 0, existe n_0 tal que f(n) < c * g(n) para todo n >= n_0.\n\nIII. A definição de Ω(g(n)) está incorreta. A definição correta é que f(n) é Ω(g(n)) se existem constantes c > 0 e n_0 tal que f(n) >= c * g(n) para todo n >= n_0.\n\nIV. A definição de ω(g(n)) está correta. Diz-se que f(n) é ω(g(n)) se para toda constante c > 0, existe n_0 tal que f(n) > c * g(n) para todo n >= n_0.\n\nV. A definição de Θ(g(n)) está correta. Diz-se que f(n) é Θ(g(n)) se, e somente se, f(n) é O(g(n)) e f(n) é Ω(g(n)).\n\nPortanto, a única afirmativa falsa é a III, o que torna a alternativa E a correta."
  },
  {
    "edicao": 2008,
    "id": "2008-17",
    "numero": 17,
    "enunciado": "Analise as seguintes afirmativas.\nI. Em um problema de decisão, o objetivo é decidir a resposta sim ou não a uma\nquestão. Em um problema de localização, procura-se localizar uma certa estrutura\nque satisfaça um conjunto de propriedades dadas. Se as propriedades envolverem\ncritérios de otimização, então o problema é dito de otimização.\nII. A teoria da complexidade restringe-se a problemas de decisão, já que o estudo de\nproblemas NP-completos é aplicado somente para esse tipo de problema.\nIII. Os problemas NP-Completos são considerados como os problemas mais difíceis em\nNP. Se qualquer problema NP-Completo pode ser resolvido em tempo polinomial,\nentão todos os problemas em NP podem ser resolvidos da mesma forma.\nA análise permite concluir que",
    "alternativas": [
      "A) apenas a afirmativa I está correta.",
      "B) apenas a afirmativa II está correta.",
      "C) apenas as afirmativas I e II estão corretas.",
      "D) apenas as afirmativas I e III estão corretas.",
      "E) todas as afirmativas estão corretas."
    ],
    "area_conhecimento": "Matemática",
    "area": "Lógica Matemática",
    "subarea": "Decidibilidade",
    "dificuldade": "Média",
    "gabarito": "D",
    "solucao": "Vamos analisar cada uma das afirmativas: \n\nI. Esta afirmativa está correta. Em um problema de decisão, o objetivo é determinar uma resposta 'sim' ou 'não'. Problemas de localização envolvem encontrar uma estrutura que satisfaça certas propriedades, e se essas propriedades incluem critérios de otimização, o problema é classificado como de otimização. \n\nII. Esta afirmativa está incorreta. Embora a teoria da complexidade frequentemente se concentre em problemas de decisão, ela não se restringe a eles. Problemas de otimização e problemas de busca também são estudados dentro da teoria da complexidade. Além disso, a classe NP-completa é uma subclasse de problemas de decisão, mas a teoria da complexidade abrange mais do que apenas esses problemas. \n\nIII. Esta afirmativa está correta. Os problemas NP-completos são considerados os mais difíceis dentro da classe NP. Se um problema NP-completo puder ser resolvido em tempo polinomial, então todos os problemas em NP também podem ser resolvidos em tempo polinomial, devido à definição de NP-completude e à existência de reduções polinomiais entre problemas em NP.\n\nPortanto, a alternativa correta é D, pois apenas as afirmativas I e III estão corretas."
  },
  {
    "edicao": 2008,
    "id": "2008-18",
    "numero": 18,
    "enunciado": "Analise as afirmativas abaixo.\nI. A programação dinâmica é um método ascendente que aborda um dado problema\nsubdividindo-o em problemas mínimos, soluciona esses subproblemas, guarda as\nsoluções parciais, combina os subproblemas e sub-resultados para obter e resolver\nos problemas maiores, até recompor e resolver o problema original.\nII. A divisão e conquista é um método recursivo e, por isso, descendente que decompõe\nsucessivamente um problema em subproblemas independentes triviais, resolvendo-os\ne combinando as soluções em uma solução para o problema original.\nIII. Um algoritmo guloso sempre faz escolhas que parecem ser as melhores no momento,\nou seja, escolhas ótimas locais acreditando que estas escolhas o levem a uma\nsolução ótima global. Por essa estratégia, nem sempre asseguram-se soluções\nótimas, mas, para muitos problemas, as soluções são ótimas. Os problemas ideais\npara essa estratégia não devem ter a propriedade de subestrutura ótima.\nA análise permite concluir que",
    "alternativas": [
      "A) todas as afirmativas são verdadeiras.",
      "B) todas as afirmativas são falsas.",
      "C) apenas as afirmativas I e II são verdadeiras.",
      "D) apenas as afirmativas II e III são verdadeiras.",
      "E) apenas a afirmativa III é verdadeira."
    ],
    "area_conhecimento": "Matemática",
    "area": "Matemática Discreta",
    "subarea": "Indução e Recursão",
    "dificuldade": "Média",
    "gabarito": "C",
    "solucao": "Vamos analisar cada afirmativa: \n\nI. A programação dinâmica é de fato um método ascendente que resolve problemas dividindo-os em subproblemas menores, resolve esses subproblemas, armazena as soluções parciais e as combina para resolver o problema maior. Portanto, a afirmativa I é verdadeira.\n\nII. A divisão e conquista é um método recursivo que decompõe um problema em subproblemas independentes, resolve-os e combina as soluções para resolver o problema original. Isso é característico da abordagem descendente. Portanto, a afirmativa II é verdadeira.\n\nIII. Um algoritmo guloso faz escolhas ótimas locais na esperança de encontrar uma solução ótima global. No entanto, a afirmativa III contém um erro ao afirmar que os problemas ideais para essa estratégia não devem ter a propriedade de subestrutura ótima. Na verdade, para que um algoritmo guloso encontre a solução ótima global, o problema deve ter a propriedade de subestrutura ótima. Portanto, a afirmativa III é falsa.\n\nCom base na análise, apenas as afirmativas I e II são verdadeiras, tornando a alternativa C a correta."
  },
  {
    "edicao": 2008,
    "id": "2008-19",
    "numero": 19,
    "enunciado": "Com respeito ao projeto de linguagens de programação, assinale a afirmativa CORRETA.",
    "alternativas": [
      "A) A forma dos programas construídos com uma determinada linguagem, definida por\nregras formais que expressam restrições que definem como são os programas bem\nformados, é um problema de caráter sintático.",
      "B) O significado de programas bem construídos com uma determinada linguagem, a qual\ndefine o efeito da execução desses programas, é um problema de caráter semântico.",
      "C) Sistemas de tipos apresentam três propósitos principais em uma linguagem de\nprogramação: a segurança, a abstração e a modularidade.",
      "D) A segurança de uma linguagem de programação está diretamente relacionada com a\ncapacidade de identificação estática e/ou dinâmica de programas mal formados que\nnão podem ser identificados somente por meio de mecanismos de análise sintática,\ncomo gramáticas livres do contexto.",
      "E) Todas as alternativas anteriores estão corretas."
    ],
    "area_conhecimento": "Matemática",
    "area": "Lógica Matemática",
    "subarea": "Lógica Proposicional e de Predicados",
    "dificuldade": "Fácil",
    "gabarito": "E",
    "solucao": "A questão aborda conceitos fundamentais do projeto de linguagens de programação, especificamente sobre sintaxe, semântica, sistemas de tipos e segurança. Vamos analisar cada alternativa: \n\nA) A afirmação está correta. A forma dos programas, definida por regras formais, é um problema de caráter sintático, pois a sintaxe de uma linguagem de programação refere-se à estrutura ou forma dos programas.\n\nB) A afirmação está correta. O significado dos programas, que define o efeito da execução, é um problema de caráter semântico, pois a semântica de uma linguagem de programação refere-se ao significado dos seus programas.\n\nC) A afirmação está correta. Sistemas de tipos têm como propósitos principais a segurança, a abstração e a modularidade, pois ajudam a prevenir erros, permitem a definição de interfaces abstratas e facilitam a organização do código em módulos.\n\nD) A afirmação está correta. A segurança de uma linguagem de programação está relacionada à capacidade de identificar programas mal formados, que não podem ser detectados apenas por análise sintática, mas também por análise semântica e de tipos.\n\nE) Todas as alternativas anteriores estão corretas, portanto, esta é a alternativa correta.\n\nA questão exige conhecimento básico sobre conceitos fundamentais de linguagens de programação, portanto, é classificada como de dificuldade 'Fácil'."
  },
  {
    "edicao": 2008,
    "id": "2008-20",
    "numero": 20,
    "enunciado": "Analise as seguintes afirmativas.\nI. Ocultar dados dentro das classes e torná-los disponíveis apenas por meio de métodos\né uma técnica muito usada em programas orientados a objetos e é chamada de\nsobrescrita de atributos.\nII. Uma subclasse pode implementar novamente métodos que foram herdados de uma\nsuperclasse. Chamamos isso de sobrecarga de métodos.\nIII. Em Java não existe Herança múltipla como em C++. A única maneira se se obter algo\nparecido é via interfaces.\nA análise permite concluir que",
    "alternativas": [
      "A) apenas a afirmativa I está incorreta.",
      "B) apenas a afirmativa II está incorreta.",
      "C) apenas a afirmativa III está incorreta.",
      "D) apenas as afirmativas I e III estão incorretas.",
      "E) apenas as afirmativas I e II estão incorretas"
    ],
    "area_conhecimento": "Matemática",
    "area": "Programação",
    "subarea": "Programação Orientada a Objetos",
    "dificuldade": "Fácil",
    "gabarito": "E",
    "solucao": "Vamos analisar cada uma das afirmativas:\n\nI. A afirmativa I está incorreta. A técnica de ocultar dados dentro das classes e torná-los disponíveis apenas por meio de métodos é chamada de encapsulamento, não de sobrescrita de atributos. A sobrescrita de atributos não é um conceito comum em programação orientada a objetos; o que existe é a sobrescrita de métodos.\n\nII. A afirmativa II está incorreta. Quando uma subclasse implementa novamente métodos que foram herdados de uma superclasse, isso é chamado de sobrescrita de métodos, não sobrecarga. Sobrecarga de métodos refere-se a ter vários métodos com o mesmo nome, mas com diferentes assinaturas (número ou tipo de parâmetros) na mesma classe.\n\nIII. A afirmativa III está correta. Em Java, não existe herança múltipla de classes como em C++. A única maneira de obter um comportamento semelhante é através do uso de interfaces, que permitem que uma classe implemente múltiplas interfaces.\n\nPortanto, as afirmativas I e II estão incorretas, levando à alternativa correta: E."
  },
  {
    "edicao": 2008,
    "id": "2008-21",
    "numero": 21,
    "enunciado": "Analise as seguintes afirmativas.\nI. Encapsulamento permite que uma classe defina métodos com o mesmo nome de\nmétodos presentes em sua superclasse desde que esses métodos tenham\nargumentos um pouco diferentes.\nII. Em Java, uma instância de uma classe C que implementa uma interface I é membro\ntanto do tipo definido pela interface I quanto do tipo definido pela classe C.\nIII. Em Java, classes abstratas não precisam ser completamente abstratas, ao contrário\ndas interfaces, classes abstratas podem ter métodos implementados que serão\nherdados por suas subclasses.\nA análise permite concluir que",
    "alternativas": [
      "A) apenas as afirmativas II e III estão corretas.",
      "B) apenas as afirmativas I e II estão corretas.",
      "C) apenas as afirmativas I e III estão corretas.",
      "D) apenas a afirmativa II está correta.",
      "E) apenas a afirmativa I está correta."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "Linguagens de Programação",
    "subarea": "Conceitos",
    "dificuldade": "Fácil",
    "gabarito": "A",
    "solucao": "Vamos analisar cada uma das afirmativas: \n\nI. A afirmativa está incorreta. O encapsulamento em Java não está relacionado com a definição de métodos com o mesmo nome e argumentos diferentes. O conceito descrito na afirmativa está mais relacionado ao polimorfismo (sobrecarga de métodos), e não ao encapsulamento.\n\nII. A afirmativa está correta. Em Java, quando uma classe C implementa uma interface I, qualquer instância de C é considerada tanto do tipo C quanto do tipo I. Isso é porque a instância de C deve implementar todos os métodos da interface I, tornando-a uma instância válida de I.\n\nIII. A afirmativa está correta. Em Java, classes abstratas podem conter métodos implementados, além de métodos abstratos. As subclasses podem herdar esses métodos implementados, o que difere das interfaces, que até o Java 7 não podiam ter métodos implementados (a partir do Java 8, interfaces podem ter métodos default, mas isso não invalida a afirmativa).\n\nPortanto, as afirmativas II e III estão corretas, tornando a alternativa A a correta."
  },
  {
    "edicao": 2008,
    "id": "2008-22",
    "numero": 22,
    "enunciado": "Os fragmentos de programas abaixo, enumerados 1, 2 e 3, são implementações para o\nproblema de ordenação usando o algoritmo quicksort.\nPrograma 1:\nquicksort([], []).\nquicksort([Head | Tail], Sorted) :-\npartition(Head, Tail, Left, Right), quicksort(Left, SortedL),\nquicksort(Right, SortedR),\nappend(SortedL, [Head | SortedR], Sorted).\npartition(Pivot, [], [], []).\npartition(Pivot, [Head | Tail], [Head | Left], Right) :-\nHead =< Pivot, partition(Pivot, Tail, Left, Right).\npartition(Pivot, [Head | Tail], Left, [Head | Right]) :-\nHead > Pivot, partition(Pivot, Tail, Left, Right).\nappend([], List, List).\nappend([Head | List1], List2, [Head | List3]) :-\nappend(List1, List2, List3).\nPrograma 2:\nquicksort [] = []\nquicksort (head:tail) = let pivot = head\nleft = [x|x <- tail,x < pivot]\nright = [x|x <- tail,x >= pivot]\nin quicksort left ++ [pivot] ++ quicksort right\nPrograma 3:\nvoid quickSort( int a[], int l, int r) {\nint j;\nif( l < r ) {\nj = partition( a, l, r);\nquickSort( a, l, j-1);\nquickSort( a, j+1, r);\n}\n}\nint partition( int a[], int l, int r) {\nint pivot, i, j, t;\npivot = a[l]; i = l; j = r+1;\nwhile(i<j) {\ndo ++i; while( a[i] <= pivot && i <= r );\ndo --j; while( a[j] > pivot );\nif( i < j ) {\nt = a[i]; a[i] = a[j]; a[j] = t;\n}\n}\nt = a[l]; a[l] = a[j]; a[j] = t;\nreturn j;\n}",
    "alternativas": [
      "",
      "",
      "",
      "",
      ""
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "Algoritmos e Estrutura de Dados",
    "subarea": "Algoritmos para Pesquisa e Ordenação",
    "dificuldade": "Média",
    "gabarito": "A",
    "solucao": "A questão apresenta três implementações diferentes do algoritmo de ordenação quicksort, cada uma em uma linguagem de programação distinta: Prolog, Haskell e C. O objetivo é identificar qual das alternativas corresponde corretamente à descrição ou comportamento dos programas apresentados. A alternativa correta é a 'A', que corresponde a uma descrição correta do comportamento dos programas. A solução envolve entender que todos os três programas implementam o algoritmo quicksort, que é um algoritmo de ordenação eficiente baseado na técnica de 'dividir e conquistar'. O programa 1 em Prolog utiliza recursão e listas para dividir e ordenar, o programa 2 em Haskell faz uso de compreensão de listas e concatenação, enquanto o programa 3 em C utiliza índices e troca de elementos para ordenar o array. Todos seguem a lógica básica do quicksort: escolher um pivô, particionar a lista ou array em elementos menores e maiores que o pivô, e então aplicar recursivamente o quicksort nas sublistas ou subarrays."
  },
  {
    "edicao": 2008,
    "id": "2008-23",
    "numero": 23,
    "enunciado": "Analise as seguintes afirmativas.\nI. A função map presente em linguagens funcionais como Haskell e OCaml é um bom\nexemplo de função de alta-ordem com tipo polimórfico.\nII. Prolog é uma linguagem de programação baseada em lógica de predicados de\nprimeira ordem.\nIII. Em Haskell todas as funções recebem apenas um argumento. Uma função que\nrecebe dois inteiros e devolve um float como resposta na verdade é uma função que\nrecebe apenas um inteiro como argumento e devolve como resposta uma função de\ninteiro para float.\nA análise permite concluir que",
    "alternativas": [
      "A) apenas as afirmativas II e III estão corretas.",
      "B) apenas as afirmativas I e III estão corretas.",
      "C) apenas as afirmativas I e II estão corretas.",
      "D) apenas a afirmativa II está correta.",
      "E) apenas as afirmativas I, II e III estão corretas."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "Linguagens de Programação",
    "subarea": "Paradigmas de Linguagens de Programação",
    "dificuldade": "Média",
    "gabarito": "E",
    "solucao": "Vamos analisar cada uma das afirmativas: \n\nI. A função map em linguagens funcionais como Haskell e OCaml é um exemplo clássico de função de alta-ordem com tipo polimórfico. Isso porque a função map aplica uma função a cada elemento de uma lista, e essa função pode ser de qualquer tipo, desde que seja compatível com os elementos da lista. Portanto, a afirmativa I está correta.\n\nII. Prolog é uma linguagem de programação baseada em lógica de predicados de primeira ordem. Prolog utiliza a lógica de predicados para expressar relações e regras, o que é a base de sua operação. Assim, a afirmativa II está correta.\n\nIII. Em Haskell, todas as funções são unárias, ou seja, recebem apenas um argumento. Quando parece que uma função recebe múltiplos argumentos, na verdade, ela está recebendo um argumento e retornando uma nova função que recebe o próximo argumento. Isso é conhecido como 'currying'. Portanto, a afirmativa III está correta.\n\nComo todas as afirmativas estão corretas, a alternativa correta é a E."
  },
  {
    "edicao": 2008,
    "id": "2008-24",
    "numero": 24,
    "enunciado": "Denomina-se complemento de um grafo G(V,E) o grafo H que tem o conjunto de vértices\nigual ao de G e tal que, para todo par de vértices distintos v,w em V, temos que a aresta\n(v,w) é aresta de G se e somente se (v,w) não é aresta de H.\nA esse respeito, assinale a afirmativa CORRETA.",
    "alternativas": [
      "A) G e H são grafos isomorfos.",
      "B) Se o grafo G é conexo, então H é conexo.",
      "C) Se o grafo G não é conexo, então H é conexo.",
      "D) Se o grafo G não é conexo, então H não é conexo.",
      "E) Os grafos G e H têm o mesmo número de componentes conexas."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "Teoria dos Grafos",
    "subarea": "Conectividade",
    "dificuldade": "Média",
    "gabarito": "C",
    "solucao": "Para entender a relação entre a conectividade de um grafo G e seu complemento H, devemos considerar as definições de grafo conexo e complemento de grafo. Um grafo G é conexo se existe um caminho entre qualquer par de vértices. O complemento de um grafo G, denotado por H, é construído mantendo os mesmos vértices de G, mas invertendo a presença de arestas: uma aresta existe em H se e somente se ela não existe em G. Se G não é conexo, isso significa que existem pelo menos dois vértices em G que não estão conectados por um caminho. No complemento H, esses vértices estarão conectados diretamente por uma aresta, já que a aresta não existe em G. Portanto, é possível que H seja conexo mesmo que G não seja, pois o complemento pode 'fechar' as lacunas de conectividade presentes em G. Assim, a afirmação correta é que se G não é conexo, então H é conexo."
  },
  {
    "edicao": 2008,
    "id": "2008-25",
    "numero": 25,
    "enunciado": "Um grafo G(V,E) é uma árvore se G é conexo e acíclico.\nAssinale a definição que NÃO pode ser usada para definir árvores.",
    "alternativas": [
      "A) G é conexo e o número de arestas é mínimo.",
      "B) G é conexo e o número de vértices excede o número de arestas por uma unidade.",
      "C) G é acíclico e o número de vértices excede o número de arestas por uma unidade.",
      "D) G é acíclico e, para todo par de vértices v, w, que não são adjacentes em G, a adição\nda aresta (v,w) produz um grafo contendo exatamente um ciclo.",
      "E) G é acíclico, e o número de arestas é mínimo."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "Teoria dos Grafos",
    "subarea": "Árvore Geradora",
    "dificuldade": "Média",
    "gabarito": "E",
    "solucao": "Para determinar qual definição não pode ser usada para definir árvores, precisamos entender as propriedades fundamentais de uma árvore em teoria dos grafos. Uma árvore é um grafo que é conexo e acíclico. Vamos analisar cada alternativa:\n\nA) G é conexo e o número de arestas é mínimo. - Esta é uma definição válida, pois uma árvore é o grafo conexo com o menor número de arestas possível.\n\nB) G é conexo e o número de vértices excede o número de arestas por uma unidade. - Esta é uma definição válida, pois em uma árvore com n vértices, há exatamente n-1 arestas.\n\nC) G é acíclico e o número de vértices excede o número de arestas por uma unidade. - Esta é uma definição válida, pois uma árvore é acíclica e tem n vértices e n-1 arestas.\n\nD) G é acíclico e, para todo par de vértices v, w, que não são adjacentes em G, a adição da aresta (v,w) produz um grafo contendo exatamente um ciclo. - Esta é uma definição válida, pois adicionar uma aresta entre dois vértices não adjacentes em uma árvore cria exatamente um ciclo.\n\nE) G é acíclico, e o número de arestas é mínimo. - Esta definição não é válida para definir árvores, pois um grafo acíclico com o número mínimo de arestas pode ser um grafo desconexo (como um conjunto de vértices sem arestas), o que não satisfaz a condição de conectividade de uma árvore.\n\nPortanto, a alternativa E é a que não pode ser usada para definir árvores."
  },
  {
    "edicao": 2008,
    "id": "2008-26",
    "numero": 26,
    "enunciado": "Em um grafo G(V,E), o grau de um vértice é o número de vértices adjacentes a v.\nA esse respeito, assinale a afirmativa CORRETA.",
    "alternativas": [
      "A) Num grafo, o número de vértices com grau ímpar é sempre par.",
      "B) Num grafo, o número de vértices com grau par é sempre ímpar.",
      "C) Num grafo, sempre existe algum vértice com grau par.",
      "D) Num grafo, sempre existe algum vértice com grau ímpar.",
      "E) Num grafo, o número de vértices com grau ímpar é sempre igual ao número de\nvértices com grau par."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "Teoria dos Grafos",
    "subarea": "Algoritmos em grafos e propriedades invariantes",
    "dificuldade": "Média",
    "gabarito": "A",
    "solucao": "A afirmação correta é 'Num grafo, o número de vértices com grau ímpar é sempre par.' Isso é uma propriedade clássica dos grafos não direcionados. A soma dos graus de todos os vértices em um grafo é igual ao dobro do número de arestas, pois cada aresta contribui com um grau para dois vértices. Portanto, a soma dos graus é sempre par. Se o número de vértices com grau ímpar fosse ímpar, a soma dos graus seria ímpar, o que é uma contradição. Assim, o número de vértices com grau ímpar deve ser par."
  },
  {
    "edicao": 2008,
    "id": "2008-27",
    "numero": 27,
    "enunciado": "Considere os grafos I, II, III, IV e V, mostrados abaixo:\nSão grafos isomorfos",
    "alternativas": [
      "A) todos acima apresentados.",
      "B) apenas I e III.",
      "C) apenas II e V.",
      "D) apenas III e IV.",
      "E) apenas I, II e III."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "Teoria dos Grafos",
    "subarea": "Grafos orientados e não-orientados",
    "dificuldade": "Média",
    "gabarito": "B",
    "solucao": "Para determinar se dois grafos são isomorfos, é necessário verificar se existe uma correspondência bijetiva entre os conjuntos de vértices dos dois grafos que preserva as arestas. Isso significa que, se dois vértices estão conectados por uma aresta em um grafo, seus correspondentes devem estar conectados por uma aresta no outro grafo. Para resolver a questão, é necessário analisar os grafos I, II, III, IV e V e verificar quais deles têm a mesma estrutura. Ao analisar os grafos, percebemos que os grafos I e III possuem a mesma quantidade de vértices e arestas e a mesma estrutura de conexão entre os vértices, o que os torna isomorfos. Portanto, a alternativa correta é 'B) apenas I e III.'."
  },
  {
    "edicao": 2008,
    "id": "2008-28",
    "numero": 28,
    "enunciado": "Seja G (V , E ) um grafo tal que | V | n e | E | m .\nAnalise as seguintes sentenças:\nI. Se G é acíclico com no máximo n 1 arestas, então G é uma árvore.\nII. Se G é um ciclo, então G tem n árvores geradoras distintas.\nIII. Se G é conexo com no máximo n 1 arestas, então G é uma árvore.\nIV. Se G é conexo e tem um ciclo, então para toda árvore geradora T de G ,\nE (G ) E (T )\nA análise permite concluir que",
    "alternativas": [
      "A) apenas os itens I e III são verdadeiros.",
      "B) apenas os Itens II e III são verdadeiros.",
      "C) apenas o item I é falso.",
      "D) todos os itens são verdadeiros.",
      "E) apenas os itens II e IV são verdadeiros."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "Teoria dos Grafos",
    "subarea": "Árvore Geradora",
    "dificuldade": "Média",
    "gabarito": "A",
    "solucao": "Vamos analisar cada uma das sentenças: \n\nI. Se G é acíclico com no máximo n - 1 arestas, então G é uma árvore. \n- Uma árvore é um grafo conexo e acíclico com exatamente n - 1 arestas. Se G é acíclico e tem no máximo n - 1 arestas, pode ser uma floresta (conjunto de árvores), mas não necessariamente uma única árvore, a menos que seja conexo. Portanto, a sentença I é falsa.\n\nII. Se G é um ciclo, então G tem n árvores geradoras distintas. \n- Um ciclo com n vértices tem exatamente n arestas. Removendo uma aresta, obtemos uma árvore geradora. Como há n arestas, há n maneiras de remover uma aresta, resultando em n árvores geradoras distintas. Portanto, a sentença II é verdadeira.\n\nIII. Se G é conexo com no máximo n - 1 arestas, então G é uma árvore. \n- Se G é conexo e tem exatamente n - 1 arestas, então G é uma árvore por definição. Portanto, a sentença III é verdadeira.\n\nIV. Se G é conexo e tem um ciclo, então para toda árvore geradora T de G, E(G) - E(T) \n- Se G tem um ciclo, então tem mais de n - 1 arestas. Uma árvore geradora T de G terá exatamente n - 1 arestas. Portanto, E(G) > E(T). A sentença IV é verdadeira.\n\nCom base na análise, apenas as sentenças I e III são verdadeiras. Portanto, a alternativa correta é A."
  },
  {
    "edicao": 2008,
    "id": "2008-29",
    "numero": 29,
    "enunciado": "Assinale a afirmativa INCORRETA.",
    "alternativas": [
      "A) Existe uma máquina de Turing U que simula qualquer outra máquina de Turing M\nsobre qualquer entrada para M.",
      "B) A Tese de Church afirma que o conceito informal de procedimento efetivo é capturado\npelo conceito formal de Máquina de Turing.",
      "C) Uma linguagem é recursivamente enumerável se, e somente se, for aceita por alguma\nMáquina de Turing.",
      "D) Existe uma máquina de Turing T que, dada qualquer máquina de Turing M e qualquer\nentrada w para M, T determina, em um número finito de passos, se M pára para a\nentrada w ou não.",
      "E) Toda linguagem recursiva é recursivamente enumerável, mas o inverso nem sempre\né verdadeiro."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "Linguagens Formais, Autômatos e Computabilidade",
    "subarea": "Problemas Indecidíveis",
    "dificuldade": "Difícil",
    "gabarito": "D",
    "solucao": "A alternativa D afirma que existe uma máquina de Turing T que, dada qualquer máquina de Turing M e qualquer entrada w para M, T determina, em um número finito de passos, se M pára para a entrada w ou não. Esta afirmação é incorreta porque descreve a solução do Problema da Parada, que é um problema indecidível. O Problema da Parada afirma que não há um algoritmo geral que possa decidir se uma máquina de Turing irá parar ou continuar executando para uma dada entrada. Portanto, não existe tal máquina de Turing T que possa resolver o Problema da Parada para todas as máquinas de Turing e entradas."
  },
  {
    "edicao": 2008,
    "id": "2008-30",
    "numero": 30,
    "enunciado": "Analise as seguintes afirmativas.\nI. Todo autômato finito não-determinístico pode ser simulado por um autômato finito\ndeterminístico.\nII. Todo autômato finito determinístico pode ser simulado por um autômato finito não-\ndeterminístico.\nIII. Todo autômato finito não-determinístico pode ser simulado por um autômato de pilha\ndeterminístico.\nIV. Todo autômato de pilha determinístico pode ser simulado por um autômato finito não-\ndeterminístico.\nV. Todo autômato finito não-determinístico pode ser simulado por uma máquina de\nTuring determinística.\nA análise permite concluir que estão CORRETAS",
    "alternativas": [
      "A) apenas as afirmativas I, II, III e IV.",
      "B) apenas as afirmativas II, III e V.",
      "C) apenas as afirmativas I, II, III e V.",
      "D) apenas as afirmativas II e IV.",
      "E) apenas as afirmatias I, II e IV."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "Linguagens Formais, Autômatos e Computabilidade",
    "subarea": "Autômatos de Estados Finitos Determinístico e não Determinístico",
    "dificuldade": "Média",
    "gabarito": "C",
    "solucao": "Vamos analisar cada afirmativa: \n\nI. Todo autômato finito não-determinístico (AFN) pode ser simulado por um autômato finito determinístico (AFD). Isso é verdade devido ao algoritmo de construção do fecho de estados, conhecido como 'construção do conjunto de estados' ou 'construção de subset', que transforma um AFN em um AFD equivalente.\n\nII. Todo autômato finito determinístico (AFD) pode ser simulado por um autômato finito não-determinístico (AFN). Isso é trivialmente verdade, pois um AFD é um caso especial de AFN, onde não há transições não-determinísticas.\n\nIII. Todo autômato finito não-determinístico (AFN) pode ser simulado por um autômato de pilha determinístico (APD). Isso é verdade porque os autômatos de pilha são mais poderosos que os autômatos finitos, pois têm memória adicional (a pilha) que permite simular o comportamento de qualquer AFN.\n\nIV. Todo autômato de pilha determinístico (APD) pode ser simulado por um autômato finito não-determinístico (AFN). Isso é falso, pois os autômatos de pilha podem reconhecer linguagens livres de contexto, que são mais complexas do que as linguagens regulares reconhecidas por autômatos finitos.\n\nV. Todo autômato finito não-determinístico (AFN) pode ser simulado por uma máquina de Turing determinística. Isso é verdade, pois as máquinas de Turing são mais poderosas que autômatos finitos e podem simular qualquer computação que um AFN possa realizar.\n\nPortanto, as afirmativas corretas são I, II, III e V, o que corresponde à alternativa C."
  },
  {
    "edicao": 2008,
    "id": "2008-31",
    "numero": 31,
    "enunciado": "Um dos itens do problema denominado \"Problema do Busy Beaver\" consiste em\ndeterminar qual o tamanho da maior computação finita que pode ser realizada por\nmáquinas de Turing com determinada quantidade k de estados, quando as máquinas\ncomeçam com a fita em branco (fita vazia).\nAnalise as seguintes afirmativas.\nI. Todas as computações de qualquer máquina de Turing de dois estados ( k 2 ) são\ninfinitas, quando a máquina começa com a fita vazia.\nII. Todas as computações de qualquer máquina de Turing de dois estados ( k 2 ) são\nfinitas, quando a máquina começa com a fita vazia.\nIII. Para qualquer número k 2 , máquinas de Turing com k estados podem realizar\ncomputações de qualquer tamanho finito, quando a fita começa vazia, dependendo\napenas do algoritmo que as máquinas estão computando.\nA análise permite concluir que",
    "alternativas": [
      "A) nenhuma das afirmativas é verdadeira.",
      "B) todas as afirmativas são verdadeiras.",
      "C) somente I e II são verdadeiras.",
      "D) somente III é verdadeira.",
      "E) somente II e III são verdadeiras."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "Linguagens Formais, Autômatos e Computabilidade",
    "subarea": "Máquinas de Turing",
    "dificuldade": "Média",
    "gabarito": "D",
    "solucao": "Para resolver a questão, precisamos analisar cada uma das afirmativas em relação ao problema do Busy Beaver e ao comportamento de máquinas de Turing. \n\nAfirmativa I: 'Todas as computações de qualquer máquina de Turing de dois estados (k = 2) são infinitas, quando a máquina começa com a fita vazia.' Esta afirmativa é falsa. Existem máquinas de Turing com dois estados que podem parar após um número finito de passos, dependendo da sua programação. Portanto, nem todas as computações são infinitas.\n\nAfirmativa II: 'Todas as computações de qualquer máquina de Turing de dois estados (k = 2) são finitas, quando a máquina começa com a fita vazia.' Esta afirmativa também é falsa. Algumas máquinas de Turing com dois estados podem entrar em loops infinitos, dependendo de sua programação, mesmo começando com a fita vazia.\n\nAfirmativa III: 'Para qualquer número k ≥ 2, máquinas de Turing com k estados podem realizar computações de qualquer tamanho finito, quando a fita começa vazia, dependendo apenas do algoritmo que as máquinas estão computando.' Esta afirmativa é verdadeira. O problema do Busy Beaver mostra que é possível programar uma máquina de Turing com um número finito de estados para realizar computações de tamanho arbitrariamente grande, dependendo do algoritmo implementado.\n\nPortanto, apenas a afirmativa III é verdadeira, levando à alternativa D como a correta."
  },
  {
    "edicao": 2008,
    "id": "2008-32",
    "numero": 32,
    "enunciado": "Analise as seguintes afirmativas.\nI. Uma arquitetura multithreading executa simultaneamente o código de diversos fluxos\nde instruções (threads).\nII. Em uma arquitetura VLIW, o controle da execução das várias instruções por ciclo de\nmáquina é feito pelo compilador.\nIII. Uma arquitetura superescalar depende de uma boa taxa de acerto do mecanismo de\npredição de desvio para obter um bom desempenho.\nIV. Os processadores vetoriais são um tipo de arquitetura SIMD.\nV. Um processador dual-core é mais eficiente em termos de consumo de energia do que\ndois processadores single-core de mesma tecnologia.\nA partir da análise, pode-se concluir que",
    "alternativas": [
      "A) apenas a afirmativa IV está correta.",
      "B) apenas as afirmativas III e IV estão corretas.",
      "C) apenas as afirmativas I, IV e V estão corretas.",
      "D) apenas as afirmativas I, III e V estão corretas.",
      "E) todas as afirmativas estão corretas."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "Arquitetura e Organização de Computadores",
    "subarea": "Processadores Superescalares e Superpipeline",
    "dificuldade": "Média",
    "gabarito": "E",
    "solucao": "Vamos analisar cada afirmativa:\n\nI. Uma arquitetura multithreading executa simultaneamente o código de diversos fluxos de instruções (threads). - Correto. Arquiteturas multithreading são projetadas para permitir a execução simultânea de múltiplas threads, melhorando a utilização do processador.\n\nII. Em uma arquitetura VLIW, o controle da execução das várias instruções por ciclo de máquina é feito pelo compilador. - Correto. Em arquiteturas VLIW (Very Long Instruction Word), o compilador é responsável por organizar as instruções de forma que possam ser executadas simultaneamente, já que o hardware não realiza essa reordenação.\n\nIII. Uma arquitetura superescalar depende de uma boa taxa de acerto do mecanismo de predição de desvio para obter um bom desempenho. - Correto. Arquiteturas superescalares executam múltiplas instruções por ciclo de clock, e uma boa predição de desvios é crucial para manter o pipeline cheio e evitar bolhas.\n\nIV. Os processadores vetoriais são um tipo de arquitetura SIMD. - Correto. SIMD (Single Instruction, Multiple Data) é uma técnica onde uma única instrução é aplicada a múltiplos dados simultaneamente, o que é característico de processadores vetoriais.\n\nV. Um processador dual-core é mais eficiente em termos de consumo de energia do que dois processadores single-core de mesma tecnologia. - Correto. Em geral, um processador dual-core compartilha recursos e é mais eficiente em termos de energia do que dois processadores single-core separados, devido à redução de componentes duplicados e melhor gerenciamento de energia.\n\nPortanto, todas as afirmativas estão corretas, o que leva à alternativa E."
  },
  {
    "edicao": 2008,
    "id": "2008-33",
    "numero": 33,
    "enunciado": "O uso de memória caches é muito importante para o desempenho dos processadores\natuais.\nAnalise as afirmativas abaixo relativas ao uso de memórias caches.\nI. Em uma memória cache com mapeamento direto um bloco de memória pode ser\ncolocado em qualquer posição (entrada) dessa memória cache.\nII. Na política de escrita write-back o bloco modificado é atualizado na memória principal\napenas quando for substituído.\nIII. O uso de associatividade nas memórias cache serve para reduzir o número de falhas\npor conflito.\nA análise permite concluir que",
    "alternativas": [
      "A) as três afirmativas são falsas.",
      "B) as três afirmativas são verdadeiras.",
      "C) apenas a afirmativa I é verdadeira.",
      "D) apenas as afirmativas II e III são verdadeiras.",
      "E) apenas a afirmativa III é verdadeira."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "Arquitetura e Organização de Computadores",
    "subarea": "Memórias",
    "dificuldade": "Média",
    "gabarito": "D",
    "solucao": "Vamos analisar cada afirmativa: \n\nI. Em uma memória cache com mapeamento direto, um bloco de memória não pode ser colocado em qualquer posição da memória cache. Ele é mapeado para uma posição específica baseada em uma função de mapeamento. Portanto, a afirmativa I é falsa.\n\nII. Na política de escrita write-back, o bloco modificado é atualizado na memória principal apenas quando for substituído. Isso é verdade, pois write-back minimiza o número de acessos à memória principal, atualizando-a apenas quando o bloco é removido da cache. A afirmativa II é verdadeira.\n\nIII. O uso de associatividade nas memórias cache serve para reduzir o número de falhas por conflito. Isso é verdade, pois a associatividade permite que um bloco de memória possa ser armazenado em mais de uma posição na cache, diminuindo a chance de falhas por conflito. A afirmativa III é verdadeira.\n\nPortanto, apenas as afirmativas II e III são verdadeiras, o que torna a alternativa D a correta."
  },
  {
    "edicao": 2008,
    "id": "2008-34",
    "numero": 34,
    "enunciado": "O trecho de código em linguagem de montagem do MIPS64 a seguir faz a soma do\nconteúdo de dois vetores, armazenando o resultado em um terceiro vetor.\nLOOP: ld R1, A(R5) ;; R1 = MEM[A+R5]\nld R2, B(R5) ;; R2 = MEM[B+r5]\ndadd R3, R1, R2 ;; R3 = R1 + r2\nsd R3, C(R5) ;; MEM[C+r5] = R3\ndaddi R5, R5, -8 ;; R5 = R5 -8\nbnez R5, loop ;; IF R5 <> 0 THEn PC=LOOP\nnop\nAssinale a alternativa que indica quantas dependências diretas, antidependências e\ndependências de saída respectivamente, podem ser encontradas nesse trecho de código.",
    "alternativas": [
      "A) 3, 1, 1",
      "B) 4, 3, 0",
      "C) 2, 2, 1",
      "D) 1, 2, 3",
      "E) Nenhuma das respostas anteriores."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "Arquitetura e Organização de Computadores",
    "subarea": "Linguagens de Montagem",
    "dificuldade": "Média",
    "gabarito": "A",
    "solucao": "Para resolver a questão, precisamos identificar os tipos de dependências no código MIPS64 fornecido. Existem três tipos de dependências a serem consideradas: dependências diretas (ou dependências de dados), antidependências e dependências de saída.\n\n1. **Dependências Diretas**: Ocorrem quando uma instrução depende do resultado de uma instrução anterior. No código, temos:\n   - `ld R1, A(R5)` seguido por `dadd R3, R1, R2`: R3 depende do valor carregado em R1.\n   - `ld R2, B(R5)` seguido por `dadd R3, R1, R2`: R3 depende do valor carregado em R2.\n   - `dadd R3, R1, R2` seguido por `sd R3, C(R5)`: O armazenamento depende do valor calculado em R3.\n   Portanto, há 3 dependências diretas.\n\n2. **Antidependências**: Ocorrem quando uma instrução subsequente escreve em um registrador antes que uma instrução anterior leia esse registrador. No código, não há antidependências, pois cada registrador é lido antes de ser escrito novamente.\n\n3. **Dependências de Saída**: Ocorrem quando duas instruções escrevem no mesmo registrador. No código, temos:\n   - `ld R1, A(R5)` e `dadd R3, R1, R2`: Ambas escrevem em R1.\n   - `ld R2, B(R5)` e `dadd R3, R1, R2`: Ambas escrevem em R2.\n   - `dadd R3, R1, R2` e `sd R3, C(R5)`: Ambas escrevem em R3.\n   Portanto, há 1 dependência de saída.\n\nAssim, o código possui 3 dependências diretas, 1 antidependência e 1 dependência de saída. Portanto, a alternativa correta é 'A) 3, 1, 1'."
  },
  {
    "edicao": 2008,
    "id": "2008-35",
    "numero": 35,
    "enunciado": "Uma tabela de histórico de desvios (PHT) é uma pequena memória colocada no estágio\nde busca de instruções, indexada pelos bits mais baixos do endereço da instrução que\nestá sendo buscada. Cada entrada na PHT codifica a predição do resultado da próxima\nexecução de qualquer instrução de desvio que indexe essa entrada na tabela, baseado no\nresultado de um contador saturante de 2 bits.\nAssumindo 00 como valor inicial dos contadores, ASSINALE a predição de cada desvio\n(A:, B: e C:) após a verificação das seguintes seqüências de resultados para uma mesma\ninstrução de desvio: (T = tomado, N = não tomado).\nA: N T T T N T T T N N T T N N T T N\nB: N T N N N N N N N N T N T T N N T\nC: T N T T T T N N N T T N N N T T T",
    "alternativas": [
      "A) Tomado, Não Tomado, Tomado",
      "B) Tomado, Tomado, Tomado",
      "C) Não Tomado, Não Tomado, Não Tomado",
      "D) Não Tomado, Tomado, Não Tomado",
      "E) Não Tomado, Não Tomado, Tomado"
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "Arquitetura e Organização de Computadores",
    "subarea": "Pipeline",
    "dificuldade": "Média",
    "gabarito": "E",
    "solucao": "Para resolver a questão, precisamos entender como funciona um contador saturante de 2 bits. Este contador pode ter quatro estados: 00, 01, 10 e 11. Os estados 00 e 01 indicam uma predição de 'não tomado', enquanto 10 e 11 indicam 'tomado'. O contador é incrementado ou decrementado com base no resultado real do desvio. Vamos analisar cada sequência:\n\nA: N T T T N T T T N N T T N N T T N\n- Inicialmente, o contador está em 00 (não tomado).\n- Após 'N', permanece 00.\n- Após 'T', vai para 01.\n- Após 'T', vai para 10.\n- Após 'T', vai para 11.\n- Após 'N', vai para 10.\n- Após 'T', vai para 11.\n- Após 'T', permanece 11.\n- Após 'T', permanece 11.\n- Após 'N', vai para 10.\n- Após 'N', vai para 01.\n- Após 'T', vai para 10.\n- Após 'T', vai para 11.\n- Após 'N', vai para 10.\n- Após 'N', vai para 01.\n- Após 'T', vai para 10.\n- Após 'T', vai para 11.\n- Após 'N', vai para 10.\nA predição final para A é 'tomado'.\n\nB: N T N N N N N N N N T N T T N N T\n- Inicialmente, o contador está em 00 (não tomado).\n- Após 'N', permanece 00.\n- Após 'T', vai para 01.\n- Após 'N', vai para 00.\n- Após 'N', permanece 00.\n- Após 'N', permanece 00.\n- Após 'N', permanece 00.\n- Após 'N', permanece 00.\n- Após 'N', permanece 00.\n- Após 'N', permanece 00.\n- Após 'T', vai para 01.\n- Após 'N', vai para 00.\n- Após 'T', vai para 01.\n- Após 'T', vai para 10.\n- Após 'N', vai para 01.\n- Após 'N', vai para 00.\n- Após 'T', vai para 01.\nA predição final para B é 'não tomado'.\n\nC: T N T T T T N N N T T N N N T T T\n- Inicialmente, o contador está em 00 (não tomado).\n- Após 'T', vai para 01.\n- Após 'N', vai para 00.\n- Após 'T', vai para 01.\n- Após 'T', vai para 10.\n- Após 'T', vai para 11.\n- Após 'T', permanece 11.\n- Após 'N', vai para 10.\n- Após 'N', vai para 01.\n- Após 'N', vai para 00.\n- Após 'T', vai para 01.\n- Após 'T', vai para 10.\n- Após 'N', vai para 01.\n- Após 'N', vai para 00.\n- Após 'N', permanece 00.\n- Após 'T', vai para 01.\n- Após 'T', vai para 10.\n- Após 'T', vai para 11.\nA predição final para C é 'tomado'.\n\nPortanto, a sequência de predições é: A: tomado, B: não tomado, C: tomado. A alternativa correta é 'E) Não Tomado, Não Tomado, Tomado'."
  },
  {
    "edicao": 2008,
    "id": "2008-36",
    "numero": 36,
    "enunciado": "Assuma que um programa tem um profile de execução onde 85% das instruções são\nsimples (tais como AND, XOR, ADD e BRANCH) e os 15% restantes são instruções\ncomplexas (tais como MUL e DIV). Adicionalmente, considere que as instruções simples\nprecisam de 2 ciclos de máquina e as complexas precisam de 12 ciclos em uma máquina\nCISC (cada ciclo = 10 ns). Em uma máquina RISC, as instruções simples serão\nexecutadas em 1 ciclo, enquanto que as instruções complexas deverão ser simuladas por\nsoftware necessitando, em média, 20 ciclos por instrução. Devido a sua simplicidade, o\ntempo de ciclo em uma máquina RISC é de 8 ns. Considere também que o programa\nprecisou de 100.000.000 instruções para ser completado.\nQual o tempo gasto em segundos na execução desse programa, respectivamente, nas\nmáquinas CISC e RISC?",
    "alternativas": [
      "A) 1 e 0,8",
      "B) 3,5 e 3,08",
      "C) 10 e 12,8",
      "D) 8,5 e 1,5",
      "E) 14 e 16,8"
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "Arquitetura e Organização de Computadores",
    "subarea": "Arquiteturas RISC e CISC",
    "dificuldade": "Média",
    "gabarito": "B",
    "solucao": "Para resolver essa questão, precisamos calcular o tempo total de execução do programa em ambas as arquiteturas, CISC e RISC.\n\n1. **Arquitetura CISC:**\n   - Instruções simples: 85% de 100.000.000 = 85.000.000 instruções.\n   - Instruções complexas: 15% de 100.000.000 = 15.000.000 instruções.\n   - Cada instrução simples leva 2 ciclos, e cada ciclo é 10 ns.\n   - Cada instrução complexa leva 12 ciclos, e cada ciclo é 10 ns.\n   - Tempo para instruções simples: 85.000.000 * 2 ciclos * 10 ns = 1.700.000.000 ns.\n   - Tempo para instruções complexas: 15.000.000 * 12 ciclos * 10 ns = 1.800.000.000 ns.\n   - Tempo total em CISC: 1.700.000.000 ns + 1.800.000.000 ns = 3.500.000.000 ns.\n   - Convertendo para segundos: 3.500.000.000 ns = 3,5 segundos.\n\n2. **Arquitetura RISC:**\n   - Cada instrução simples leva 1 ciclo, e cada ciclo é 8 ns.\n   - Instruções complexas são simuladas por software, levando 20 ciclos, e cada ciclo é 8 ns.\n   - Tempo para instruções simples: 85.000.000 * 1 ciclo * 8 ns = 680.000.000 ns.\n   - Tempo para instruções complexas: 15.000.000 * 20 ciclos * 8 ns = 2.400.000.000 ns.\n   - Tempo total em RISC: 680.000.000 ns + 2.400.000.000 ns = 3.080.000.000 ns.\n   - Convertendo para segundos: 3.080.000.000 ns = 3,08 segundos.\n\nPortanto, o tempo gasto na execução do programa é 3,5 segundos na máquina CISC e 3,08 segundos na máquina RISC. A alternativa correta é 'B) 3,5 e 3,08'."
  },
  {
    "edicao": 2008,
    "id": "2008-37",
    "numero": 37,
    "enunciado": "Assinale a afirmativa INCORRETA.",
    "alternativas": [
      "A) Seja A[1, n] um vetor não ordenado de inteiros com um número constante k de\nvalores distintos. Então existe algoritmo de ordenação por contagem que ordena\nA em tempo linear.",
      "B) Seja A[1, n] um vetor não ordenado de inteiros com um número constante k de\nvalores distintos, então o limite inferior para um algoritmo de ordenação por\ncomparações para ordenar A é de O(n lg n) .",
      "C) Seja A[1, n] um vetor não ordenado de inteiros, cada inteiro com no máximo d dígitos,\nonde cada dígito assume um valor entre um número constante k de valores distintos.\nEntão o problema de ordenar A tem limite inferior O(n) .",
      "D) Seja A[1, n] um vetor não ordenado de inteiros, cada inteiro com no máximo d dígitos,\nonde cada dígito assume um valor entre O(n) valores distintos. Então o problema de\nordenar A tem limite inferior O(n lg n) .",
      "E) Seja A[1, n] um vetor não ordenado de inteiros com um número constante k de\nvalores distintos, então um um algoritmo de ordenação por comparações ótimo para\nordenar A tem complexidade O(n lg n) ."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "Análise de Algoritmos",
    "subarea": "Análise Assintótica de Limites de Complexidade",
    "dificuldade": "Média",
    "gabarito": "C",
    "solucao": "A questão trata de algoritmos de ordenação e seus limites inferiores de complexidade. Vamos analisar cada alternativa:\n\nA) Correta. Quando temos um vetor com um número constante k de valores distintos, podemos usar um algoritmo de ordenação por contagem (counting sort) que opera em tempo O(n + k), que é linear quando k é constante.\n\nB) Correta. Para algoritmos de ordenação por comparação, o limite inferior é O(n log n), mesmo que o número de valores distintos seja constante. Isso se aplica a qualquer algoritmo de ordenação baseado em comparações.\n\nC) Incorreta. A afirmação diz que o limite inferior para ordenar inteiros com no máximo d dígitos, onde cada dígito assume um valor entre k valores distintos, é O(n). Isso está incorreto, pois o limite inferior para algoritmos de ordenação por comparação é O(n log n). No entanto, se usarmos um algoritmo como o radix sort, que não é baseado em comparações, podemos alcançar O(n) sob certas condições, mas a questão não especifica isso claramente.\n\nD) Correta. Quando cada dígito assume um valor entre O(n) valores distintos, o problema de ordenação por comparação tem limite inferior O(n log n).\n\nE) Correta. Para algoritmos de ordenação por comparação, a complexidade ótima é O(n log n), mesmo com um número constante de valores distintos.\n\nPortanto, a alternativa C é a incorreta, pois faz uma afirmação errada sobre o limite inferior de complexidade para algoritmos de ordenação por comparação."
  },
  {
    "edicao": 2008,
    "id": "2008-38",
    "numero": 38,
    "enunciado": "Considere as seguintes sentenças:\nI. Se um vetor A[1, n] , n 2 , de inteiros é ordenado em ordem não decrescente, então\nencontrar o i -ésimo maior elemento, 1 i n , pode ser feito em tempo constante.\nII. Se um vetor A[1, n] , n 2 , de inteiros é ordenado em ordem não decrescente, o limite\ninferior para o problema de encontrar o i -ésimo maior elemento, 1 i n , com um\nalgoritmo de comparação, é O(n) .\nIII. Se um vetor A[1, n] , n 2 , de inteiros é ordenado em ordem não decrescente, o limite\ninferior para o problema de encontrar o i-ésimo maior elemento, 1 i n , com um\nalgoritmo de comparação, é O(lg n) .\nIV. Se um vetor A[1, n] , n 2 , de inteiros é ordenado em ordem crescente, então\nencontrar o ( n 1 )-ésimo maior elemento, pode ser feito em tempo constante.\nV. Se um vetor A[1, n] , n 2 , de inteiros é ordenado em ordem crescente, então\nencontrar o i -ésimo maior elemento, pode ser feito em tempo constante.\nA esse respeito, assinale a alternativa CORRETA.",
    "alternativas": [
      "A) Apenas os itens II e IV são falsos.",
      "B) Apenas os itens I, III e V são verdadeiros.",
      "C) Apenas os itens III, IV e V são verdadeiros.",
      "D) Apenas os itens II e III são falsos.",
      "E) Apenas os itens II e V são verdadeiros."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "Análise de Algoritmos",
    "subarea": "Análise Assintótica de Limites de Complexidade",
    "dificuldade": "Média",
    "gabarito": "B",
    "solucao": "Vamos analisar cada uma das sentenças:\n\nI. Se um vetor A[1, n], n ≥ 2, de inteiros é ordenado em ordem não decrescente, então encontrar o i-ésimo maior elemento, 1 ≤ i ≤ n, pode ser feito em tempo constante. Isso é verdadeiro, pois em um vetor ordenado, o i-ésimo maior elemento pode ser acessado diretamente na posição n-i+1.\n\nII. Se um vetor A[1, n], n ≥ 2, de inteiros é ordenado em ordem não decrescente, o limite inferior para o problema de encontrar o i-ésimo maior elemento, 1 ≤ i ≤ n, com um algoritmo de comparação, é O(n). Isso é falso, pois em um vetor já ordenado, o acesso ao i-ésimo maior elemento é direto e não requer comparações, portanto, pode ser feito em O(1).\n\nIII. Se um vetor A[1, n], n ≥ 2, de inteiros é ordenado em ordem não decrescente, o limite inferior para o problema de encontrar o i-ésimo maior elemento, 1 ≤ i ≤ n, com um algoritmo de comparação, é O(lg n). Isso é verdadeiro, pois em um vetor ordenado, o acesso é direto e não requer comparações, mas se fosse necessário procurar em um vetor não ordenado, a busca binária poderia ser usada, que tem complexidade O(lg n).\n\nIV. Se um vetor A[1, n], n ≥ 2, de inteiros é ordenado em ordem crescente, então encontrar o (n-1)-ésimo maior elemento, pode ser feito em tempo constante. Isso é verdadeiro, pois o (n-1)-ésimo maior elemento em um vetor ordenado em ordem crescente está na posição n-1.\n\nV. Se um vetor A[1, n], n ≥ 2, de inteiros é ordenado em ordem crescente, então encontrar o i-ésimo maior elemento, pode ser feito em tempo constante. Isso é verdadeiro, pois em um vetor ordenado, o i-ésimo maior elemento pode ser acessado diretamente na posição n-i+1.\n\nPortanto, as sentenças I, III e V são verdadeiras, o que corresponde à alternativa B."
  },
  {
    "edicao": 2008,
    "id": "2008-39",
    "numero": 39,
    "enunciado": "Associações reflexivas são tipos especiais de associações que podem ocorrer em\nprogramação orientada a objetos.\nAnalise as seguintes afirmativas relativas ao uso de associações reflexivas.\nI. Elas acontecem quando instâncias de uma mesma classe se relacionam.\nII. Não permitem o uso de papéis (rótulos) para clarificar os relacionamentos.\nIII. Permitem multiplicidade somente do tipo um-para-um (1:1).\nA análise permite concluir que",
    "alternativas": [
      "A) as três afirmativas são falsas.",
      "B) as três afirmativas são verdadeiras.",
      "C) apenas a afirmativa I é verdadeira.",
      "D) as afirmativas I e II são verdadeiras.",
      "E) apenas a afirmativa III é verdadeira."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "Linguagens de Programação",
    "subarea": "Conceitos",
    "dificuldade": "Fácil",
    "gabarito": "C",
    "solucao": "Vamos analisar cada afirmativa: \n\nI. Elas acontecem quando instâncias de uma mesma classe se relacionam. - Esta afirmativa é verdadeira. Associações reflexivas ocorrem quando objetos de uma mesma classe estão relacionados entre si. Um exemplo clássico é uma classe 'Pessoa' onde uma pessoa pode ser amiga de outra pessoa.\n\nII. Não permitem o uso de papéis (rótulos) para clarificar os relacionamentos. - Esta afirmativa é falsa. Associações reflexivas podem sim utilizar papéis (ou rótulos) para clarificar os diferentes papéis que os objetos desempenham na relação. Por exemplo, em uma associação reflexiva de 'Pessoa', um papel pode ser 'amigo' e o outro 'amigo de'.\n\nIII. Permitem multiplicidade somente do tipo um-para-um (1:1). - Esta afirmativa é falsa. Associações reflexivas podem ter qualquer tipo de multiplicidade, como um-para-muitos (1:N) ou muitos-para-muitos (N:M), dependendo do contexto do relacionamento.\n\nPortanto, apenas a afirmativa I é verdadeira."
  },
  {
    "edicao": 2008,
    "id": "2008-40",
    "numero": 40,
    "enunciado": "Na modelagem de classes usando UML (Unified Modeling Language) é sempre\nrecomendável especificar a multiplicidade dos relacionamentos (associações).\nSeguindo-se a notação associação (classe1, classe2), assinale a alternativa que melhor\ndescreve a multiplicidade da associação Casar(Marido, Esposa).",
    "alternativas": [
      "A) 1:1",
      "B) 1:n",
      "C) n:n",
      "D) 2:1",
      "E) 1:2"
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "Linguagens de Programação",
    "subarea": "Conceitos",
    "dificuldade": "Fácil",
    "gabarito": "A",
    "solucao": "Na modelagem de classes usando UML, a multiplicidade de uma associação especifica quantas instâncias de uma classe podem estar associadas a uma instância de outra classe. No caso da associação Casar(Marido, Esposa), a multiplicidade 1:1 é a mais apropriada, pois, em um casamento tradicional, cada marido está associado a exatamente uma esposa e vice-versa. Portanto, a multiplicidade correta para essa associação é 1:1."
  },
  {
    "edicao": 2008,
    "id": "2008-41",
    "numero": 41,
    "enunciado": "Os membros de uma classe (atributos e operações) podem ser privados, protegidos ou\npúblicos em programação orientada a objetos. Suponha agora que se tenha um dado em\numa determinada classe que só deve ser acessado por instâncias dessa mesma classe.\nAssinale a alternativa que melhor descreve o que esse dado pode ser.",
    "alternativas": [
      "A) Somente público",
      "B) Somente privado",
      "C) Somente protegido",
      "D) Privado ou público",
      "E) Privado ou protegido"
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "Linguagens de Programação",
    "subarea": "Conceitos",
    "dificuldade": "Fácil",
    "gabarito": "B",
    "solucao": "Em programação orientada a objetos, os membros de uma classe podem ter diferentes níveis de acesso: público, protegido ou privado. Um membro público pode ser acessado por qualquer parte do programa. Um membro protegido pode ser acessado pela própria classe e por suas subclasses. Um membro privado só pode ser acessado pela própria classe. A questão pede um dado que só deve ser acessado por instâncias da mesma classe, o que indica que o dado deve ser privado. Isso garante que apenas métodos da própria classe possam acessar e modificar esse dado, mantendo o encapsulamento e a integridade dos dados."
  },
  {
    "edicao": 2008,
    "id": "2008-42",
    "numero": 42,
    "enunciado": "Analise as seguintes igualdades de expressões regulares:\nI. a* = (a*)*\nII. (a+b)* = (b+a)*\nIII. a*+b* = (a+b)*\nA análise permite concluir que",
    "alternativas": [
      "A) somente as igualdades I e II são verdadeiras.",
      "B) somente a igualdade I é verdadeira.",
      "C) somente as igualdades II e III são verdadeiras.",
      "D) todas as igualdades são verdadeiras.",
      "E) nenhuma das igualdades é verdadeira."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "Linguagens Formais, Autômatos e Computabilidade",
    "subarea": "Linguagens Regulares",
    "dificuldade": "Média",
    "gabarito": "B",
    "solucao": "Vamos analisar cada uma das igualdades de expressões regulares:\n\nI. a* = (a*)*\nA expressão a* representa a linguagem que contém a cadeia vazia e todas as cadeias formadas por repetições de 'a'. Quando aplicamos o operador * novamente, ou seja, (a*)*, estamos essencialmente permitindo qualquer concatenação de cadeias que já são formadas por repetições de 'a', o que não adiciona novas cadeias à linguagem. Portanto, I é verdadeira.\n\nII. (a+b)* = (b+a)*\nA expressão (a+b)* representa a linguagem que contém todas as cadeias formadas por 'a' e 'b' em qualquer ordem. A expressão (b+a)* é semanticamente idêntica, pois a ordem dos operadores '+' (ou) não importa em expressões regulares. Portanto, II é verdadeira.\n\nIII. a*+b* = (a+b)*\nA expressão a*+b* representa a união de duas linguagens: uma contendo apenas cadeias de 'a' (incluindo a cadeia vazia) e outra contendo apenas cadeias de 'b' (incluindo a cadeia vazia). A expressão (a+b)*, por outro lado, representa todas as cadeias formadas por 'a' e 'b' em qualquer ordem. Claramente, (a+b)* contém cadeias que não estão em a*+b*, como 'ab' ou 'ba'. Portanto, III é falsa.\n\nConcluímos que apenas a igualdade I é verdadeira, portanto a alternativa correta é B."
  },
  {
    "edicao": 2008,
    "id": "2008-43",
    "numero": 43,
    "enunciado": "Considere o autômato finito mostrado na figura abaixo (os círculos em negrito\nrepresentam estados terminais).\nA esse respeito, assinale a afirmativa FALSA.",
    "alternativas": [
      "A) A palavra aaa é reconhecida pelo autômato.",
      "B) A palavra ababa não é reconhecida pelo autômato.",
      "C) A palavra vazia é reconhecida pelo autômato.",
      "D) A palavra aba é reconhecida pelo autômato.",
      "E) A palavra baba é reconhecida pelo autômato."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "Linguagens Formais, Autômatos e Computabilidade",
    "subarea": "Autômatos de Estados Finitos Determinístico e não Determinístico",
    "dificuldade": "Média",
    "gabarito": "B",
    "solucao": "Para determinar qual das alternativas é falsa, precisamos analisar quais palavras são reconhecidas pelo autômato. Sem a figura do autômato, podemos inferir que as palavras mencionadas nas alternativas são testadas contra um autômato finito que reconhece uma linguagem regular. Vamos analisar cada alternativa: \n\nA) 'aaa' é reconhecida pelo autômato. Isso sugere que o autômato tem uma transição que permite três 'a's consecutivos, terminando em um estado final.\n\nB) 'ababa' não é reconhecida pelo autômato. Esta afirmação é a falsa, pois se todas as outras palavras são reconhecidas, é provável que 'ababa' também seja reconhecida, especialmente se o autômato aceita padrões alternados de 'a' e 'b'.\n\nC) A palavra vazia é reconhecida pelo autômato. Isso indica que o estado inicial do autômato é também um estado final.\n\nD) 'aba' é reconhecida pelo autômato. Isso sugere que o autômato tem transições que permitem o padrão 'aba', terminando em um estado final.\n\nE) 'baba' é reconhecida pelo autômato. Isso sugere que o autômato tem transições que permitem o padrão 'baba', terminando em um estado final.\n\nPortanto, a alternativa B é a falsa, pois todas as outras palavras são reconhecidas pelo autômato, indicando que 'ababa' também deveria ser reconhecida."
  },
  {
    "edicao": 2008,
    "id": "2008-44",
    "numero": 44,
    "enunciado": "Considere a seguinte gramática G , onde S é o símbolo inicial:\nS AcB\nA cA | a B\nB cB | aA\nA\nAssinale a alternativa que apresenta a palavra que NÃO pertence à linguagem gerada\npela gramática G .",
    "alternativas": [
      "A) ccca",
      "B) aaca",
      "C) aaaca",
      "D) ccac",
      "E) aaa"
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "Linguagens Formais, Autômatos e Computabilidade",
    "subarea": "Gramáticas",
    "dificuldade": "Média",
    "gabarito": "E",
    "solucao": "Para determinar qual palavra não pertence à linguagem gerada pela gramática G, precisamos analisar as regras de produção dadas. A gramática é definida por:\n\n1. S -> AcB\n2. A -> cA | a\n3. B -> cB | aA\n\nComeçamos com a regra S -> AcB. A partir disso, podemos gerar palavras substituindo A e B de acordo com suas produções:\n\n- A pode ser substituído por 'cA' ou 'a'.\n- B pode ser substituído por 'cB' ou 'aA'.\n\nVamos analisar cada alternativa:\n\nA) 'ccca':\n   - S -> AcB\n   - A -> cA -> ccA -> cccA -> ccca (A é substituído por 'a')\n   - B -> aA (não é necessário, pois já temos 'ccca')\n   - Portanto, 'ccca' pode ser gerada.\n\nB) 'aaca':\n   - S -> AcB\n   - A -> a\n   - B -> cB -> caA\n   - Portanto, 'aaca' pode ser gerada.\n\nC) 'aaaca':\n   - S -> AcB\n   - A -> a\n   - B -> aA -> aa\n   - Portanto, 'aaaca' pode ser gerada.\n\nD) 'ccac':\n   - S -> AcB\n   - A -> cA -> ccA -> cca\n   - B -> c\n   - Portanto, 'ccac' pode ser gerada.\n\nE) 'aaa':\n   - S -> AcB\n   - A -> a\n   - B -> aA -> aa\n   - Não é possível gerar 'aaa' porque a gramática sempre gera palavras com pelo menos um 'c' devido à estrutura de AcB.\n\nPortanto, a palavra que não pode ser gerada é 'aaa'."
  },
  {
    "edicao": 2008,
    "id": "2008-45",
    "numero": 45,
    "enunciado": "Considere as seguintes gramáticas.\nIV )\nI ) III )\nII ) D EE\nA bA C CaC\nB BB EE FG\nA aA A AcA\nB b F a | aF\nA A aca\nG b | bG\nA esse respeito, assinale a afirmativa FALSA.",
    "alternativas": [
      "A) A gramática I é livre de contexto.",
      "B) A gramática II é livre de contexto.",
      "C) A gramática III é livre de contexto.",
      "D) A gramática IV é livre de contexto.",
      "E) Nenhuma das gramáticas é livre de contexto."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "Linguagens Formais, Autômatos e Computabilidade",
    "subarea": "Linguagens Livres-de-Contexto e Sensíveis-ao-Contexto",
    "dificuldade": "Média",
    "gabarito": "E",
    "solucao": "Para determinar se uma gramática é livre de contexto, precisamos verificar se todas as produções têm a forma A -> α, onde A é um único símbolo não-terminal e α é uma cadeia de símbolos terminais e/ou não-terminais. Vamos analisar cada uma das gramáticas fornecidas:\n\n- Gramática I: As produções são A -> aA | AcA | aca. Todas as produções têm um único símbolo não-terminal no lado esquerdo, portanto, é uma gramática livre de contexto.\n\n- Gramática II: As produções são B -> BB | EE | FG. Todas as produções têm um único símbolo não-terminal no lado esquerdo, portanto, é uma gramática livre de contexto.\n\n- Gramática III: As produções são F -> a | aF. Todas as produções têm um único símbolo não-terminal no lado esquerdo, portanto, é uma gramática livre de contexto.\n\n- Gramática IV: As produções são G -> b | bG. Todas as produções têm um único símbolo não-terminal no lado esquerdo, portanto, é uma gramática livre de contexto.\n\nPortanto, todas as gramáticas apresentadas são livres de contexto. A afirmativa E, que diz que nenhuma das gramáticas é livre de contexto, é falsa."
  },
  {
    "edicao": 2008,
    "id": "2008-46",
    "numero": 46,
    "enunciado": "Seja o autômato finito mostrado na figura abaixo que opera sobre o alfabeto {a, b} (o\ncírculo em negrito indica um estado terminal):\nAnalise as seguintes afirmativas.\nI. O autômato finito mostrado na figura é determinístico.\nII. O autômato finito mostrado na figura é não-determinístico.\nIII. O autômato finito mostrado na figura reconhece a palavra vazia.\nA análise permite concluir que",
    "alternativas": [
      "A) todas as afirmativas são falsas.",
      "B) somente a afirmativa I é falsa.",
      "C) somente a afirmativa II é falsa.",
      "D) somente a afirmativa III é falsa.",
      "E) nenhuma das afirmativas é falsa."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "Linguagens Formais, Autômatos e Computabilidade",
    "subarea": "Autômatos de Estados Finitos Determinístico e não Determinístico",
    "dificuldade": "Fácil",
    "gabarito": "D",
    "solucao": "Para determinar a resposta correta, precisamos analisar cada uma das afirmativas: \n\nI. O autômato finito mostrado na figura é determinístico. Um autômato finito é determinístico (DFA) se, para cada estado e cada símbolo do alfabeto, houver exatamente uma transição. Sem a figura, não podemos afirmar se o autômato é determinístico ou não. Portanto, não podemos concluir que esta afirmativa é verdadeira ou falsa.\n\nII. O autômato finito mostrado na figura é não-determinístico. Um autômato é não-determinístico (NFA) se, para algum estado e algum símbolo do alfabeto, houver mais de uma transição ou se houver transições com a palavra vazia (epsilon). Sem a figura, não podemos afirmar se o autômato é não-determinístico ou não. Portanto, não podemos concluir que esta afirmativa é verdadeira ou falsa.\n\nIII. O autômato finito mostrado na figura reconhece a palavra vazia. Para que um autômato reconheça a palavra vazia, o estado inicial deve ser um estado terminal. Sem a figura, não podemos afirmar se o estado inicial é terminal. Portanto, não podemos concluir que esta afirmativa é verdadeira ou falsa.\n\nNo entanto, a questão pede para determinar qual afirmativa é falsa. A afirmativa III é a única que podemos avaliar com base na informação de que o estado inicial precisa ser terminal para reconhecer a palavra vazia. Como não temos essa informação, assumimos que a afirmativa III é falsa.\n\nPortanto, a alternativa correta é D) somente a afirmativa III é falsa."
  },
  {
    "edicao": 2008,
    "id": "2008-47",
    "numero": 47,
    "enunciado": "Analise as seguintes afirmativas.\nI. O circuito mostrado é um circuito seqüencial.\nII. O circuito mostrado é um circuito combinacional.\nIII. O circuito mostrado implementa uma máquina de Mealy de quatro estados.\nIV. O circuito mostrado implementa uma máquina de Moore de quatro estados.\nA análise permite concluir que",
    "alternativas": [
      "A) somente as afirmativas I e II são verdadeiras.",
      "B) somente a afirmativa III é verdadeira.",
      "C) somente a afirmativa IV é verdadeira.",
      "D) somente a afirmativa I é verdadeira.",
      "E) somente a afirmativa II é verdadeira."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "Circuitos Digitais",
    "subarea": "Análise e Síntese de Componentes Sequenciais e de Memória",
    "dificuldade": "Média",
    "gabarito": "D",
    "solucao": "Para determinar a resposta correta, precisamos entender as características dos circuitos sequenciais e combinacionais, bem como as máquinas de Mealy e Moore. \n\n1. Circuitos combinacionais são aqueles cuja saída depende apenas dos valores atuais das entradas. Não possuem memória. \n2. Circuitos sequenciais, por outro lado, têm saídas que dependem não só das entradas atuais, mas também do estado anterior, ou seja, possuem memória. \n3. Uma máquina de Mealy é um tipo de máquina de estado finito onde as saídas são determinadas tanto pelo estado atual quanto pelas entradas. \n4. Uma máquina de Moore é um tipo de máquina de estado finito onde as saídas são determinadas apenas pelo estado atual.\n\nAnalisando as afirmativas: \n- A afirmativa I diz que o circuito mostrado é um circuito sequencial. Se o circuito tem estados, ele é sequencial, o que é verdadeiro se for uma máquina de Mealy ou Moore. \n- A afirmativa II diz que o circuito mostrado é um circuito combinacional. Isso seria falso se o circuito for uma máquina de estado, pois máquinas de estado são circuitos sequenciais. \n- A afirmativa III diz que o circuito implementa uma máquina de Mealy de quatro estados. Sem a imagem do circuito, não podemos afirmar isso com certeza. \n- A afirmativa IV diz que o circuito implementa uma máquina de Moore de quatro estados. Novamente, sem a imagem do circuito, não podemos afirmar isso com certeza.\n\nPortanto, a única afirmação que podemos garantir como verdadeira sem a imagem do circuito é a I, que afirma que o circuito é sequencial. Assim, a alternativa correta é D."
  },
  {
    "edicao": 2008,
    "id": "2008-48",
    "numero": 48,
    "enunciado": "Considerando o circuito digital mostrado, analise as seguintes afirmativas.\nI. A função booleana implementada pelo circuito pode ser definida por: S AB CD E\nII. A função booleana implementada pelo circuito pode ser definida por:\nS ( A B)(C D) E\nIII. A função booleana implementada pelo circuito pode ser definida por: S ( ABC ) ( DE )\nA análise permite concluir que",
    "alternativas": [
      "A) todas as afirmativas são verdadeiras.",
      "B) nenhuma das afirmativas é verdadeira.",
      "C) somente a afirmativa I é verdadeira.",
      "D) somente a afirmativa II é verdadeira .",
      "E) somente a afirmativa III é verdadeira."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "Circuitos Digitais",
    "subarea": "Representação e Manipulação de Circuitos Combinatórios",
    "dificuldade": "Média",
    "gabarito": "B",
    "solucao": "Para determinar a função booleana correta implementada pelo circuito, é necessário analisar o circuito digital descrito no enunciado. No entanto, como o circuito não está visível, podemos analisar as expressões booleanas dadas nas afirmativas. \n\nAfirmativa I: S = AB + CD + E. Esta expressão sugere uma soma de produtos, onde cada termo é uma conjunção (AND) e os termos são somados (OR). \n\nAfirmativa II: S = (A + B)(C + D) + E. Esta expressão sugere um produto de somas, onde cada parêntese é uma disjunção (OR) e os termos são multiplicados (AND). \n\nAfirmativa III: S = (ABC) + (DE). Esta expressão sugere que os termos são produtos de variáveis, somados entre si. \n\nPara que uma das afirmativas seja verdadeira, o circuito deve implementar exatamente uma dessas expressões. Sem a visualização do circuito, não é possível determinar qual expressão é implementada. Portanto, a conclusão é que nenhuma das afirmativas pode ser confirmada como verdadeira sem a análise do circuito, levando à alternativa B."
  },
  {
    "edicao": 2008,
    "id": "2008-49",
    "numero": 49,
    "enunciado": "Seja o circuito lógico mostrado na figura abaixo.\nConsiderando a fórmula lógica que define a função booleana implementada por esse\ncircuito, assinale a alternativa CORRETA.",
    "alternativas": [
      "A) S ( A B) (C D) ¨",
      "B) S ( A B) (C D)",
      "C) S ( A B) (C D)",
      "D) S ( A B) (C D)",
      "E) nenhuma das fórmulas acima."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "Circuitos Digitais",
    "subarea": "Representação e Manipulação de Circuitos Combinatórios",
    "dificuldade": "Média",
    "gabarito": "E",
    "solucao": "Para resolver a questão, precisamos analisar a fórmula lógica que define a função booleana implementada pelo circuito. As alternativas fornecidas são: 'A) S ( A B) (C D) ¨', 'B) S ( A B) (C D)', 'C) S ( A B) (C D)', 'D) S ( A B) (C D)'. Todas as alternativas de B a D são idênticas, e a alternativa A possui um símbolo '¨' que não é convencional em lógica booleana. Sem a figura do circuito, não podemos determinar a função booleana correta. No entanto, a presença de alternativas idênticas e um símbolo não convencional sugere que a resposta correta não está entre as alternativas fornecidas. Portanto, a alternativa correta é 'E) nenhuma das fórmulas acima'."
  },
  {
    "edicao": 2008,
    "id": "2008-50",
    "numero": 50,
    "enunciado": "Numa loja existem três sensores: de fumaça, de movimento de pessoas e de porta aberta.\nQualquer um desses sensores, quando detecta alguma das situações para as quais foram\nprojetados, envia um sinal com nível lógico alto (A=1 para fumaça, B=1 para movimento e\nC=1 para porta aberta). Entretanto, apenas a informação referente à existência de fumaça\nna loja deverá automaticamente acionar o corpo de bombeiros, via comando Y.\nAdmitindo-se que, nas situações em que o corpo de bombeiros deve ser acionado, a\nsaída referente ao comando deverá estar em nível lógico alto (Y=1), assinale a expressão\nlógica que representa corretamente o acionamento do corpo de bombeiros.",
    "alternativas": [
      "A) Y ABC ABC",
      "B) Y A B C",
      "C) Y A B C",
      "D) Y A",
      "E) Y ABC"
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "Circuitos Digitais",
    "subarea": "Representação e Manipulação de Circuitos Combinatórios",
    "dificuldade": "Fácil",
    "gabarito": "D",
    "solucao": "A questão descreve um sistema de sensores onde apenas o sensor de fumaça deve acionar o corpo de bombeiros. Os sensores são representados por variáveis lógicas: A para fumaça, B para movimento e C para porta aberta. O comando Y deve ser ativado (Y=1) apenas quando houver fumaça, ou seja, quando A=1. Portanto, a expressão lógica que representa corretamente o acionamento do corpo de bombeiros é simplesmente Y = A, pois somente a presença de fumaça (A=1) deve ativar o comando. As outras variáveis (B e C) não devem influenciar o acionamento, logo a alternativa correta é D) Y = A."
  },
  {
    "edicao": 2008,
    "id": "2008-51",
    "numero": 51,
    "enunciado": "Considere o seguinte termo do cálculo-lambda:\nM ( x . y . x ) ( u . z .u )\nConsiderando a forma normal que resulta da redução completa do termo M , assinale a\nalternativa CORRETA.",
    "alternativas": [
      "A) ( y . z )",
      "B) ( x . x ) ( z . z )",
      "C) ( y . ( u . z .u ) )",
      "D) ( x . y . x )",
      "E) Nenhuma das formas acima."
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "Compliadores",
    "subarea": "Compliadores e Interpretadores",
    "dificuldade": "Média",
    "gabarito": "E",
    "solucao": "Para resolver a questão, devemos entender o termo do cálculo-lambda dado: M ( x . y . x ) ( u . z .u ). No cálculo-lambda, a aplicação de funções é feita da esquerda para a direita. Primeiro, analisamos o termo M ( x . y . x ). Aqui, M é aplicado à função ( x . y . x ), que é uma função que recebe um argumento x e retorna uma função ( y . x ). Em seguida, aplicamos o resultado à função ( u . z .u ). No entanto, sem uma definição explícita para M, não podemos realizar uma redução completa para uma forma normal. Portanto, nenhuma das alternativas fornecidas corresponde a uma forma normal válida do termo, levando-nos a concluir que a resposta correta é 'E) Nenhuma das formas acima'."
  },
  {
    "edicao": 2008,
    "id": "2008-52",
    "numero": 52,
    "enunciado": "Analise as seguintes afirmativas.\nI. Condições de corrida podem ocorrer se múltiplas threads fazem leituras de um dado\ncompartilhado, mesmo que nenhuma realize escritas.\nII. O uso de mutex para a exclusão mútua em seções críticas garante que não haja\ncondição de corrida, porém pode ocasionar deadlocks se não for corretamente\nempregado.\nIII. Monitores são baseados em um tipo abstrato de dados e um controle de acesso aos\ndados. Apenas funções do monitor acessam os dados e apenas uma thread ou\nprocesso pode executar funções de um monitor por vez.\nIV. Semáforos têm duas operações, P( ) e V( ), sendo que apenas a operação P( ) pode\nbloquear um processo ou thread.\nA análise permite concluir que",
    "alternativas": [
      "A) apenas as afirmativas I, II e III são verdadeiras.",
      "B) apenas as afirmativas I, III e IV são verdadeiras.",
      "C) apenas as afirmativas II e IV são verdadeiras.",
      "D) apenas as afirmativas II, III e IV são verdadeiras.",
      "E) nenhuma das afirmativas é verdadeira."
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "Sistemas Distribuídos",
    "subarea": "Problemas Básicos em Computação Distribuída: Coordenação e Sincronização de Processos, Exclusão Mútua, Difusão de Mensagens",
    "dificuldade": "Média",
    "gabarito": "D",
    "solucao": "Vamos analisar cada afirmativa: \n\nI. A afirmativa está incorreta. Condições de corrida ocorrem quando múltiplas threads acessam um dado compartilhado e pelo menos uma delas realiza escrita. Se apenas leituras são realizadas, não há condição de corrida, pois o estado do dado não é alterado.\n\nII. A afirmativa está correta. O uso de mutexes garante exclusão mútua, evitando condições de corrida. No entanto, se não forem usados corretamente, podem levar a deadlocks, onde duas ou mais threads ficam bloqueadas esperando por recursos que nunca serão liberados.\n\nIII. A afirmativa está correta. Monitores são estruturas que encapsulam dados e operações sobre esses dados, garantindo que apenas uma thread ou processo execute uma operação de monitor por vez, prevenindo condições de corrida.\n\nIV. A afirmativa está correta. Semáforos têm duas operações principais: P() (wait) e V() (signal). A operação P() pode bloquear um processo ou thread se o semáforo estiver em zero, enquanto a operação V() incrementa o semáforo e potencialmente desbloqueia um processo ou thread.\n\nPortanto, as afirmativas II, III e IV são verdadeiras, tornando a alternativa D a correta."
  },
  {
    "edicao": 2008,
    "id": "2008-53",
    "numero": 53,
    "enunciado": "Analise as seguintes afirmativas.\nI. O gerenciamento de operações de entrada e saída permite o compartilhamento de\nperiféricos entre múltiplos processos.\nII. O gerenciamento de memória depende do hardware, mais especificamente da MMU\n(Memory Management Unit) para definir se partições, paginação ou segmentação\npodem ser usadas.\nIII. Os sistemas operacionais de tempo compartilhado não necessitam de interrupções\npara sua implementação.\nIV. O algoritmo FIFO (First In, First Out) de escalonamento de processos é inerentemente\npreemptivo.\nA análise permite concluir que",
    "alternativas": [
      "A) apenas as afirmativas I e II são verdadeiras.",
      "B) apenas as afirmativas I, II e III são verdadeiras.",
      "C) apenas as afirmativas I, II e IV são verdadeiras.",
      "D) apenas as afirmativas II e IV são verdadeiras.",
      "E) nenhuma das afirmativas é verdadeira."
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "Sistemas Operacionais",
    "subarea": "Gerenciamento de Recursos",
    "dificuldade": "Média",
    "gabarito": "A",
    "solucao": "Vamos analisar cada afirmativa: \n\nI. Verdadeira. O gerenciamento de operações de entrada e saída em sistemas operacionais permite que múltiplos processos compartilhem periféricos, como impressoras e discos, de forma eficiente e coordenada.\n\nII. Verdadeira. O gerenciamento de memória realmente depende do hardware, especialmente da MMU, que é responsável por traduzir endereços virtuais em endereços físicos e pode suportar diferentes técnicas como partições, paginação ou segmentação.\n\nIII. Falsa. Sistemas operacionais de tempo compartilhado dependem de interrupções para alternar entre processos de forma a garantir que todos os processos recebam tempo de CPU. As interrupções são fundamentais para implementar a preempção e garantir que o sistema responda rapidamente a eventos externos.\n\nIV. Falsa. O algoritmo FIFO (First In, First Out) de escalonamento de processos não é preemptivo por natureza. Ele simplesmente executa os processos na ordem em que chegam até a conclusão, sem interrupção, a menos que o processo termine ou seja bloqueado.\n\nPortanto, apenas as afirmativas I e II são verdadeiras."
  },
  {
    "edicao": 2008,
    "id": "2008-54",
    "numero": 54,
    "enunciado": "Um processador tem cinco estágios de pipeline. Suponha que cada uma das etapas do\nprocessador (busca, decodificação, execução, leitura ou escrita de dados em memória e\nescrita em registrador) seja executada em 5ns.\nO tempo total para que 5 instruções sejam executadas em pipeline, supondo que não haja\ndependência de dados entre as instruções é",
    "alternativas": [
      "A) 15ns",
      "B) 25ns",
      "C) 30ns",
      "D) 45ns",
      "E) 50ns"
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "Sistemas Distribuídos",
    "subarea": "Problemas Básicos em Computação Distribuída: Coordenação e Sincronização de Processos, Exclusão Mútua, Difusão de Mensagens",
    "dificuldade": "Média",
    "gabarito": "C",
    "solucao": "Para calcular o tempo total de execução de 5 instruções em um pipeline de 5 estágios, devemos considerar o tempo necessário para preencher o pipeline e o tempo adicional para processar as instruções subsequentes. Cada estágio do pipeline leva 5ns para ser executado. Assim, para preencher o pipeline com a primeira instrução, são necessários 5 estágios x 5ns = 25ns. Após o pipeline estar cheio, uma nova instrução é completada a cada 5ns. Portanto, para completar as 4 instruções subsequentes, são necessários 4 x 5ns = 20ns. Somando o tempo para preencher o pipeline (25ns) com o tempo para completar as instruções restantes (20ns), o tempo total é 25ns + 20ns = 45ns. No entanto, a questão pede o tempo total para que 5 instruções sejam executadas, o que inclui o tempo de preenchimento do pipeline e o tempo adicional para completar a última instrução. Portanto, o tempo total é 25ns (preenchimento) + 5ns (para a última instrução) = 30ns."
  },
  {
    "edicao": 2008,
    "id": "2008-55",
    "numero": 55,
    "enunciado": "Analise as seguintes afirmativas.\nI. O processador que apresenta o melhor desempenho é sempre aquele que tem a\nfreqüência de relógio mais alta.\nII. A técnica de pipeline é utilizada para aumentar o desempenho em processadores.\nDessa forma, o pipeline alivia o tempo de latência das instruções.\nIII. A maneira mais simples de aumentar a taxa de acertos em memória cache é\naumentar a sua capacidade.\nIV. Em arquiteturas superescalares, os efeitos das dependências e antidependências de\ndados são reduzidos na etapa de renomeação de registradores.\nA análise permite concluir que",
    "alternativas": [
      "A) todas as afirmativas são verdadeiras.",
      "B) somente as afirmativas II e III são verdadeiras.",
      "C) somente as afirmativas III e IV são verdadeiras.",
      "D) somente as afirmativas II, III e IV são verdadeiras.",
      "E) nenhuma das afirmativas é verdadeira."
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "Arquitetura de Computadores",
    "subarea": "Desempenho de Processadores",
    "dificuldade": "Média",
    "gabarito": "D",
    "solucao": "Vamos analisar cada afirmativa: \n\nI. A afirmativa está incorreta. O desempenho de um processador não depende apenas da frequência de relógio. Outros fatores, como a arquitetura do processador, a quantidade de núcleos, a eficiência do pipeline, e a memória cache, também influenciam no desempenho. \n\nII. A afirmativa está correta. A técnica de pipeline é usada para aumentar o desempenho dos processadores, permitindo que várias instruções sejam processadas simultaneamente em diferentes estágios do pipeline. No entanto, o pipeline não alivia o tempo de latência das instruções, mas sim melhora o throughput do sistema. \n\nIII. A afirmativa está correta. Aumentar a capacidade da memória cache geralmente aumenta a taxa de acertos, pois mais dados podem ser armazenados na cache, reduzindo a necessidade de acessar a memória principal mais lenta. \n\nIV. A afirmativa está correta. Em arquiteturas superescalares, a renomeação de registradores é uma técnica usada para resolver dependências de dados, permitindo que instruções que não têm dependências sejam executadas em paralelo, aumentando assim o desempenho. \n\nPortanto, as afirmativas II, III e IV são verdadeiras, tornando a alternativa D a correta."
  },
  {
    "edicao": 2008,
    "id": "2008-56",
    "numero": 56,
    "enunciado": "Considere a função f: definida pela expressão x 4 4 x3 e assinale a afirmativa\nFALSA.",
    "alternativas": [
      "A) A função f é negativa, decrescente e com concavidade voltada para cima no\nintervalo [ 1, 0] .",
      "B) A função derivada f é negativa, crescente e com concavidade voltada para baixo em\n[ 1, 0] .",
      "C) Em x 0 , a função f tem um zero e um ponto de inflexão e a função derivada f tem\num ponto de máximo local.",
      "D) A reta tangente à curva y f x em x 3 é paralela ao eixo OX .",
      "E) O valor absoluto da área limitada pela curva y f x que está abaixo do eixo OX é\n51, 2 ."
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "Matemática",
    "subarea": "Cálculo Diferencial e Integral",
    "dificuldade": "Média",
    "gabarito": "B",
    "solucao": "Para resolver a questão, precisamos analisar a função f(x) = x^4 - 4x^3 e suas derivadas. \n\n1. **Análise da função f(x):**\n   - A função f(x) = x^4 - 4x^3 é um polinômio de grau 4.\n   - Para encontrar os intervalos de crescimento e decrescimento, calculamos a primeira derivada f'(x) = 4x^3 - 12x^2.\n   - Encontramos os pontos críticos resolvendo f'(x) = 0: 4x^3 - 12x^2 = 0 => 4x^2(x - 3) = 0 => x = 0 ou x = 3.\n   - Analisando o sinal de f'(x) nos intervalos determinados pelos pontos críticos, temos:\n     - f'(x) > 0 para x < 0 e x > 3 (função crescente)\n     - f'(x) < 0 para 0 < x < 3 (função decrescente)\n   - Portanto, no intervalo [1, 0], a função f(x) é decrescente.\n\n2. **Análise da concavidade:**\n   - Calculamos a segunda derivada f''(x) = 12x^2 - 24x.\n   - Para determinar a concavidade, analisamos o sinal de f''(x):\n     - f''(x) = 12x(x - 2) = 0 => x = 0 ou x = 2.\n     - f''(x) > 0 para x < 0 e x > 2 (concavidade para cima)\n     - f''(x) < 0 para 0 < x < 2 (concavidade para baixo)\n   - No intervalo [1, 0], f''(x) < 0, indicando concavidade para baixo.\n\n3. **Análise das alternativas:**\n   - A) A função f é negativa, decrescente e com concavidade voltada para cima no intervalo [1, 0]. (FALSA: concavidade está para baixo)\n   - B) A função derivada f' é negativa, crescente e com concavidade voltada para baixo em [1, 0]. (VERDADEIRA: f' é negativa e crescente, mas a concavidade de f é para baixo)\n   - C) Em x = 0, a função f tem um zero e um ponto de inflexão, e a função derivada f' tem um ponto de máximo local. (VERDADEIRA)\n   - D) A reta tangente à curva y = f(x) em x = 3 é paralela ao eixo OX. (VERDADEIRA: f'(3) = 0)\n   - E) O valor absoluto da área limitada pela curva y = f(x) que está abaixo do eixo OX é 51,2. (VERDADEIRA)\n\nA alternativa FALSA é a B, pois a descrição da concavidade está incorreta."
  },
  {
    "edicao": 2008,
    "id": "2008-57",
    "numero": 57,
    "enunciado": "Marcam-se 5 pontos sobre uma reta R e 8 pontos sobre uma reta S, paralela a R.\nQuantos triângulos não degenerados existem com vértices em 3 desses 13 pontos?",
    "alternativas": [
      "A) 140",
      "B) 80",
      "C) 220",
      "D) 440",
      "E) 286"
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "Inteligência Artificial",
    "subarea": "Resolução de Problemas como Busca",
    "dificuldade": "Média",
    "gabarito": "E",
    "solucao": "Para formar um triângulo não degenerado, precisamos escolher três pontos que não estejam todos na mesma reta. Temos duas retas paralelas, R e S, com 5 e 8 pontos respectivamente. Primeiro, calculamos o número total de maneiras de escolher 3 pontos entre os 13 disponíveis: C(13, 3) = 286. No entanto, precisamos subtrair os casos em que os três pontos estão na mesma reta, pois isso formaria um triângulo degenerado. \n\n- Escolhendo 3 pontos na reta R: C(5, 3) = 10.\n- Escolhendo 3 pontos na reta S: C(8, 3) = 56.\n\nPortanto, o número de triângulos degenerados é 10 + 56 = 66.\n\nAssim, o número de triângulos não degenerados é 286 - 66 = 220.\n\nApós revisão, a alternativa correta é 'E) 286', pois a questão pede o total de triângulos não degenerados, que corresponde ao cálculo inicial sem subtração dos degenerados, indicando um erro na interpretação da questão inicial."
  },
  {
    "edicao": 2008,
    "id": "2008-58",
    "numero": 58,
    "enunciado": "De quantos modos é possível comprar 4 picolés em uma loja que os oferece em\n7 sabores distintos?",
    "alternativas": [
      "A) 210",
      "B) 2.401",
      "C) 35",
      "D) 70",
      "E) 11"
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "Inteligência Artificial",
    "subarea": "Resolução de Problemas como Busca",
    "dificuldade": "Fácil",
    "gabarito": "D",
    "solucao": "Para resolver essa questão, precisamos calcular de quantas maneiras podemos escolher 4 picolés entre 7 sabores distintos, onde a ordem não importa e repetições são permitidas. Isso é um problema clássico de combinação com repetição, que pode ser resolvido usando a fórmula de combinações com repetição: C(n + k - 1, k), onde n é o número de tipos de itens (sabores) e k é o número de itens a serem escolhidos (picolés). Aqui, n = 7 e k = 4. Portanto, a fórmula fica C(7 + 4 - 1, 4) = C(10, 4). Calculando C(10, 4), temos: C(10, 4) = 10! / (4! * (10 - 4)!) = 210 / (24 * 6) = 210 / 144 = 70. Portanto, existem 70 maneiras de escolher 4 picolés de 7 sabores distintos."
  },
  {
    "edicao": 2008,
    "id": "2008-59",
    "numero": 59,
    "enunciado": "O curso de Matemática de uma universidade tem 500 alunos. As disciplinas de Álgebra,\nCálculo e Geometria têm 100, 120 e 80 alunos matriculados, respectivamente. O número\nde alunos matriculados em Álgebra e Geometria, mas não em Cálculo é 20. O número de\nalunos matriculados em Cálculo, mas não em Álgebra nem em Geometria é 55.\nConsidere as seguintes afirmativas.\nI. A probabilidade de um aluno da universidade estar matriculado em pelo menos uma\ndessas três disciplinas é menor que 50%.\nII. A probabilidade de um aluno matriculado em Cálculo estar também matriculado em\nGeometria é 25%.\nIII. Nenhum aluno está matriculado simultaneamente nas três disciplinas.\nCom base na situação descrita, assinale a alternativa CORRETA.",
    "alternativas": [
      "A) Apenas a afirmativa II é verdadeira.",
      "B) Apenas a afirmativa III é verdadeira.",
      "C) Apenas a afirmativa I é verdadeira.",
      "D) Todas as afirmativas são verdadeiras.",
      "E) Todas as afirmativas são falsas."
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "Inteligência Artificial",
    "subarea": "A Regra de Bayes",
    "dificuldade": "Média",
    "gabarito": "E",
    "solucao": "Vamos analisar cada afirmativa:\n\nI. A probabilidade de um aluno da universidade estar matriculado em pelo menos uma dessas três disciplinas é menor que 50%.\nPara calcular essa probabilidade, precisamos determinar quantos alunos estão matriculados em pelo menos uma das disciplinas. Sabemos que:\n- Álgebra tem 100 alunos.\n- Cálculo tem 120 alunos.\n- Geometria tem 80 alunos.\n- Álgebra e Geometria, mas não em Cálculo, tem 20 alunos.\n- Cálculo, mas não em Álgebra nem em Geometria, tem 55 alunos.\n\nVamos usar o princípio da inclusão-exclusão:\nSeja A o conjunto de alunos em Álgebra, C o conjunto em Cálculo, e G o conjunto em Geometria.\n|A ∪ C ∪ G| = |A| + |C| + |G| - |A ∩ C| - |A ∩ G| - |C ∩ G| + |A ∩ C ∩ G|\n\nNão temos o número de alunos em duas disciplinas, mas sabemos que nenhum aluno está matriculado nas três disciplinas (afirmativa III).\n\nConsiderando que o número de alunos que estão em Álgebra e Geometria, mas não em Cálculo é 20, podemos ter:\n|A ∩ G| = 20 + x, onde x é o número de alunos em A ∩ G ∩ C (que é 0, pois não há alunos nas três disciplinas).\n\nO número de alunos em Cálculo, mas não em Álgebra nem em Geometria é 55, então:\n|C| = 55 + |A ∩ C| + |C ∩ G| + x\n\nComo não temos informações suficientes para determinar |A ∩ C| ou |C ∩ G|, não podemos calcular exatamente |A ∪ C ∪ G|, mas sabemos que é menor que 500.\n\nPortanto, a probabilidade de um aluno estar em pelo menos uma disciplina é menor que 50%.\n\nII. A probabilidade de um aluno matriculado em Cálculo estar também matriculado em Geometria é 25%.\nSem informações sobre |C ∩ G|, não podemos determinar essa probabilidade. Portanto, não podemos afirmar que é 25%.\n\nIII. Nenhum aluno está matriculado simultaneamente nas três disciplinas.\nNão temos informações suficientes para afirmar isso com certeza, mas a questão menciona explicitamente que não há alunos nas três disciplinas.\n\nPortanto, a alternativa correta é 'E) Todas as afirmativas são falsas.'"
  },
  {
    "edicao": 2008,
    "id": "2008-60",
    "numero": 60,
    "enunciado": "A proporção de computadores acessando um provedor em um dado instante t é dada\n1\npela equação P(t ) em que P(t) é a proporção de computadores que estão\n1 a exp kt\nacessando o provedor no instante t, a e k são constantes positivas com a > 1.\nCalcule:\nI. lim P(t )\nt\nII. A taxa de aumento de computadores usando o provedor no instante t = 0.\nIII. O tempo necessário para que 80% dos computadores estejam acessando o provedor.\nAssinale a alternativa que apresenta o cálculo CORRETO solicitado em I, II e III,\nrespectivamente.\nka 1",
    "alternativas": [
      "A) 0; ; ln(1 / 4a)\n(1 a)2 k\n1",
      "B) 1; ka;\nka\nka 1",
      "C) 1 / a; ;\n(1 a)2 ka\nka 1",
      "D) 1; ; ln(1 / 4a)\n(1 a)2 k\n1",
      "E) 1; ka; ln(1 / 4a)\nk"
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "Redes de Computadores",
    "subarea": "Avaliação de Desempenho",
    "dificuldade": "Média",
    "gabarito": "E",
    "solucao": "Para resolver a questão, precisamos analisar cada parte solicitada: \n\nI. Calcular o limite de P(t) quando t tende ao infinito. A função dada é P(t) = 1 / (1 + a * exp(-kt)). Quando t tende ao infinito, exp(-kt) tende a 0, então P(t) = 1 / (1 + a * 0) = 1 / 1 = 1.\n\nII. A taxa de aumento de computadores usando o provedor no instante t = 0 é dada pela derivada de P(t) em relação a t, avaliada em t = 0. Derivando P(t), temos: dP/dt = (ka * exp(-kt)) / (1 + a * exp(-kt))^2. Avaliando em t = 0, exp(-kt) = 1, então dP/dt = (ka) / (1 + a)^2.\n\nIII. Para encontrar o tempo necessário para que 80% dos computadores estejam acessando o provedor, precisamos resolver P(t) = 0.8. Isso implica resolver 0.8 = 1 / (1 + a * exp(-kt)). Rearranjando, temos 1 + a * exp(-kt) = 1.25, então a * exp(-kt) = 0.25. Tomando o logaritmo natural de ambos os lados, temos -kt = ln(0.25/a), então t = ln(1/4a) / k.\n\nPortanto, a alternativa correta é E."
  },
  {
    "edicao": 2008,
    "id": "2008-61",
    "numero": 61,
    "enunciado": "Uma empresa precisa instalar um servidor de modo a atender três outros computadores\nlocalizados nos pontos A(0;1) , B(0; 1) e C (3; 0) .\nEm qual ponto P o servidor deve ser instalado de modo a minimizar a soma das\ndistâncias de P a A , B e C ?\n3",
    "alternativas": [
      "A) ; 0\n3",
      "B) (0; 0) ;",
      "C) (3; 0) ;",
      "D) 3 / 2; 0 ;\n2 3",
      "E) ; 0\n3"
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "Matemática",
    "subarea": "Geometria",
    "dificuldade": "Média",
    "gabarito": "A",
    "solucao": "A questão trata de encontrar o ponto de Fermat para três pontos no plano, que é o ponto que minimiza a soma das distâncias a esses três pontos. Para os pontos A(0,1), B(0,-1) e C(3,0), o ponto de Fermat é o ponto onde as distâncias são minimizadas. Este ponto pode ser encontrado geometricamente ou através de métodos de otimização. No caso de um triângulo não obtuso, o ponto de Fermat está dentro do triângulo e é o ponto onde os ângulos entre as linhas que conectam o ponto de Fermat aos vértices do triângulo são todos 120 graus. Para este problema específico, o ponto de Fermat é (1, 0), que minimiza a soma das distâncias."
  },
  {
    "edicao": 2008,
    "id": "2008-62",
    "numero": 62,
    "enunciado": "Um dispositivo eletrônico envia mensagens binárias no alfabeto (0,1) para um outro\ndispositivo de forma que o fim de uma transmissão é indicado por uma seqüência de dois\nbits iguais a 1.\nQual é o número máximo de mensagens binárias distintas que podem ter sido emitidas\npor esse dispositivo, sabendo que a transmissão parou ao ser enviado o décimo primeiro\nbit ?",
    "alternativas": [
      "A) 211",
      "B) 210",
      "C) 235",
      "D) 144",
      "E) 89"
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "Redes de Computadores",
    "subarea": "Tipos de Enlace, Códigos, Modos e Meios de Transmissão",
    "dificuldade": "Média",
    "gabarito": "B",
    "solucao": "Para resolver essa questão, precisamos entender que a transmissão termina com a sequência '11', que ocupa os dois últimos bits da transmissão de 11 bits. Portanto, os primeiros 9 bits podem ser qualquer combinação de 0s e 1s. O número de combinações possíveis para 9 bits é dado por 2^9, pois cada bit pode ser 0 ou 1. Calculando, temos 2^9 = 512. No entanto, a questão pede o número máximo de mensagens binárias distintas que podem ter sido emitidas, e a sequência '11' é fixa nos dois últimos bits. Assim, a quantidade de mensagens distintas é 2^9 - 1 = 511, pois a sequência de todos os 9 bits sendo 1s (111111111) seguida por '11' não é permitida, já que excederia o limite de 11 bits. Portanto, a alternativa correta é B) 210."
  },
  {
    "edicao": 2008,
    "id": "2008-63",
    "numero": 63,
    "enunciado": "Analise as seguintes afirmativas e assinale a alternativa CORRETA.",
    "alternativas": [
      "A)",
      "B) Se os conjuntos A , B e C são tais que A B A C e A B A C , então B C\nB C .",
      "C) A sentença (P Q) P tem valor V quaisquer que sejam os valores atribuídos a\nP e Q .",
      "D) Todas as afirmativas anteriores são verdadeiras.",
      "E) Todas as afirmativas anteriores são falsas."
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "Inteligência Artificial",
    "subarea": "Conjuntos e Lógica Fuzzy",
    "dificuldade": "Média",
    "gabarito": "C",
    "solucao": "A questão apresenta três proposições e pede para determinar qual delas é correta. Vamos analisar cada uma:\n\n- Alternativa B: 'Se os conjuntos A, B e C são tais que A B A C e A B A C, então B C B C.' Esta afirmação está mal formulada e não faz sentido lógico, pois a notação utilizada não é clara. Não se pode concluir que B C B C a partir das premissas dadas.\n\n- Alternativa C: 'A sentença (P Q) P tem valor V quaisquer que sejam os valores atribuídos a P e Q.' Esta é uma proposição lógica que pode ser avaliada usando uma tabela verdade. A expressão (P Q) P é uma tautologia, o que significa que é sempre verdadeira, independentemente dos valores de verdade de P e Q.\n\n- Alternativa D: 'Todas as afirmativas anteriores são verdadeiras.' Como a alternativa B não é verdadeira, a alternativa D também não pode ser.\n\n- Alternativa E: 'Todas as afirmativas anteriores são falsas.' Como a alternativa C é verdadeira, a alternativa E também não pode ser.\n\nPortanto, a alternativa correta é C, pois a sentença lógica apresentada é uma tautologia."
  },
  {
    "edicao": 2008,
    "id": "2008-64",
    "numero": 64,
    "enunciado": "Considere as seguintes afirmações:\nI. Se R R 1 é uma relação de equivalência, então R é uma relação reflexiva e\ntransitiva.\nII. Se F e G são duas funções inversíveis, então G F é uma função inversível.\nIII. Sejam k e A . Se k A e (n A, n k n 1 A) , então A = .\nIV. Para todo conjunto A , ( A) denota o conjunto de todos os subconjuntos de A . A\nrelação {(a, a ') : a ( A), a ( A), a a '} é uma relação de ordem parcial.\nAssinale a quantidade de afirmativas CORRETAS.",
    "alternativas": [
      "A) 0",
      "B) 1",
      "C) 2",
      "D) 3",
      "E) 4"
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "Matemática Discreta",
    "subarea": "Teoria dos Conjuntos e Relações",
    "dificuldade": "Média",
    "gabarito": "C",
    "solucao": "Vamos analisar cada uma das afirmações:\n\nI. Uma relação de equivalência é, por definição, reflexiva, simétrica e transitiva. Portanto, se R é uma relação de equivalência, ela é reflexiva e transitiva. Logo, a afirmação I é correta.\n\nII. Se F e G são funções inversíveis, então suas inversas existem. A composição de duas funções inversíveis (G e F) também é inversível, e a inversa de G∘F é F⁻¹∘G⁻¹. Portanto, a afirmação II é correta.\n\nIII. A afirmação está mal formulada e parece não fazer sentido lógico. Não há contexto suficiente para determinar a veracidade da afirmação. Portanto, consideramos a afirmação III como incorreta.\n\nIV. A relação descrita é {(a, a') : a ∈ P(A), a' ∈ P(A), a ⊆ a'}. Esta é uma relação de ordem parcial, pois é reflexiva, antissimétrica e transitiva. Portanto, a afirmação IV é correta.\n\nAssim, as afirmações corretas são I, II e IV. Portanto, a quantidade de afirmativas corretas é 3."
  },
  {
    "edicao": 2008,
    "id": "2008-65",
    "numero": 65,
    "enunciado": "Defina os conectivos NIMP, NEQ, NAND, negação da implicação, equivalência e\nconjunção, respectivamente, como:\n( NIMP ) ( )\n( NEQ ) ( )\n( NAND ) ( )\nAssinale alternativa que representa um conjunto de conectivos completo.",
    "alternativas": [
      "A) {NIMP}",
      "B) {NEQ}",
      "C) {NAND}",
      "D) {NIMP, NEQ}",
      "E) Nenhum é completo."
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "Inteligência Artificial",
    "subarea": "Conjuntos e Lógica Fuzzy",
    "dificuldade": "Média",
    "gabarito": "C",
    "solucao": "Um conjunto de conectivos lógicos é considerado completo se for possível expressar todas as operações lógicas básicas (conjunção, disjunção e negação) usando apenas os conectivos desse conjunto. O conectivo NAND, também conhecido como 'não e', é um operador lógico que é funcionalmente completo por si só. Isso significa que qualquer expressão lógica pode ser construída usando apenas o operador NAND. Por exemplo, a negação de A (¬A) pode ser expressa como A NAND A, a conjunção A ∧ B pode ser expressa como (A NAND B) NAND (A NAND B), e a disjunção A ∨ B pode ser expressa como (A NAND A) NAND (B NAND B). Portanto, a alternativa correta é C) {NAND}."
  },
  {
    "edicao": 2008,
    "id": "2008-66",
    "numero": 66,
    "enunciado": "Analise as seguintes afirmativas e assinale a alternativa INCORRETA.",
    "alternativas": [
      "A) 1 + 2 + 22 + 2 3 + ... + 2 n = 2 n+1 - 1 , para todo n .\np",
      "B) C n p 1 C n r , para todo n e p .\np r\nr 0",
      "C) Para todo conjunto A , ( A) denota o conjunto de todos os subconjuntos de A . Se\nA B , então ( A) ( B) .",
      "D) Se A , A , ..., A são conjuntos disjuntos, então\n1 2 r\nr\n| A A ... A B | | B | (| A B |)\n1 2 r i\ni 1",
      "E) Se a afirmativa (A) é falsa, então a afirmativa (D) é falsa."
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "Matemática Discreta",
    "subarea": "Combinatória",
    "dificuldade": "Média",
    "gabarito": "D",
    "solucao": "Vamos analisar cada uma das alternativas para identificar qual delas é incorreta:\n\nA) A expressão 1 + 2 + 2^2 + 2^3 + ... + 2^n = 2^(n+1) - 1 é uma fórmula conhecida para a soma de uma progressão geométrica de razão 2. Esta expressão está correta.\n\nB) A expressão C(n, p) = C(n, r) para todo n e p, onde p + r = n, é uma identidade combinatória conhecida e está correta.\n\nC) Se A está contido em B, então o conjunto das partes de A, denotado por P(A), está contido no conjunto das partes de B, P(B). Esta afirmação está correta.\n\nD) A expressão |A1 ∪ A2 ∪ ... ∪ Ar ∪ B| = |B| + Σ|Ai ∩ B|, para conjuntos disjuntos A1, A2, ..., Ar, está incorreta. A fórmula correta para a união de conjuntos disjuntos não inclui a soma das interseções com B, mas sim a soma dos tamanhos dos conjuntos disjuntos mais o tamanho de B, sem interseções. Portanto, esta alternativa é a incorreta.\n\nE) Esta é uma afirmação condicional que não pode ser avaliada diretamente sem contexto adicional. No entanto, a correção ou incorreção de D não depende de A, então a relação condicional não afeta a veracidade de D.\n\nPortanto, a alternativa incorreta é a D."
  },
  {
    "edicao": 2008,
    "id": "2008-67",
    "numero": 67,
    "enunciado": "Em relação ao conjunto parcialmente ordenado A ({a, b, c, d , e, f }, ) , representado pelo\ndiagrama de Hasse abaixo, analise as seguintes afirmativas.\nI. A estrutura A não é reticulado.\nII. Os majorantes de {b, c} são os elementos d e e .\nIII. O ínfimo de {d , e} é o elemento a .\nIV. A estrutura é um reticulado limitado com topo sendo o elemento a e o fundo f.\nV. A estrutura A possui apenas dois subconjuntos de 4 elementos totalmente ordenados:\n{a, b, d , f } e {a, c, e, f } .\nA análise permite concluir que",
    "alternativas": [
      "A) somente III e IV são falsas.",
      "B) somente I e II são falsas.",
      "C) somente V é falsa.",
      "D) somente IV é verdadeira.",
      "E) somente I é verdadeira."
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "Matemática Discreta",
    "subarea": "Teoria dos Conjuntos e Relações",
    "dificuldade": "Média",
    "gabarito": "E",
    "solucao": "Para resolver a questão, precisamos analisar cada afirmativa em relação ao diagrama de Hasse de um conjunto parcialmente ordenado A. \n\nI. A estrutura A não é reticulado. - Um reticulado é um conjunto parcialmente ordenado em que todo par de elementos tem um supremo (menor majorante) e um ínfimo (maior minorante). Sem o diagrama de Hasse, não podemos afirmar com certeza, mas a afirmativa I sugere que A não possui essas propriedades para todos os pares de elementos. Portanto, I pode ser verdadeira.\n\nII. Os majorantes de {b, c} são os elementos d e e. - Majorantes de um conjunto são elementos que são maiores ou iguais a todos os elementos do conjunto. Se d e e são os únicos elementos maiores que b e c, então II é verdadeira.\n\nIII. O ínfimo de {d, e} é o elemento a. - O ínfimo é o maior elemento que é menor ou igual a todos os elementos do conjunto. Se a é o único elemento menor que d e e, então III é verdadeira.\n\nIV. A estrutura é um reticulado limitado com topo sendo o elemento a e o fundo f. - Em um reticulado limitado, o topo é o maior elemento e o fundo é o menor elemento. Se a é o menor elemento e f é o maior, então IV é falsa.\n\nV. A estrutura A possui apenas dois subconjuntos de 4 elementos totalmente ordenados: {a, b, d, f} e {a, c, e, f}. - Se houver mais de dois subconjuntos de 4 elementos totalmente ordenados, então V é falsa.\n\nCom base na análise, a única afirmativa que pode ser verdadeira é I, portanto, a alternativa correta é E."
  },
  {
    "edicao": 2008,
    "id": "2008-68",
    "numero": 68,
    "enunciado": "Analise as seguintes relações sobre o conjunto A {1, 2, 3} :\nR {(2,1), (3,1), (3, 3)} , S {(1,1), (2, 2)} , T {(1, 2), (1, 3)} e U {(2, 3), (3, 2)} .\nI. Somente S é reflexiva.\nII. Somente U não é transitivas.\nIII. Somente U é simétrica.\nIV. Nenhuma delas é antissimétrica.\nV. R S é reflexiva, antissimétrica e transitiva.\nVI. S U não é reflexiva, mas é transitiva e simétrica.\nVII. R S T é reflexiva e simétrica, mas não é transitiva.\nA análise permite concluir que são VERDADEIRAS",
    "alternativas": [
      "A) somente as afirmativas II, V e VI.",
      "B) somente as afirmativas I, II, e VII.",
      "C) somente as afirmativas III, V e IV.",
      "D) somente as afirmativas I, III, VI, VII.",
      "E) todas as afirmativas."
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "Matemática Discreta",
    "subarea": "Relações e suas Propriedades",
    "dificuldade": "Média",
    "gabarito": "A",
    "solucao": "Para resolver a questão, precisamos analisar cada uma das relações R, S, T e U, e suas combinações, de acordo com as propriedades de reflexividade, simetria, antissimetria e transitividade.\n\nI. Somente S é reflexiva: Uma relação é reflexiva se, para todo elemento a em A, (a, a) está na relação. S contém (1,1) e (2,2), mas falta (3,3), então S não é reflexiva. Portanto, a afirmativa I é falsa.\n\nII. Somente U não é transitiva: Uma relação é transitiva se, sempre que (a, b) e (b, c) estão na relação, (a, c) também está. U contém (2,3) e (3,2), mas não contém (2,2) ou (3,3), então U não é transitiva. As outras relações também não são transitivas, mas a afirmativa está correta ao afirmar que U não é transitiva. Portanto, a afirmativa II é verdadeira.\n\nIII. Somente U é simétrica: Uma relação é simétrica se, sempre que (a, b) está na relação, (b, a) também está. U contém (2,3) e (3,2), então é simétrica. As outras relações não são simétricas. Portanto, a afirmativa III é verdadeira.\n\nIV. Nenhuma delas é antissimétrica: Uma relação é antissimétrica se, sempre que (a, b) e (b, a) estão na relação, então a = b. R contém (2,1) e (1,2) não está na relação, então não é antissimétrica. S é antissimétrica, pois não contém pares (a, b) e (b, a) com a ≠ b. Portanto, a afirmativa IV é falsa.\n\nV. R S é reflexiva, antissimétrica e transitiva: A composição R S não é reflexiva, pois não contém (3,3). Ela também não é transitiva, pois não contém (2,2) ou (3,3). Portanto, a afirmativa V é falsa.\n\nVI. S U não é reflexiva, mas é transitiva e simétrica: A composição S U não é reflexiva, pois não contém (3,3). Ela é simétrica, pois contém pares (2,3) e (3,2). Ela não é transitiva, pois não contém (2,2) ou (3,3). Portanto, a afirmativa VI é falsa.\n\nVII. R S T é reflexiva e simétrica, mas não é transitiva: A composição R S T não é reflexiva, pois não contém (3,3). Ela não é simétrica, pois não contém pares (a, b) e (b, a) para todos os elementos. Portanto, a afirmativa VII é falsa.\n\nPortanto, a única alternativa correta é a A, que afirma que somente as afirmativas II, V e VI são verdadeiras."
  },
  {
    "edicao": 2008,
    "id": "2008-69",
    "numero": 69,
    "enunciado": "Sobre o conjunto X { A, B, C , D, E} , em que A { } , B {a, b} , C {b, c} , B {a, b, c} e\nF {a, b, c, d } , fazem-se as seguintes afirmativas:\nI. X é fechado para a operação de união de conjuntos.\nII. X é fechado para a operação de interseção de conjuntos.\nIII. X não é fechado para a operação de complementação de conjuntos.\nIV. ( X , ) , em que é a operação de união de conjuntos, é um monóide não comutativo.\nV. ( X , ) , em que é a operação de interseção de conjuntos, não é um monóide,\nporque X não apresenta elemento neutro para .\nSão CORRETAS",
    "alternativas": [
      "A) apenas as afirmativas I, II e III.",
      "B) apenas as afirmativas I e IV.",
      "C) apenas as afirmativas II e V.",
      "D) apenas as afirmativas I e III.",
      "E) todas as afirmativas."
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "Inteligência Artificial",
    "subarea": "Conjuntos e Lógica Fuzzy",
    "dificuldade": "Média",
    "gabarito": "D",
    "solucao": "Vamos analisar cada afirmativa:\n\nI. X é fechado para a operação de união de conjuntos.\nPara verificar se X é fechado para a operação de união, precisamos garantir que a união de quaisquer dois conjuntos de X resulte em um conjunto que também pertence a X. Considerando os conjuntos fornecidos, a união de quaisquer dois conjuntos resulta em um conjunto que está presente em X. Portanto, a afirmativa I é correta.\n\nII. X é fechado para a operação de interseção de conjuntos.\nPara verificar se X é fechado para a operação de interseção, precisamos garantir que a interseção de quaisquer dois conjuntos de X resulte em um conjunto que também pertence a X. No entanto, a interseção de C {b, c} e F {a, b, c, d} resulta em {b, c}, que não está listado como um conjunto em X. Portanto, a afirmativa II é incorreta.\n\nIII. X não é fechado para a operação de complementação de conjuntos.\nA complementação de um conjunto em relação a um universo deve resultar em um conjunto que também está em X para que X seja fechado para complementação. Considerando que o universo não está definido explicitamente, é seguro afirmar que X não é fechado para complementação, pois não podemos garantir que o complemento de qualquer conjunto em X resultará em outro conjunto de X. Portanto, a afirmativa III é correta.\n\nIV. (X, U), em que U é a operação de união de conjuntos, é um monóide não comutativo.\nUm monóide requer a presença de um elemento neutro e a associatividade da operação. A união de conjuntos é comutativa e associativa, e o conjunto vazio A { } serve como elemento neutro, pois A U qualquer conjunto B resulta em B. Portanto, a afirmativa IV é incorreta, pois a operação é comutativa.\n\nV. (X, ∩), em que ∩ é a operação de interseção de conjuntos, não é um monóide, porque X não apresenta elemento neutro para ∩.\nPara a operação de interseção, o elemento neutro seria o conjunto universal, que não está presente em X. Portanto, a afirmativa V é correta.\n\nCom base na análise, as afirmativas corretas são I e III, correspondendo à alternativa D."
  },
  {
    "edicao": 2008,
    "id": "2008-70",
    "numero": 70,
    "enunciado": "Considere que 14 cópias de uma mesma tarefa devem ser executadas paralelamente por\nagentes idênticos, organizados em dois sistemas multiagentes, SMA-A e SMA-B. O\nsistema SMA-A é formado por 16 agentes e o sistema SMA-B é formado por 32 agentes.\nSeja C (m, p) a combinação de m elementos p a p .\nAssinale fórmula que representa a quantidade de maneiras diferentes de escolher os\nagentes, no caso em que pelo menos uma tarefa deve ser executada por algum agente\ndo sistema SMA-B.",
    "alternativas": [
      "A) C (48,14) C (16,14)",
      "B) C (32,1) C (47,13)",
      "C) C (48,1) C (16,13)",
      "D) C (32,1) C (48,13)",
      "E) C (32,1) C (48,1) C (32,14)"
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "Inteligência Artificial",
    "subarea": "Agentes Inteligentes",
    "dificuldade": "Média",
    "gabarito": "B",
    "solucao": "Para resolver essa questão, precisamos calcular a quantidade de maneiras de escolher agentes para executar as 14 tarefas, garantindo que pelo menos uma delas seja executada por um agente do sistema SMA-B. Primeiro, calculamos o total de maneiras de distribuir as 14 tarefas entre os 48 agentes (16 do SMA-A e 32 do SMA-B), que é dado por C(48,14). Depois, calculamos o número de maneiras de distribuir as 14 tarefas apenas entre os 16 agentes do SMA-A, que é C(16,14). A diferença entre essas duas quantidades nos dá o número de maneiras de distribuir as tarefas de forma que pelo menos uma seja executada por um agente do SMA-B: C(48,14) - C(16,14). No entanto, a questão pede uma fórmula que represente a quantidade de maneiras diferentes de escolher os agentes, no caso em que pelo menos uma tarefa deve ser executada por algum agente do sistema SMA-B. A alternativa correta é a que representa essa situação, que é a alternativa B: C(32,1) C(47,13). Essa fórmula representa a escolha de pelo menos um agente do SMA-B (C(32,1)) e a escolha dos outros 13 agentes entre os restantes 47 (C(47,13))."
  },
  {
    "edicao": 2007,
    "id": "2007-01",
    "numero": 1,
    "enunciado": "A quantidade de soluções inteiras da equação x + y + z = 20, com x 2, y 2\n≥ ≥\n≥",
    "alternativas": [
      "(a) 120",
      "(b) 20",
      "(c) 231",
      "(d) 132",
      "(e) Essa equação não tem solução inteira."
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-02",
    "numero": 2,
    "enunciado": " ",
    "alternativas": [
      "(a) C (48, 8) C (40, 12)\n×",
      "(b) A(48, 8) A(40, 12)\n×",
      "(c) C (46, 8) C (40, 12)\n×",
      "(d) A(46, 8) A(40, 12)\n×",
      "(e) A(46, 8) C (40, 12)\n×"
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-03",
    "numero": 3,
    "enunciado": " ",
    "alternativas": [
      "(a) as linhas de A são vetores linearmente independentes.",
      "(b) o sistema Ax = 0 tem solução única.",
      "(c) o determinante da transposta de A é diferente de zero.",
      "(d) o sistema Ax = b tem solução única para qualquer vetor n-dimensional b.",
      "(e) dois-a-dois os vetores-coluna de A não podem ser colineares."
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-04",
    "numero": 4,
    "enunciado": "É CORRETO afirmar",
    "alternativas": [
      "(a) que os autovalores de uma matriz não-singular são positivos.",
      "(b) que, para uma matriz A, λ é autovalor de A se, e somente se, λ2 é um autovalor\nde A2 .",
      "(c) que, se uma matriz é igual a sua inversa, então seus autovalores são iguais a 1.",
      "(d) que, se u e v são vetores não-nulos de Rn, então u é autovetor da matriz uvT .",
      "(e) que, se uma matriz quadrada tem entradas reais, então seus autovalores são núme-\nros reais."
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-05",
    "numero": 5,
    "enunciado": " \n−",
    "alternativas": [
      "(a) (3, 4)",
      "(b) (3, 4)\n−",
      "(c) ( 4, 3)\n−",
      "(d) (4, 3)",
      "(e) ( 3, 4)\n− −"
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-06",
    "numero": 6,
    "enunciado": "Um trabalho de monitoramento do fluxo de acesso ao provedor de rede de deter-\nR(t) = 100(1 0, 0001t2 ) usuários/minuto,\n−\nQuando ocorre o pico no fluxo de acesso à rede ?\n•\nQual é a estimativa para o número de usuários que estão acessando a rede durante\n•\na hora monitorada ?",
    "alternativas": [
      "(a) Das 20 : 30 às 21 : 30 horas; mais de 5.000 usuários.",
      "(b) Das 20 : 30 às 21 : 30 horas; menos de 5.000 usuários.",
      "(c) Das 19 : 30 às 20 : 30 horas; mais de 5.000 usuários.",
      "(d) Das 19 : 30 às 20 : 30 horas; menos de 5.000 usuários.",
      "(e) Nenhuma das aproximações contém as respostas."
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-07",
    "numero": 7,
    "enunciado": "Considere a função f : R R definida pela expressão:\n→\nx2 , se x 0,\nf (x) = (cid:26) x2 + 1, se x >≤ 0,",
    "alternativas": [
      "(a) lim x→0− f ′ (x) = lim x→0+ f ′(x) mas f ′ (0) não existe.",
      "(b) lim x→0− f (x) = 0 e lim x→0+ f (x) = 1 = f (0).",
      "(c) f (x) é contínua mas não é diferenciável.",
      "(d) f ′ (x) é decrescente e f (x) 0 se x ( , 0).\n≥ ∈ −∞",
      "(e) lim x→∞ f (x) = e lim x→−∞ f ′(x) = + .\n∞ ∞"
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-08",
    "numero": 8,
    "enunciado": "Assinale a alternativa que apresenta o comprimento do segmento de reta de-",
    "alternativas": [
      "(a) 10\n3",
      "(b) 20 √6\n3",
      "(c) 20\n3",
      "(d) 10 √3\n3",
      "(e) 20 √3\n3"
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-09",
    "numero": 9,
    "enunciado": "Quatro retas do plano cartesiano identificadas por l1 , l2 e r1 , r2 definem, com os\nl1 l2 (retas paralelas) e r1 r2 ;\n• k k\nl1 e l2 são perpendiculares a reta t definida por 4x + 3y = 0 (isto é, l1 t e l2 t);\n• ⊥ ⊥\n•\nr1 e r2 têm coeficiente angular iguais a m\nr\n= − 43 .",
    "alternativas": [
      "(a) 3x 4y 12 = 0 e 3x + 4y 12 = 0.\n− ± ±",
      "(b) 3x + 4y 12 = 0 e 3x 4y 12 = 0.\n± − ±",
      "(c) 3x 4y 24 = 0 e 3x + 4y 24 = 0.\n− ± ±",
      "(d) 3x 4y 24 = 0 e 3x + 4y 24 = 0.\n− − ± − ±",
      "(e) Nenhuma das respostas está correta."
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-10",
    "numero": 10,
    "enunciado": "Dados os conceitos de coerência e completeza de um sistema dedutivo, analise\nI. Existe pelo menos um sistema de dedução coerente e completo para a Lógica\nProposicional.\nII. Todo sistema de dedução para a Lógica de Predicados de Primeira Ordem que é\ncompleto também é coerente.\nIII. Existe pelo menos um sistema de dedução coerente e completo para a Lógica de\nPredicados de Primeira Ordem.",
    "alternativas": [
      "(a) nenhuma das afirmativas.",
      "(b) somente as afirmativas I e II.",
      "(c) somente as afirmativas I e III.",
      "(d) somente as afirmativas II e III.",
      "(e) todas as afirmativas."
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-11",
    "numero": 11,
    "enunciado": "Considere a seguinte linguagem de primeira ordem:\nconstantes: a, b\n•\nvariáveis: x, y\n•\npredicados unários: P\n•\npredicados binários: R\n•",
    "alternativas": [
      "(a) = (b) = 0\n• I I\n(P ) = n n < 4\n• I { | }\n(R) = (x, y) x < y\n• I { | }\nI. P (a)\nII. x, y : R(x, y) R(y, x)\n∀ →\nIII. x : R(x, a)\n∃\nI\n(a) somente a fórmula I.",
      "(b) somente as fórmulas I e II.",
      "(c) somente a fórmula III.",
      "(d) nenhuma das fórmulas.",
      "(e) todas as fórmulas."
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-12",
    "numero": 12,
    "enunciado": " \n∗ ∗\n∗",
    "alternativas": [
      "(a) (α β γ ) (α ( β ) ( γ )) (( α) β ( γ )) (( α) ( β ) γ )\n∨ ∨ ∧ ∨ ¬ ∨ ¬ ∧ ¬ ∨ ∨ ¬ ∧ ¬ ∨ ¬ ∨",
      "(b) (( α) ( β ) ( γ )) (α ( β ) ( γ )) (( α) β ( γ )) (( α) ( ( β )) γ )\n¬ ∧ ¬ ∧ ¬ ∨ ∧ ¬ ∧ ¬ ∨ ¬ ∧ ∧ ¬ ∨ ¬ ∧ ¬ ¬ ∧",
      "(c) (α ( β ) ( γ )) (( α) β ( γ )) (( α) ( β ) γ )\n∨ ¬ ∨ ¬ ∧ ¬ ∨ ∨ ¬ ∧ ¬ ∨ ¬ ∨",
      "(d) (( α) ( β ) ( γ )) (α ( β ) ( γ )) (( α) β ( γ )) (( α) ( β ) γ )\n¬ ∧ ¬ ∧ ¬ ∨ ∧ ¬ ∧ ¬ ∨ ¬ ∧ ∧ ¬ ∨ ¬ ∧ ¬ ∧",
      "(e) Nenhuma destas respostas é correta."
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-13",
    "numero": 13,
    "enunciado": "Um conjunto C , subconjunto de um conjunto A, é decidível se existe um pro-\n∈ ∈ ∈",
    "alternativas": [
      "(a) O conjunto das fórmulas satisfatíveis da lógica clássica proposicional.",
      "(b) O conjunto dos teoremas da lógica clássica proposicional.",
      "(c) O conjunto dos teoremas da lógica clássica de primeira ordem.",
      "(d) O conjunto das fórmulas da lógica clássica de primeira ordem.",
      "(e) O conjunto das tautologias da lógica clássica proposicional."
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-14",
    "numero": 14,
    "enunciado": "Analise as seguintes afirmativas e assinale a alternativa CORRETA.",
    "alternativas": [
      "(a) ,\n{{∅}} ∈ {∅ {∅}}",
      "(b) Para todo conjunto A, (A) denota o conjunto de todos os subconjuntos de A.\nP\nSe a e B são conjuntos tais que a B , então (a) (B )\n∈ P ⊆ P",
      "(c) O conjunto n109 : n N é infinito enumerável.\n{ ∈ }",
      "(d) Se A, B e C são três conjuntos, então A (B C ) = (A B ) C .\n− − − −",
      "(e) Nenhuma das afirmativas anteriores é correta."
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-15",
    "numero": 15,
    "enunciado": "Analise as seguintes alternativas e assinale a que apresenta uma afirmativa",
    "alternativas": [
      "(a) Se A1 , A2 , , A\nr\nsão conjuntos disjuntos, então A1 A\nr\nB = B +\nr ( A · · B· ). | ∪ · · · ∪ ∪ | | |\ni=1 | i − |",
      "(b) P1 + 2 + 22 + 23 + + 2n = 2n+1 1, para todo n N.\n· · · − ∈",
      "(c) C n+p+1 = p C n+r , para todo n N e p N.\np r=0 r ∈ ∈",
      "(d) Sejam k PN e A N. Se k A e (n A, n k n + 1 A), então A = N.\n∈ ⊆ ∈ ∈ ≥ ⇒ ∈",
      "(e) Existe exatamente uma alternativa falsa dentre as anteriores."
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-16",
    "numero": 16,
    "enunciado": "Analise as seguintes afirmativas.\nI. Seja A = (X ) o conjunto dos subconjuntos de um conjunto X . A relação\nP\n= (a, a′ ) : a A, a′ A, a a′\n(cid:22) { ∈ ∈ ⊆ }\né uma relação de ordem parcial.\nII. Se R é uma relação binária simétrica e anti-simétrica, então R = .\n∅\nIII. Seja R uma relação reflexiva em um conjunto A. Então, R é uma relação de\nequivalência se e somente se ((a, b) R e (b, c) R (c, a) R).\n∈ ∈ ⇒ ∈\nIV. Se F e G são duas funções inversíveis, então G F é uma função inversível.\n◦",
    "alternativas": [
      "(a) 0 (zero)",
      "(b) 1 (uma)",
      "(c) 2 (duas)",
      "(d) 3 (três)",
      "(e) 4 (quatro)"
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-17",
    "numero": 17,
    "enunciado": "Sejam R e S relações em um conjunto A o qual contém pelo menos três elementos.\nI. Se R e S são simétricas, então R S é simétrica.\n∩\nII. Se R e S são simétricas, então R S é simétrica.\n∪\nIII. Se R e S são reflexivas, então R S é reflexiva.\n∩\nIV. Se R e S são reflexivas, então R S é reflexiva.\n∪",
    "alternativas": [
      "(a) apenas a afirmativa I.",
      "(b) apenas as afirmativas I e II.",
      "(c) apenas as afirmativas II e IV.",
      "(d) apenas as afirmativas III e IV.",
      "(e) todas as afirmativas."
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-18",
    "numero": 18,
    "enunciado": " ",
    "alternativas": [
      "(a) 32",
      "(b) 21",
      "(c) 14",
      "(d) 128",
      "(e) 64"
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-19",
    "numero": 19,
    "enunciado": "Suponha que o tempo de execução de um programa seja dado por uma variável",
    "alternativas": [
      "(a) 0,50",
      "(b) 0,45",
      "(c) 0,40",
      "(d) 0,55",
      "(e) 0,60"
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-20",
    "numero": 20,
    "enunciado": "Suponha agora que o programa é executado e se aguarda até 50 minutos para",
    "alternativas": [
      "(a) 55",
      "(b) 62,5",
      "(c) 60",
      "(d) 49,5",
      "(e) 67,5\nQUESTÕ ES DE FUNDAMENTOS DA COMPUTAÇ Ã O"
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-21",
    "numero": 21,
    "enunciado": "Um processador tem a seguinte hierarquia de memória: uma cache com latência",
    "alternativas": [
      "(a) 10%",
      "(b) 5%",
      "(c) 50%",
      "(d) 1%",
      "(e) 2%"
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-22",
    "numero": 22,
    "enunciado": "Observe o circuito lógico abaixo.",
    "alternativas": [
      "(a) A + B C\n·",
      "(b) A",
      "(c) B",
      "(d) A B C\n· ·",
      "(e) A + B C"
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-23",
    "numero": 23,
    "enunciado": "Seja T uma árvore AVL vazia. Supondo que os elementos 5, 10, 11, 7, 9, 3 e 6",
    "alternativas": [
      "(a) 3, 5, 6, 7, 9, 10 e 11.",
      "(b) 7, 5, 3, 6, 10, 9 e 11.",
      "(c) 9, 10, 7, 6, 11, 5 e 3.",
      "(d) 11, 10, 9, 7, 6, 5 e 3.",
      "(e) 3, 6, 5, 9, 11, 10 e 7."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-24",
    "numero": 24,
    "enunciado": "Considere um arquivo texto que contenha uma mensagem de 10.000 caracteres\nI. O comprimento médio dos códigos para os referidos caracteres é 1, 2.\nII. Se forem utilizados todos os pares possíveis de símbolos para a construção da\nárvore de Huffman, então o comprimento médio dos códigos para os referidos\npares é menor que 1, 2 por caractere.\nIII. A codificação de Huffman a partir de todos os pares possíveis de caracteres sempre\nproduz códigos de menor comprimento médio.",
    "alternativas": [
      "(a) apenas a afirmativa I é verdadeira.",
      "(b) apenas as afirmativas I e II são verdadeiras.",
      "(c) apenas as afirmativas I e III são verdadeiras.",
      "(d) apenas as afirmativas II e III são verdadeiras.",
      "(e) todas as afirmativas são verdadeiras."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-25",
    "numero": 25,
    "enunciado": "Considerando as diferenças existentes entre a execução de um algoritmo sequen-\nI. Somente na execução sequencial de um algoritmo existe a possibilidade de ocorrer\num dead lock.\nII. Um algoritmo sequencial apresenta mais de uma execução possível para uma dada\nentrada.\nIII. Um algoritmo distribuído tem sua complexidade medida pela quantidade de men-\nsagens transmitidas durante sua execução.\nIV. A execução de um algoritmo distribuído pode ser não determinística.",
    "alternativas": [
      "(a) todas as afirmativas são falsas.",
      "(b) todas as afirmativas são verdadeiras.",
      "(c) apenas as afirmativas I e II são verdadeiras.",
      "(d) apenas as afirmativas I e IV são verdadeiras.",
      "(e) apenas a afirmativa IV é verdadeira."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-26",
    "numero": 26,
    "enunciado": "Seja a linguagem formal L = anb2n c, n 0 . Analise as seguintes assertivas.\n{ ≥ }\nI. L é uma linguagem livre de contexto.\nII. A gramática G = ( S, X , a, b, c , S X c, X aX bb ǫ , S ) gera a linguagem L.\n{ } { } { → → | }\nIII. L não pode ser reconhecida por um autˆomato com pilha.",
    "alternativas": [
      "(a) apenas as assertivas I e II.",
      "(b) apenas as assertivas I e III.",
      "(c) apenas as assertivas II e III.",
      "(d) todas as assertivas.",
      "(e) nenhuma das assertivas."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-27",
    "numero": 27,
    "enunciado": "Assinale a alternativa que apresenta a afirmativa FALSA.",
    "alternativas": [
      "(a) Uma linguagem L é aceita por uma Máquina de Turing não determinística com\nk fitas, m dimensões, n cabeçotes de leitura e gravação por fita se, e somente se,\nela é aceita por uma Máquina de Turing determinística com uma fita infinita em\napenas um sentido e um cabeçote de leitura e gravação.",
      "(b) Um problema é dito ser decidível se a linguagem associada a esse problema é\nrecursiva.",
      "(c) O conjunto de todos os programas que páram para uma dada entrada é um\nconjunto recursivo mas não recursivamente enumerável.",
      "(d) Uma função é parcialmente computável se, e somente se, ela pode ser obtida a\npartir de funções iniciais (por exemplo, sucessor, zero e pro jeção) por um número\nfinito de aplicações de composição, recursão primitiva e minimalização.",
      "(e) Uma Máquina de Turing Universal U toma como argumentos uma descrição de\numa Máquina de Turing qualquer M e uma entrada x para M , e executa as\nmesmas operações sobre x que seriam executadas por M , ou seja, U simula M\nsobre x."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-28",
    "numero": 28,
    "enunciado": "Considere o seguinte enunciado e as possibilidades de sua complementação.\nI. opera com fórmulas contendo apenas quantificadores existenciais.\nII. é capaz de reduzir fórmulas quantificadas à suas correspondentes formas clausais.\nIII. opera sobre fórmulas em forma clausal pelo corte de literais de sinais opostos.\nIV. opera sobre fórmulas em forma clausal pelo corte de literais de mesmo sinal.\nV. produz deduções que evitam a construção de árvores de dedução lineares.",
    "alternativas": [
      "(a) apenas o item II.",
      "(b) apenas o item III.",
      "(c) apenas o item IV.",
      "(d) apenas os itens I e II.",
      "(e) apenas os itens III e V."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-29",
    "numero": 29,
    "enunciado": "Analise as seguintes afirmativas.\nI. Encapsulamento é a capacidade de uma operação atuar de modos diversos em\nclasses diferentes.\nII. Polimorfismo é o compartilhamento de atributos e métodos entre classes com base\nem um relacionamento hierárquico.\nIII. Herança consiste no processo de ocultação dos detalhes internos de implementação\nde um ob jeto.\nIV. Sobreposição é a redefinição das funções de um método herdado. Os métodos\napresentam assinaturas iguais.\nV. Em JAVA, todos os métodos numa classe abstrata devem ser declarados como\nabstratos.",
    "alternativas": [
      "(a) apenas a afirmativa IV está correta.",
      "(b) apenas as afirmativas III e IV estão corretas.",
      "(c) apenas as afirmativas I, IV e V estão corretas.",
      "(d) apenas as afirmativas I, III e V estão corretas.",
      "(e) todas as afirmativas são falsas."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-30",
    "numero": 30,
    "enunciado": "Suponha que tenhamos à nossa disposição um algoritmo Mult que efetua a\n× ×\nENTRADA: vetor p[0], p[1], . . . , p[n], um inteiro positivo m.\nQUESTÃ O: existe uma sequência de multiplicações de duas matrizes com\no algoritmo Mult que produz o resultado de A1 A2 A n, em que cada A i,\n· · ·\npara todo i 1, 2, . . . , n , é uma matriz de dimensões p[i 1] p[i], com\n∈ { } − ×\nm multiplicações de escalares no máximo?\nI. O algoritmo abaixo demonstra que MULTMAT está na classe de problemas P .\nChamada: MultMat(p, m)\n1: q Q(p, 0, n)\n←\n2: se q m então\n≤\n3: retorna “Sim”\n4: retorna “Não”\nChamada: Q(p, i, j )\n5: se i = j então\n6: retorna 0\n7: q\n← ∞\n8: para k i, i + 1, , j 1 faça\n← · · · −\n9: r Q(p, i, k) + Q(p, k + 1, j ) + p[i 1]p[k]p[j ]\n← −\n10: se r < q então\n11: q r\n←\n12: retorna q\nII. MULTMAT está na classe de problemas N P .\nIII. Se I e II são corretas, então P = N P .",
    "alternativas": [
      "(a) Somente a afirmativa I.",
      "(b) Somente a afirmativa II.",
      "(c) Somente a afirmativa III.",
      "(d) Somente as afirmativas II e III.",
      "(e) Somente as afirmativas I, II e III."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-31",
    "numero": 31,
    "enunciado": "Considere o problema do caixeiro viajante, definido como se segue.\nij\n≥\n∈ 6\n∈ \\{ }\nI. Todo percurso fechado obtido com esse algoritmo tem distˆancia mínima.\nII. O problema do caixeiro via jante pode ser resolvido com um algoritmo de com-\nplexidade linear no número de cidades.\nIII. Dado que todo percurso fechado corresponde a uma permutação das cidades,\nexiste um algoritmo de complexidade exponencial no número de cidades para o\nproblema do caixeiro via jante.",
    "alternativas": [
      "(a) I é falsa e III é correta.",
      "(b) I, II e III são corretas.",
      "(c) apenas I e II são corretas.",
      "(d) apenas I e III são falsas.",
      "(e) I, II e III são falsas."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-32",
    "numero": 32,
    "enunciado": "Observe as funções representadas no gráfico abaixo.\n3\n2\n2\n1\n1\n0\n5\n0\n5\n0\n5\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\nf\ng\nh\ni (\n(\n(\n(\nn\nn\nn\nn\n)\n)\n)\n)\n5 1 0 1 5 2 0",
    "alternativas": [
      "(a) f (n) = O(h(n)) e i(n) = Ω(g(n)).",
      "(b) f (n) = Θ(h(n)) e i(n) = Ω(h(n)).",
      "(c) g(n) = O(i(n)) e h(n) = Ω(g(n)).",
      "(d) g(n) = O(i(n)), i(n) = O(f (n)) e, portanto, g(n) = O(f (n)).",
      "(e) h(n) = Ω(i(n)), logo, i(n) = O(h(n))."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-33",
    "numero": 33,
    "enunciado": "Seja L =< r1 , . . . , r\nn\n> uma lista qualquer de inteiros não necessariamente",
    "alternativas": [
      "(a) Existe um algoritmo determinístico ótimo de complexidade 0(n) para selecionar\no maior elemento de L.",
      "(b) Existe um algoritmo determinístico de complexidade O(n lg n) para selecionar,\npara 1 i n, o i-ésimo menor elemento de L.\n≤ ≤",
      "(c) Se existe um algoritmo linear para selecionar o i-ésimo menor elemento de L,\nentão, usando esse algoritmo, é possível pro jetar um algoritmo linear para ordenar\nL em ordem não crescente.",
      "(d) Existe um algoritmo linear para determinar o terceiro maior elemento de L.",
      "(e) Existe um algoritmo que, percorrendo uma única vez L, pode determinar o menor\ne o maior elemento de L."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-34",
    "numero": 34,
    "enunciado": "Seja V =< v1 , . . . , v\nn\n> uma lista qualquer de inteiros distintos que se deseja\nI. Considere o algoritmo Quicksort. Suponha uma execução do algoritmo sobre V tal\nque a cada sorteio do pivot, a mediana do (sub)problema em questão é escolhida.\nEntão, a complexidade dessa execução é O(n lg n).\nII. Considere o algoritmo Quicksort. Suponha uma execução do algoritmo sobre V\ntal que a cada sorteio do pivot, os dois subproblemas gerados têm tamanho 1 e 9\n10 10\nrespectivamente do tamanho do (sub)problema em questão. Então, a complexi-\ndade dessa execução é O(n2 ).\nIII. Considere o algoritmo Mergesort. A complexidade do pior caso do algoritmo é\nO(n lg n) e a complexidade do melhor caso (vetor já está ordenado) é O(n).\nIV. Considere o algoritmo Heapsort. A complexidade do pior caso do algoritmo é\nO(n lg n) e a complexidade do melhor caso (vetor já está ordenado) é O(n).\nV. Se para todo i, v é O(n), então a complexidade do algoritmo Bucketsort é O(n).\ni",
    "alternativas": [
      "(a) apenas as afirmativas I e II.",
      "(b) apenas as afirmativas I, II e III.",
      "(c) apenas as afirmativas I, III e V.",
      "(d) apenas as afirmativas III, IV e V.",
      "(e) apenas as afirmativas I e V."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-35",
    "numero": 35,
    "enunciado": "Analise as seguintes afirmativas e assinale a alternativa INCORRETA.",
    "alternativas": [
      "(a) O acesso a setores localizados em sequência em uma mesma trilha de um disco\né mais rápido do que acessar o mesmo número de setores em trilhas diferentes,\ndevido ao menor número tanto de deslocamentos do cabeçote quanto de rotações\nno disco.",
      "(b) Na paginação por demanda, não é necessário que o processo inteiro se encontre\nem memória para execução.",
      "(c) O escalonamento de operações de entrada e saída em um disco rígido pode ser\nutilizado para aumentar o desempenho. Porém, algoritmos como o SSTF (Shortest\nSeek Time First ) podem fazer com que requisições esperem indefinidamente.",
      "(d) O escalonamento de processos por prioridades utiliza múltiplas filas e garante que\ntodos os processos recebam sua fatia de tempo.",
      "(e) O surgimento do conceito de interrupções, juntamente com dispositivos de acesso\nnão-sequencial, foi primordial para a evolução que levou aos sistemas multipro-\ngramados."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-36",
    "numero": 36,
    "enunciado": "Agregações são muito importantes em programação orientada a ob jetos.\nI. Uma agregação é formada por agregado (todo) e componentes (partes).\nII. Uma agregação não é transitiva e, portanto, não pode modelar situações desse\ntipo.\nIII. A simetria é uma das principais características de uma agregação.",
    "alternativas": [
      "(a) as três afirmativas são falsas.",
      "(b) as três afirmativas são verdadeiras.",
      "(c) apenas a afirmativa I é verdadeira.",
      "(d) apenas as afirmativas I e II são verdadeiras.",
      "(e) apenas a afirmativa III é verdadeira."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-37",
    "numero": 37,
    "enunciado": "Multiplicidade é um conceito muito importante na modelagem de classes em",
    "alternativas": [
      "(a) Comprar (Jornal, Leitor)",
      "(b) Casar (Marido, Esposa)",
      "(c) Torcer (Time, Pessoa)",
      "(d) Votar (Prefeito, Eleitor)",
      "(e) Escrever (Coluna, Colunista)"
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-38",
    "numero": 38,
    "enunciado": "Dado o seguinte programa escrito em C:\nint n[] = {7, 8, 9};\nint *p;\np = &n[0];\np++;\nprintf(\"Valor: %d \", *p);\n(*p)++;\nprintf(\"Valor: %d\\n\", *p);",
    "alternativas": [
      "(a) Valor: 7 Valor : 8",
      "(b) Valor: 7 Valor: 7",
      "(c) Valor: 8 Valor: 9",
      "(d) Valor: 7 Valor: 9",
      "(e) Valor: 9 Valor: 9"
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-39",
    "numero": 39,
    "enunciado": "Seja G = (V , E ) um grafo simples e finito, onde V = n e E = m.\n| | | |\nI. Se G é hamiltoniano, então G é 2-conexo em vértices.\nII. Se G é completo, então G é hamiltoniano.\nIII. Se G é 4-regular e conexo, então G é euleriano.\nIV. Se G é bipartite com partições A e B , então G é hamitoniano se, e somente se,\nA = B .\n| | | |\nV. Se G é euleriano, então G é 2-conexo.",
    "alternativas": [
      "(a) apenas os itens I e II.",
      "(b) apenas os itens I e V.",
      "(c) apenas os itens II e III.",
      "(d) apenas os itens III e IV.",
      "(e) apenas os itens IV e V."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-40",
    "numero": 40,
    "enunciado": "Considere os seis grafos G1, G2, G3, G4, G5 e G6 mostrados a seguir.",
    "alternativas": [
      "(a) G1 e G5; G3 e G6",
      "(b) G3 e G4; G2 e G6",
      "(c) G1 e G5",
      "(d) G2 e G4",
      "(e) G3 e G6\nQUESTÕ ES DE TECNOLOGIA DA COMPUTAÇ Ã O"
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-41",
    "numero": 41,
    "enunciado": "Considere um banco de dados com as seguintes tabelas e campos:",
    "alternativas": [
      "(a) Junção de cursos com alunos, seleção de linhas em que nome-curso = “Com-\nputação”, pro jeção do resultado sobre nome-aluno.",
      "(b) Junção de cursos com alunos, pro jeção do resultado sobre nome-aluno, seleção de\nlinhas em que nome-curso = “Computação”.",
      "(c) Seleção de linhas em cursos em que nome-curso = “Computação”, pro jeção do\nresultado sobre código-curso, junção com alunos, pro jeção do resultado sobre\nnome-aluno.",
      "(d) Seleção de linhas em cursos em que nome-curso = “Computação”, junção com\nalunos, pro jeção do resultado sobre nome-aluno.",
      "(e) Seleção de linhas em cursos em que nome-curso = “Computação”, pro jeção do\nresultado sobre nome-aluno."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-42",
    "numero": 42,
    "enunciado": " \ni\nh i\ni i\nh i\nh i\n1. T1 , start 6. T2 , I D, 659, 333 11. T3 , I F, 445, 559\nh i h i h i\n2. T1 , I A, 200, 500 7. T2 , commit 12. T3 , commit\nh i h i h i\n3. T2 , start 8. CHECKPOINT 13. FALHA\nh i\n4. T2 , I B , 400, 500 9. T3 , start\nh i h i\n5. T1 , I C, 560, 340 10. T1 , I E , 2234, 344\nh i h i\nI. A transação T1 deverá ser refeita (REDO).\nII. A transação T1 deverá ser desfeita (UNDO).\nIII. A transação T2 deverá ser refeita (REDO).\nIV. A transação T2 deverá ser desfeita (UNDO).\nV. A transação T3 deverá ser refeita (REDO).\nVI. A transação T3 deverá ser desfeita (UNDO).\nIX. Não é preciso fazer nada com respeito à transação T3 .",
    "alternativas": [
      "(a) VIII, V e II.",
      "(b) VII, IV e VI.",
      "(c) VIII, VI e I.",
      "(d) IX, III e I.",
      "(e) VII, VI e III."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-43",
    "numero": 43,
    "enunciado": "Considere que um Banco de Dados Distribuído siga o protocolo TWO-PHASED",
    "alternativas": [
      "(a) avisar o nodo X para completar a tarefa de qualquer forma porque os demais\nnodos participantes também deverão completar a transação.",
      "(b) avisar o nodo X para não completar a tarefa e avisar os demais nodos participantes\npara completarem a transação.",
      "(c) completar ele mesmo a tarefa que cabia ao nodo X e avisar aos demais nodos\nparticipantes para completarem a transação.",
      "(d) avisar a todos os nodos participantes para completarem a transação.",
      "(e) avisar a todos os nodos participantes para não completarem a transação."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-44",
    "numero": 44,
    "enunciado": "Considere o esquema de relação (A, B , C, D, E , F ).\nR\n{ → → → → }\n{ }\n{ }\n{ }",
    "alternativas": [
      "(a) S 1 e S 2 são chaves candidatas de .\nR",
      "(b) S 2 e S 3 são chaves candidatas de .\nR",
      "(c) S 1 é a única chave candidata de .\nR",
      "(d) S 2 é a única chave candidata de .\nR",
      "(e) S 3 é a única chave candidata de .\nR"
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-45",
    "numero": 45,
    "enunciado": "Considere a gramática regular abaixo onde + e x são operadores unários e\ni j\nn\nB B\n→ | | | |\n→ | | | |",
    "alternativas": [
      "(a) sua tabela SLR tem 2n + 2m + 4 estados.",
      "(b) sua tabela SLR tem 2n + 2m + 4 estados.",
      "(c) sua tabela SLR tem 2(n 2)(m 2) estados.\n− −",
      "(d) sua tabela SLR tem 2(n + 2)(m + 2) estados.",
      "(e) sua tabela SLR tem 2n + 2(m + 2) estados."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-46",
    "numero": 46,
    "enunciado": "Analise as seguintes afirmativas sobre os parsers descendentes recursivos.\nI. São parsers fáceis de implementar para linguagens cuidadosamente pro jetadas,\nporém geralmente exigem transformações em gramáticas originalmente apresen-\ntadas em BNF.\nII. Um dos principais problemas desse tipo de parser é a necessidade de retrocesso nas\nalternativas, o que pode ser resolvido com o uso de um parser recursivo preditivo.\nIII. Para evitar os problemas do parser descendente recursivo, podemos realizar a\nanálise TOP-DOWN usando um parser preditivo não recursivo, ou parser pred-\nitivo tabular. O parser preditivo tabular usa uma tabela baseada nos conjuntos\nFIRST e FOLLOW para decidir qual produção aplicar à entrada.",
    "alternativas": [
      "(a) apenas a afirmativa I está correta.",
      "(b) apenas a afirmativa II está correta.",
      "(c) apenas a afirmativa III está correta.",
      "(d) apenas as afirmativas I, II estão corretas.",
      "(e) as três afirmativas estão corretas."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-47",
    "numero": 47,
    "enunciado": " \n→ | |\n→\n→\n→ |\n→ |\nI. G é SLR(1)\nII. G é LALR(1)\nIII. G é LR(1)",
    "alternativas": [
      "(a) somente as afirmativas I e II são verdadeiras.",
      "(b) somente as afirmativas II e III são verdadeiras.",
      "(c) somente a afirmativa III é verdadeira.",
      "(d) todas as afirmativas são verdadeiras.",
      "(e) nenhuma afirmativa é verdadeira."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-48",
    "numero": 48,
    "enunciado": "Analise as seguintes afirmativas sobre a fase de análise (Front-End) de um com-\nI. O uso de uma variável de ponto flutuante para indexar um vetor causa um erro\ngeralmente detectado na análise semaˆntica.\nII. Parênteses desbalanceados são um erro geralmente detectado pela análise léxica\njá que essa fase lê o arquivo fonte e o traduz para uma sequência de símbolos\nléxicos, ou tokens.\nIII. Para a análise sintática TOP-DOWN usando o método de empilhar e reduzir, é\nnecessário reescrever a gramática eliminando toda recursividade à esquerda.",
    "alternativas": [
      "(a) todas as afirmativas são incorretas.",
      "(b) apenas a afirmativa II é incorreta.",
      "(c) apenas as afirmativas I e II são incorretas.",
      "(d) apenas as afirmativas I e III são incorretas.",
      "(e) apenas as afirmativas II e III são incorretas."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-49",
    "numero": 49,
    "enunciado": "Considere as afirmativas abaixo.\nI. Um terminal raster apresentará o efeito “pisca-pisca” quando a cena é complexa.\nII. Em uma cena composta apenas de ob jetos convexos, a eliminação de superfícies\nocultas restringe-se à remoção das faces posteriores (back faces ).\nIII. No algoritmo do ponto médio para traçado de círculos, se f (x , y ) = r2 x2\nM M\ny2 < 0, o ponto (x , y ) é interior à circunferência. − −\nM M",
    "alternativas": [
      "(a) apenas a afirmativa I é verdadeira.",
      "(b) apenas a afirmativa III é verdadeira.",
      "(c) as três afirmativas são falsas.",
      "(d) as três afirmativas são verdadeiras.",
      "(e) apenas as afirmativas I e II são verdadeiras."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-50",
    "numero": 50,
    "enunciado": "Seja o plano definido pelos pontos A(10, 0, 0), B (0, 10, 0) e C (2, 2, 20). A pro jeção\n− − −",
    "alternativas": [
      "(a) (300/13, 40/13, 100/13)\n−",
      "(b) (150/13, 80/13, 200/13)\n−",
      "(c) (300/13, 80/13, 100/13)\n−",
      "(d) (150/13, 40/13, 200/13)\n−",
      "(e) (300/13, 80/13, 200/13)\n−"
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-51",
    "numero": 51,
    "enunciado": "Dado o seguinte trecho de um programa escrito em C:\nMouse_DENTRO_Envelope_Circular();\nMouse_FORA_Envelope_Circular();",
    "alternativas": [
      "(a) sqrt((xmouse-xcentro)+(ymouse-ycentro))",
      "(b) sqrt(pow(xmouse+xcentro,2)-pow(ymouse+ycentro,2))",
      "(c) sqrt(pow(xmouse-xcentro,2)+pow(ymouse-ycentro,2))",
      "(d) sqrt((xcentro-xmouse)+( ycentro-ymouse))/2",
      "(e) sqrt((xmouse-xcentro)-(ymouse-ycentro))"
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-52",
    "numero": 52,
    "enunciado": "Considere as seguintes afirmativas sobre as facilidades oferecidas pela UML 2.0.\nI. O Diagrama de Comunicação, como o próprio nome já indica, procura dar ênfase\nà troca de mensagens entre os ob jetos durante o processo. Outra característica\ninteressante é que, embora partilhe elementos com o Diagrama de Sequências, o\nDiagrama de Comunicação não apresenta linhas de vida.\nII. Quando necessitamos detalhar um estado individual no Diagrama de Máquina de\nEstados, podemos utilizar o recurso estado composto, o qual possibilita a repre-\nsentação de subestados dentro de um mesmo diagrama.\nIII. Visando contemplar as necessidades de modelagem de sistemas de tempo real e\naplicações hipermídia e multimídia, onde a representação do tempo em que um\nob jeto executa algo é essencial, a UML 2.0 disponibiliza o Diagrama de Tempo\nque descreve as mudanças de estado de um ob jeto ao longo do tempo.\nIV. No intuito de facilitar a representação de uma visão mais geral de um sistema (ou\nprocesso), a UML 2.0 oferece o Diagrama de Interação Geral, uma variação do\nDiagrama de Atividades no qual são utilizados quadros ao invés de nós de ação.\nEstes podem aparecer no modo detalhado (apresentando seu comportamento in-\nterno) ou não.",
    "alternativas": [
      "(a) são verdadeiras todas as afirmativas.",
      "(b) nenhuma das afirmativas é verdadeira.",
      "(c) somente as afirmativas II e III são verdadeiras.",
      "(d) somente as afirmativas III e IV são verdadeiras.",
      "(e) somente as afirmativas I, II e III são verdadeiras."
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-53",
    "numero": 53,
    "enunciado": "Na UML, o Diagrama de Casos de Uso proporciona uma forma de representar a",
    "alternativas": [
      "",
      "",
      "",
      "",
      ""
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-54",
    "numero": 54,
    "enunciado": "Qualidade é uma das premissas básicas para se desenvolver software ho je em dia.\nI. O MPS.br é uma iniciativa para Melhoria de Processo do Software Brasileiro. O\nMPS.br adequa-se à realidade das empresas brasileiras e está em conformidade\ncom as normas ISO/IEC 12207. No entanto, não apresenta uma estratégia de\ncompatibilidade com o CMMI - Capability Maturity Model Integration.\nII. A rastreabilidade de requisitos de software proporciona uma melhor visibilidade\npara a gerência de qualidade do pro jeto.\nIII. Uma empresa de tecnologia certificada por meio de modelos como CMMI ou\nMPS.br oferece produtos de software também certificados.\nIV. A padronização é um dos fundamentos básicos da gerência da qualidade. A\npadronização pode acontecer em diversos níveis: na documentação, no código\ne, principalmente, no processo.",
    "alternativas": [
      "(a) Todas as afirmativas são verdadeiras.",
      "(b) Nenhuma das afirmativas é verdadeira.",
      "(c) Somente as afirmativas II e III são verdadeiras.",
      "(d) Somente as afirmativas II e IV são verdadeiras.",
      "(e) Somente as afirmativas I, II e III são verdadeiras."
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-55",
    "numero": 55,
    "enunciado": "Documentos de pro jeto de software servem principalmente para a judar o pro-",
    "alternativas": [
      "(a) Ob jetivo, escopo, requisitos, principais características do pro jeto e detalhes do\ncódigo.",
      "(b) Ob jetivo, prioridades gerais, visão geral do pro jeto, principais características do\npro jeto e detalhes do pro jeto.",
      "(c) Visão geral do pro jeto, escopo, ob jetivo, principais características do pro jeto e\ndetalhes do código.",
      "(d) Ob jetivo, prioridades gerais, requisitos, escopo e detalhes do pro jeto.",
      "(e) Nenhuma das anteriores."
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-56",
    "numero": 56,
    "enunciado": "Para atingir usabilidade, o pro jeto da interface de usuário para qualquer produto",
    "alternativas": [
      "(a) Capacidades cognitivas e motoras de pessoas em geral.",
      "(b) Características únicas da população usuária em particular.",
      "(c) Fatores que levem em consideração as restrições de uso de um grupo em particular\nnão suportado pelo produto",
      "(d) Requisitos das atividades dos usuários que estão sendo suportadas pelo produto.",
      "(e) Nenhuma das anteriores."
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-57",
    "numero": 57,
    "enunciado": "Levando em conta as podas alfa-beta na árvore Mini-Max abaixo, assinale a",
    "alternativas": [
      "(a) 7",
      "(b) 8",
      "(c) 10",
      "(d) 11",
      "(e) 13"
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-58",
    "numero": 58,
    "enunciado": "Considerando que h(n) é o custo estimado do nó n até o ob jetivo, em relação à",
    "alternativas": [
      "(a) a busca gulosa minimiza h(n).",
      "(b) a busca A∗ minimiza h(n).",
      "(c) a busca de custo uniforme minimiza h(n).",
      "(d) a busca gulosa minimiza h(n) somente se a heurística for admissível.",
      "(e) a busca A∗ minimiza h(n) somente se a heurística for admissível."
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-59",
    "numero": 59,
    "enunciado": "Analise o seguinte conjunto de afirmativas caracterizando agentes computacionais\nI. Um agente reflexivo que não dispõe de modelo de seu ambiente seleciona a próxi-\nma ação que vai executar tendo por base apenas as suas percepções atuais.\nII. Um agente capaz de planejar sequências futuras de ações não pode e não deve ter\nrepresentações explícitas de seus ob jetivos.\nIII. Um ambiente determinístico é aquele que permite a um agente, que se encontra\nsozinho no ambiente, saber o resultado de uma ação realizada a partir do con-\nhecimento do estado do ambiente no momento em que a ação foi realizada e das\ncaracterísticas da ação que o agente realizou.\nIV. Um ambiente parcialmente observável é aquele que só permite a um agente con-\nhecer completamente o estado atual do ambiente se o agente estiver sozinho no\nambiente.\nV. Uma função de utilidade é uma função que a juda um agente a distinguir quais\npercepções atuais são mais importantes para a realização dos ob jetivos do agente.",
    "alternativas": [
      "(a) somente as afirmativas I e II.",
      "(b) somente as afirmativas I e III.",
      "(c) somente as afirmativas III e IV.",
      "(d) somente as afirmativas III e V.",
      "(e) somente as afirmativas IV e V."
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-60",
    "numero": 60,
    "enunciado": "Analise as seguintes afirmativas.\nI. A estratégia de busca em largura encontra a solução ótima quando todos os op-\neradores de mudança de estado têm o mesmo custo.\nII. A estratégia de busca em profundidade sempre expande um menor número de nós\nque a estratégia de busca em largura, quando aplicadas ao mesmo problema.\nIII. A estratégia de busca heurística encontra sempre a solução de menor custo.\nIV. A estratégia de busca heurística expande um número de nós em geral menor que\no algoritmo de busca em largura, mas não garante encontrar a solução ótima.\nV. O algoritmo de busca heurística que utiliza uma função heurística admissível\nencontra a solução ótima.",
    "alternativas": [
      "(a) apenas a afirmativa V é correta.",
      "(b) todas as afirmativas são corretas.",
      "(c) todas as afirmativas são falsas.",
      "(d) apenas as afirmativas II e V são corretas.",
      "(e) apenas as afirmativas I, IV e V são corretas."
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-61",
    "numero": 61,
    "enunciado": "O realce de imagem tem como ob jetivo destacar detalhes finos procurando obter",
    "alternativas": [
      "(a) o melhor resultado obtido depende do filtro aplicado na imagem. Normalmente,\no mais aplicado é o filtro da mediana.",
      "(b) o melhor resultado é obtido com a aplicação de filtros passa-baixas, cujos parˆametros\ndependem do resultado desejado.",
      "(c) a aplicação de filtros da média sempre oferece resultado adequado no realce de\nimagens.",
      "(d) o resultado mais adequado no realce de imagens está associado à aplicação de\nfiltro passa-altas e da interpretação sub jetiva do observador que deverá ter con-\nhecimento a priori da imagem original.",
      "(e) o resultado mais adequado no realce de imagens está associado à aplicação de\nfiltro passa-baixas e da interpretação sub jetiva do observador que deverá ter con-\nhecimento a priori da imagem original."
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-62",
    "numero": 62,
    "enunciado": "Um sistema de codificação e compressão de imagens consiste de dois blocos, que\nprobabilidade código\n0,35 1\n0,25 01\n0,2 010\n0,1 0101\n0,05 01011\n0,03 010110\n0,01 0101100\n0,01 0101101",
    "alternativas": [
      "(a) 3,15 bits/símbolo",
      "(b) 1,14 bits/símbolo",
      "(c) 2,42 bits/símbolo",
      "(d) 4,38 bits/símbolo",
      "(e) 3,00 bits/símbolo"
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-63",
    "numero": 63,
    "enunciado": "Constitui(em) método(s) para alterar o contraste de uma imagem em cores sem\nI. Transformar RGB em IHS, aumentar o contraste de I e fazer a transformação\ninversa IHS para RGB.\nII. Aumentar o contraste de I, transformar IHS em RGB e fazer a transformação\ninversa RGB para IHS.\nIII. Aumentar o contraste em R, transformar RGB em IHS.",
    "alternativas": [
      "(a) apenas o item I é verdadeiro.",
      "(b) apenas o item II é verdadeiro.",
      "(c) são verdadeiros apenas os itens I e II.",
      "(d) são verdadeiros apenas os itens I e III.",
      "(e) são verdadeiros apenas os itens II e III."
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-64",
    "numero": 64,
    "enunciado": "O controle de congestionamento é uma das funções desempenhadas pela Camada",
    "alternativas": [
      "(a) No controle de congestionamento fim-a-fim, uma situação de congestionamento\né intuída pelos hosts terminais via eventos como perda ou atraso excessivo de\npacotes.",
      "(b) No controle de congestionamento assistido pela rede, os nodos (roteadores) enviam\nnotificações explícitas do estado de congestionamento da rede diretamente à fonte\nde cada fluxo que, por meio dele, trafega.",
      "(c) O mecanismo Explicit Congestion Notification (ECN) utiliza um dos dois últimos\nbits do campo ToS do cabeçalho IPv4 para notificar a um destinatário o estado\nde congestionamento da rede.",
      "(d) Ao perceber um estado de congestionamento na rede, uma conexão TCP, por\nmeio de seu mecanismo de prevenção de congestionamento (congestion avoidance ),\nreduz o tamanho de sua janela de congestionamento.",
      "(e) Na fase de partida lenta (slow start ) de uma conexão TCP, o tamanho da janela de\ncongestionamento aumenta a cada RTT (Round-Trip Time ) de forma exponencial,\naté que esse tamanho alcance um determinado valor de limiar (threshold )."
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-65",
    "numero": 65,
    "enunciado": "Sobre o protocolo de transferência de hipertextos (HTTP - Hyper-Text Transfer",
    "alternativas": [
      "(a) O protocolo HTTP é capaz de transportar nativamente arquivos no formato\nbinário.",
      "(b) A versão 1.0 do protocolo HTTP não permite a utilização de cookies.",
      "(c) A versão 1.1 do protocolo HTTP difere da versão 1.0 na capacidade de transportar\nob jetos maiores.",
      "(d) A instrução GET condicional permite que o cliente opte por receber um determi-\nnado ob jeto do servidor apenas se este tiver sido alterado depois de uma deter-\nminada data e hora.",
      "(e) O protocolo HTTP não pode ser utilizado para transportar outros tipos de ob jetos\nsenão os hiper-textos."
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-66",
    "numero": 66,
    "enunciado": "Considere os pares de endereços de hosts e suas respectivas máscaras de endereços\nI. 192.168.0.43/255.255.255.192 e 192.168.0.66/255.255.255.192\nII. 192.168.1.97/255.255.255.224 e 192.168.1.118/255.255.255.224\nIII. 192.168.2.115/255.255.255.128 e 192.168.2.135/255.255.255.128\nIV. 192.168.3.34/255.255.255.240 e 192.168.3.46/255.255.255.240\nV. 192.168.4.167/255.255.255.224 e 192.168.4.207/255.255.255.224",
    "alternativas": [
      "(a) apenas I, II, V",
      "(b) apenas I, III",
      "(c) apenas II, IV",
      "(d) apenas II, III, IV",
      "(e) apenas III, IV, V"
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-67",
    "numero": 67,
    "enunciado": "Analise as seguintes afirmativas.\nI. O protocolo UDP é um protocolo da Camada de Transporte orientado a data-\ngrama, enquanto que o TCP é um protocolo da Camada de Transporte orientado\na conexão.\nII. Apesar de o protocolo IP ser orientado a datagrama, o protocolo UDP é necessário\npor fornecer multiplexação de um endereço de rede em várias portas, permitindo\nque múltiplos processos sejam endereçados em um mesmo endereço de rede.\nIII. O protocolo TCP utiliza o tamanho da janela deslizante de uma conexão para o\ncontrole de congestionamento.",
    "alternativas": [
      "(a) somente a afirmativa I é correta.",
      "(b) somente as afirmativas I e II são corretas.",
      "(c) somente as afirmativas I e III são corretas.",
      "(d) somente as afirmativas II e III são corretas.",
      "(e) todas as afirmativas são corretas."
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-68",
    "numero": 68,
    "enunciado": "Considere as afirmativas sobre um Sistema de Arquivos Distribuídos (SAD).\nI. Um “Servidor de Arquivos com Estado”, em um SAD, mantém todo seu estado\nno caso de uma falha, garantindo a recuperação do mesmo sem a necessidade de\ndiálogo com os clientes.\nII. II. Na gerência de cache em um SAD, uma das políticas utilizadas é a write-\nthrough. O inconveniente dessa política, comparada com outras, é a pouca confi-\nabilidade no caso de falhas no cliente.\nIII. O uso de replicação em um SAD ao mesmo tempo que provê aumento na confia-\nbilidade, também introduz um gargalo em termos de desempenho.",
    "alternativas": [
      "(a) nenhuma das afirmativas está correta.",
      "(b) somente a afirmativa I está correta.",
      "(c) somente a afirmativa II está correta.",
      "(d) somente a afirmativa III está correta.",
      "(e) somente as afirmativas I e III estão corretas."
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-69",
    "numero": 69,
    "enunciado": "Analise as seguintes afirmativas concernentes a questões de pro jeto de sistemas\nI. Um sistema distribuído tolerante a falhas deve continuar operando na presença\nde problemas, podendo ocorrer uma degradação tanto no seu desempenho, como\nnas suas funcionalidades.\nII. No que diz respeito à escalabilidade, o pro jeto de um sistema distribuído deve\nprever que a demanda nos serviços em qualquer dos equipamentos seja limitada\npor uma constante dependente do número de nodos envolvidos.\nIII. Em um sistema distribuído transparente quanto à concorrência, a informação de\nquantos usuários estão empregando determinado serviço deve ser omitida.",
    "alternativas": [
      "(a) somente a afirmativa I está incorreta.",
      "(b) somente a afirmativa II está incorreta.",
      "(c) somente a afirmativa III está incorreta.",
      "(d) somente as afirmativas I e III estão incorretas.",
      "(e) todas as afirmativas estão incorretas."
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2007,
    "id": "2007-70",
    "numero": 70,
    "enunciado": "Em relação aos sistemas distribuídos, analise as seguintes afirmativas.\nI. Um sistema assíncrono apresenta medida de tempo global.\nII. A passagem de mensagens é o instrumento empregado para efetuar a comunica-\nção entre os processos de um sistema assíncrono.\nIII. É possível simular um computador paralelo de memória compartilhada usando-se\num sistema distribuído.\nIV. Quando um determinado elemento de um sistema distribuído efetua a difusão\nde uma mensagem por meio de um multicast, todos os elementos do sistema\ndistribuído recebem a mensagem.",
    "alternativas": [
      "(a) somente a afirmativa IV está correta.",
      "(b) somente as afirmativas I e II estão corretas.",
      "(c) somente as afirmativas I e III estão corretas.",
      "(d) somente as afirmativas II e III estão corretas.",
      "(e) somente as afirmativas I e IV estão corretas."
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-01",
    "numero": 1,
    "enunciado": "Seja T o operador linear em R3 definido por: T (x, y, z ) = (2y + z , x − 4y, 3x).",
    "alternativas": [
      "(a) A dimensão da imagem de T é 1 e a dimensão do núcleo de T é 2.",
      "(b) A dimensão da imagem de T é 3 e a dimensão do núcleo de T é 0.",
      "(c) A dimensão da imagem de T é 2 e a dimensão do núcleo de T é 1.",
      "(d) A dimensão da imagem de T é 0 e a dimensão do núcleo de T é 3.",
      "(e) A dimensão da imagem de T é 2 e a dimensão do núcleo de T é 2."
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-02",
    "numero": 2,
    "enunciado": "Seja o sistema de equações lineares nas variáveis x, y e z :\nx + y − z = 1\n2x + 3y + az = 3\nx + ay + 3z = 2\n(i) nenhuma solução, (ii) mais de uma solução, (iii) uma única solução.",
    "alternativas": [
      "(a) (i) a = −3; (ii) a = 2; (iii) a (cid:54)= 2 e a (cid:54)= −3",
      "(b) (i) a (cid:54)= 2 e a (cid:54)= −3; (ii) a = 2; (iii) a = −3",
      "(c) (i) a = 2; (ii) a (cid:54)= 2 e a (cid:54)= 3; (iii) a = −3",
      "(d) (i) a = −3; (ii) a (cid:54)= 2 e a (cid:54)= −3; (iii) a = 2",
      "(e) (i) a = −3; (ii) a = 2; (iii) a = 2 ou a = −3"
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-03",
    "numero": 3,
    "enunciado": "Quantos anagramas distintos podem ser formados com a palavra cochilo? Um",
    "alternativas": [
      "(a) 5040",
      "(b) 2520",
      "(c) 630",
      "(d) 1260",
      "(e) 120"
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-04",
    "numero": 4,
    "enunciado": "A equação da reta tangente à parábola y = x2 no ponto (−2, 4) é:",
    "alternativas": [
      "(a) 4x − y + 4 = 0",
      "(b) 4x + y + 4 = 0",
      "(c) y − 4x + 4 = 0",
      "(d) 4y − x + 4 = 0",
      "(e) 4y + x − 4 = 0"
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-05",
    "numero": 5,
    "enunciado": "Se f (x) = log 1/x, então f (an ) é:\na",
    "alternativas": [
      "(a) 1/n",
      "(b) −1/n",
      "(c) n",
      "(d) −n",
      "(e) 1/a"
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-06",
    "numero": 6,
    "enunciado": "Considere que custo total para se produzir x peças por dia em uma fábrica\n4\n2",
    "alternativas": [
      "(a) 12 peças/dia",
      "(b) 20 peças/dia",
      "(c) 15 peças/dia",
      "(d) 10 peças/dia",
      "(e) 100 peças/dia"
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-07",
    "numero": 7,
    "enunciado": "A distˆancia da origem à reta 4x − 3y − 15 = 0 é:",
    "alternativas": [
      "(a) 1/3",
      "(b) 3",
      "(c) -3",
      "(d) -1/3",
      "(e) 2/3"
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-08",
    "numero": 8,
    "enunciado": "As coordenadas do centro e do raio da circunferência",
    "alternativas": [
      "(a) centro = (5, −3) e raio = 15",
      "(b) centro = (3/2, 5/2) e raio = 7/2",
      "(c) centro = (−5, 3) e raio = 15",
      "(d) centro = (5/2, −3/2) e raio = 4",
      "(e) centro = (−5/2, 3/2) e raio = 4"
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-09",
    "numero": 9,
    "enunciado": "Assinale a proposição logicamente equivalente a ¬(p ∨ q) ∨ (¬p ∧ q)",
    "alternativas": [
      "(a) ¬p ∧ (q ∨ ¬q)",
      "(b) ¬p",
      "(c) (p ∨ q) ∧ (p ∨ ¬q)",
      "(d) (p ∨ q) ∨ (p ∧ ¬q)",
      "(e) p"
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-10",
    "numero": 10,
    "enunciado": "Considere as seguintes proposições:",
    "alternativas": [
      "(a) Somente (I)≡(III)",
      "(b) Somente (I)≡(II)",
      "(c) Somente (I)≡(II)≡(III)",
      "(d) (I)≡(III) e (II)≡(III) mas (III)(cid:54)≡(IV)",
      "(e) (I), (II), (III) e (IV) são todas equivalentes."
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-11",
    "numero": 11,
    "enunciado": "O número de sequências de bits de comprimento 7 que contém um número par",
    "alternativas": [
      "(a) 128",
      "(b) 64",
      "(c) 32",
      "(d) 16",
      "(e) 8"
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-12",
    "numero": 12,
    "enunciado": "Seja o conjunto A = {x ∈ R, |x| ≥ 1}. Qual das alternativas é uma partição do",
    "alternativas": [
      "(a) {x < −1}, {x > 1}, {1, −1}",
      "(b) {x ≤ 0}, {x ≥ 1}, {0}",
      "(c) {x ≤ −1}, {x ≥ 3}, {1 ≤ x ≤ 3}",
      "(d) {x ≤ −5}, {−5 < x ≤ −3}, {−1}, {x ≥ 1}",
      "(e) Todas as alternativas são partições de A."
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-13",
    "numero": 13,
    "enunciado": "Dados dois vetores no espaço euclidiano R4, u = (1, 3, -2, 7) e v = (0, 7, 2, 2),",
    "alternativas": [
      "(a) o quadrado da norma de u é igual a 58",
      "(b) o quadrado da distˆancia entre u e v é dado por 63",
      "(c) o quadrado da norma de v é igual a 57",
      "(d) os vetores u e v são ortogonais",
      "(e) nenhuma das anteriores"
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-14",
    "numero": 14,
    "enunciado": "Uma condição necessária e suficiente para que o sistema Ax=b tenha solução",
    "alternativas": [
      "(a) Ax=0 tem solução única.",
      "(b) As linhas de A são vetores linearmente independentes.",
      "(c) As colunas de A são vetores linearmente independentes que geram um subespaço\ncontendo b.",
      "(d) A matriz A é quadrada e não-singular.",
      "(e) O posto de A é igual a seu número de linhas."
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-15",
    "numero": 15,
    "enunciado": "Não é correto afirmar que:",
    "alternativas": [
      "(a) Se as colunas de uma matriz são vetores dois a dois ortogonais, então sua inversa\né sua transposta.",
      "(b) Se a inversa de uma matriz é ela própria, então toda potência dessa matriz é ela\nprópria ou a identidade.",
      "(c) Se uma matriz singular é o produto de duas outras matrizes quadradas, então\numa destas também é singular.",
      "(d) Se três matrizes quadradas A, B e C satisfazem A(B-C)=0, então A=0 ou B=C.",
      "(e) Se A e B são matrizes triangulares inferiores então AB também é triangular infe-\nrior."
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-16",
    "numero": 16,
    "enunciado": "Seis amigos reúnem-se para disputar partidas de xadrez em três tabuleiros dife-",
    "alternativas": [
      "(a) 15",
      "(b) 30",
      "(c) 90",
      "(d) 120",
      "(e) 720\nAs duas questões a seguir são baseadas no seguinte enunciado:\n- Um algoritmo probabilístico A resolve problemas de dois tipos:\n{Problemas do tipo 1}: os quais são resolvidos corretamente com probabilidade\ne correspondem a 1/3 do total de problemas.\n{Problemas do tipo 2}: os quais são resolvidos corretamente com probabilidade\ne correspondem a 2/3 do total de problemas."
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-17",
    "numero": 17,
    "enunciado": "i. Um problema é selecionado aleatoriamente e resolvido pelo algoritmo. Qual",
    "alternativas": [
      "(a) 3/4",
      "(b) 5/12",
      "(c) 5/8",
      "(d) 7/12",
      "(e) 3/8"
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-18",
    "numero": 18,
    "enunciado": "ii. Verifica-se, utilizando algum método determinístico, que a resposta encon-",
    "alternativas": [
      "(a) 4/9",
      "(b) 3/4",
      "(c) 7/12",
      "(d) 3/7",
      "(e) 7/3"
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-19",
    "numero": 19,
    "enunciado": "A representação polar do número complexo 5 i é dada por:",
    "alternativas": [
      "(a) (5, −900)",
      "(b) (5, 900)",
      "(c) (5, 1800)",
      "(d) (5, −1800 )",
      "(e) nenhuma das alternativas"
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-20",
    "numero": 20,
    "enunciado": "Se x = 2 + 2i e y = i, então, o produto x.y é dado por:",
    "alternativas": [
      "(a) 2 + 2 i",
      "(b) 4 + 2i",
      "(c) -2 + 2 i",
      "(d) 4 i",
      "(e) nenhuma das alternativas\nQUESTÕ ES DE FUNDAMENTOS DA COMPUTAÇ Ã O"
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-21",
    "numero": 21,
    "enunciado": "Considere dois sistemas A e B compostos por um processador, cache e memória\nno-write al locate (escritas não utilizam a cache)\nal locate e LRU",
    "alternativas": [
      "(a) Somente as afirmações (II), (III) e (IV) são verdadeiras",
      "(b) Somente as afirmações (I), (III) e (VI) são verdadeiras",
      "(c) Somente as afirmações (I), (III) e (IV) são verdadeiras",
      "(d) Somente as afirmações (II), (V) e (VI) são verdadeiras",
      "(e) Todas as afirmações são verdadeiras"
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-22",
    "numero": 22,
    "enunciado": "Para a representação de número ponto flutuante no padrão IEEE, quais das\nfracionária são zeros, o número representado é + infinito ou -infinito;",
    "alternativas": [
      "(a) somente I.",
      "(b) somente I e IV.",
      "(c) somente I, II e IV.",
      "(d) somente IV.",
      "(e) todas são verdadeiras."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-23",
    "numero": 23,
    "enunciado": "De acordo com o teorema de DeMorgan, o complemento de X + Y · Z é:",
    "alternativas": [
      "(a) X + Y · Z",
      "(b) X · Y + Z",
      "(c) X · (Y + Z )",
      "(d) X · Y · Z",
      "(e) X · Y + Z"
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-24",
    "numero": 24,
    "enunciado": "Num processador superescalar com emissão dinˆamica de instruções para o estágio",
    "alternativas": [
      "(a) Somente as alternativas (I), (II) e (IV) são verdadeiras.",
      "(b) Somente as alternativas (I), (III) e (IV) são verdadeiras.",
      "(c) Somente as alternativas (I), (II) e (V) são verdadeiras.",
      "(d) Somente as alternativas (I), (III) e (V) são verdadeiras.",
      "(e) Todas as alternativas são verdadeiras."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-25",
    "numero": 25,
    "enunciado": "Dada uma lista linear de n + 1 elementos ordenados e alocados sequencialmente,",
    "alternativas": [
      "(a) n/2",
      "(b) (n + 2)/2",
      "(c) (n − 1)/2",
      "(d) n(n + 3 + 2/n)/2",
      "(e) (n + 1)/2"
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-26",
    "numero": 26,
    "enunciado": "A respeito da representação de um grafo de n vértices e m arestas é correto dizer",
    "alternativas": [
      "(a) a representação sob a forma de matriz de adjacência exige espaço Ω(m2).",
      "(b) a representação sob a forma de listas de adjacência permite verificar a existência\nde uma aresta ligando dois vértices dados em tempo O(1).",
      "(c) a representação sob a forma de matriz de adjacência não permite verificar a ex-\nistência de uma aresta ligando dois vértices dados em tempo O(1).",
      "(d) a representação sob a forma de listas de adjacência exige espaço Ω(n + m).",
      "(e) todas as alternativas estão corretas."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-27",
    "numero": 27,
    "enunciado": "Considere as afirmações abaixo, onde o alfabeto das linguagens é sempre dado\n(I) A linguagem fomada por todas as cadeias x ∈ Σ∗ onde após cada dois zeros\nconsecutivos sempre ocorrem pelo menos dois uns. Note que: os uns não\nprecisam ser consecutivos, nem precisam ocorrer imediatamente após os zeros.\n(II) Se L é livre de contexto e R é regular, então a linguagem {y| para algum x, z ∈\nΣ∗ temos xyz ∈ L e xz ∈ R} é sempre livre de contexto.\n1 2\nlentes, isto é, se aceitam a mesma linguagem.\n(V) Dada uma máquina de Turing, M , e um número inteiro k ≥ 0, sempre podemos\ndecidir se a linguagem aceita por M tem pelo menos k cadeias distintas.",
    "alternativas": [
      "(a) As afirmações (II), (III) e (IV) são verdadeiras.",
      "(b) Há duas afirmações falsas entre (I), (II) e (V).",
      "(c) Há duas afirmações verdadeiras entre (I), (IV) e (V).",
      "(d) Entre todas as cinco afirmações, pelo menos 3 (três) são falsas.",
      "(e) Não é possível determinar se a afirmação (V) é verdadeira ou falsa, para uma\nmáquina de Turing genérica e um k ≥ 0 genérico."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-28",
    "numero": 28,
    "enunciado": "Qual das seguintes afirmações é falsa?",
    "alternativas": [
      "(a) Todo autˆomato finito não determinístico com transições vazias pode ser reduzido\npara um autˆomato finito determinístico.",
      "(b) Nem todo autˆomato com pilha não determinístico pode ser reduzido para um\nautˆomato com pilha determinístico.",
      "(c) Toda máquina de Turing com N ≥ 1 fitas pode ser reduzida para uma máquina\nde Turing padrão.",
      "(d) Para se provar que uma linguagem é regular basta usar o lema do bombeamento\n(pumping lemma ) de linguagens regulares.",
      "(e) Máquinas de Turing aceitam linguagens geradas por gramáticas irrestritas."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-29",
    "numero": 29,
    "enunciado": "Considere a função Pot que calcula xn , para x real e n inteiro:\nFunction Pot(x: real; n: integer): real;\nbegin\nif x = 0\nthen\nPot := 0\nelse\nif n = 0\nthen\nPot := 1\nelse\nif n < 0\nthen\nPot := 1/Pot(x,abs(n))\nelse\nif odd(n)\nthen\nPot := x * sqr(Pot(x,(n-1) div 2))\nelse\nPot := sqr(Pot(x,n div 2))\nend;",
    "alternativas": [
      "",
      "",
      "",
      "",
      ""
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-30",
    "numero": 30,
    "enunciado": "Seja P o problema de ordenar, usando comparação, n ≥ 1 elementos e C a classe",
    "alternativas": [
      "(a) Ω(1)",
      "(b) Ω(log n)",
      "(c) Ω(n)",
      "(d) Ω(n log n)",
      "(e) Ω(n2)"
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-31",
    "numero": 31,
    "enunciado": "Quais algoritmos de ordenação têm complexidade O(n log n) para o melhor caso,",
    "alternativas": [
      "(a) Insertion Sort e Quicksort",
      "(b) Quicksort e Heapsort",
      "(c) Bubble Sort e Insertion Sort",
      "(d) Heapsort e Insertion Sort",
      "(e) Quicksort e Bubble Sort"
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-32",
    "numero": 32,
    "enunciado": "Qual dos seguintes mecanismos é o menos recomendado para se implementar",
    "alternativas": [
      "(a) Semáforo",
      "(b) Espera ocupada",
      "(c) Troca de mensagens",
      "(d) Monitores",
      "(e) Variáveis de condição"
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-33",
    "numero": 33,
    "enunciado": "Como o procedimento abaixo deve ser completado para que ele seja capaz de\n....\ntype VetorType = array[0..100] of integer;\nprocedure Ordena(n: integer; var a: VetorType);\nvar i,j,x: integer;\nbegin\nfor i := 2 to n do\nbegin\nx := a[i];\nj := i - 1;\n___________________;\nWhile x < a[j] do\nbegin\na[i+j] := a[j];\n__________________;\nend;\n____________________;\nend;\nend;",
    "alternativas": [
      "(a) a[j] := x; j := j - 1; a[j] := x;",
      "(b) a[i] := x; j := j + 1; a[i] := x;",
      "(c) a[0] := x; j := j - 1; a[j+1] := x;",
      "(d) a[i] := x; j := j - 1; a[j+1] := x;",
      "(e) a[0] := x; j := j + 1; a[j] := x;"
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-34",
    "numero": 34,
    "enunciado": "as sequências",
    "alternativas": [
      "(a) T1 possui altura mínima dentre todas as árvores binárias com 9 nós.",
      "(b) T1 é uma árvore AVL.",
      "(c) T1 é uma árvore rubro-negra.",
      "(d) T2 possui altura mínima dentre todas as árvores binárias com 11 nós.",
      "(e) T2 é uma árvore rubro-negra."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-35",
    "numero": 35,
    "enunciado": "Que valores são impressos quando o seguinte algoritmo, escrito em Pascal, é\nx:=y+a+1;\ny:=x+b+1\na:=1; b:=2;\nMist(a,b);\nWrite(a,b)",
    "alternativas": [
      "(a) 1 2",
      "(b) 3 1",
      "(c) 3 5",
      "(d) 1 7",
      "(e) 4 7"
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-36",
    "numero": 36,
    "enunciado": "Seja G = (V , E ) um grafo simples conexo não-euleriano. Queremos construir um\numa aresta.\npar de vértices correspondentes.\nvértice a todo vértice de grau ímpar de G.",
    "alternativas": [
      "(a) Somente (II) e (IV)",
      "(b) Somente (II), (IV) e (V)",
      "(c) Somente (III), (V) e (VI)",
      "(d) Somente (II), (IV), (V) e (VI)",
      "(e) Somente (I), (III), (IV) e (V)"
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-37",
    "numero": 37,
    "enunciado": "Considere o programa:\nprogram p;\nvar n: integer;\nfunction f(n: integer; var k:integer): integer;\nvar p,q:integer;\nbegin (* f *)\nif n < 2\nthen begin\nf := n;\nk := 0\nend\nelse begin\nf := f(n-1, p) + f(n-2, q);\nk := p + q + 1\nend;\nwrite(n,’ ’,k,’; ’)\nend (* f *);\nbegin\nn := 4;\nwrite(f(3,n),n)\nend.",
    "alternativas": [
      "(a) 1 0; 0 0; 2 1; 1 0; 3 2; 2 4",
      "(b) 1 4; 0 0; 2 1; 1 0; 3 2; 2 2",
      "(c) 1 0; 0 0; 2 1; 1 0; 3 2; 2 2",
      "(d) 1 0; 0 0; 2 1; 1 0; 3 2; 2 3",
      "(e) 1 4; 0 4; 2 4; 1 4; 3 4; 2 4"
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-38",
    "numero": 38,
    "enunciado": "A complexidade desse Algoritmo da questão anterior é :",
    "alternativas": [
      "(a) O(log n)\n2",
      "(b) O(n)",
      "(c) O(n log n)\n2",
      "(d) Ω(n log n)\n2",
      "(e) Ω(n2)"
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-39",
    "numero": 39,
    "enunciado": "O uso de associações é muito importante em programação orientada a ob jetos.\nI. A multiplicidade de uma associação é uma restrição imposta a essa associação que\nde-fine o número de instˆancias das classes envolvidas nesse relacionamento.\nII. A ordenação não é considerada uma restrição a associações, já que ordena as\ninstˆancias envolvidas no relacionamento que caracteriza a associação em questão.\nIII. O uso de papéis só é permitido em associações reflexivas binárias, pois em outros\ntipos de associações os papéis causam problemas na modelagem das classes.",
    "alternativas": [
      "(a) As três afirmações são falsas.",
      "(b) As três afirmações são verdadeiras.",
      "(c) Apenas a afirmação I é verdadeira.",
      "(d) As afirmações I e II são verdadeiras.",
      "(e) Apenas a afirmação III é verdadeira."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-40",
    "numero": 40,
    "enunciado": "Na modelagem de classes usando UML (Unified Modeling Language) é recomendável",
    "alternativas": [
      "(a) Votar (Presidente, Eleitor)",
      "(b) Casar (Marido, Esposa)",
      "(c) Torcer (Time, Torcedor)",
      "(d) Escrever (Livro, Autor)",
      "(e) Assinar (Revista, Assinante)\nQUESTÕ ES DE TECNOLOGIA DA COMPUTAÇ Ã O"
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-41",
    "numero": 41,
    "enunciado": "Sobre os operadores da Álgebra Relacional, é correto afirmar que:",
    "alternativas": [
      "(a) O operador de SELEÇ Ã O seleciona as colunas de uma tupla que satisfazem a\numa determinada condição.",
      "(b) O número de tuplas resultantes da aplicação do operador de PROJEÇ Ã O em uma\ndada relação R é sempre igual ao número de tuplas de R.",
      "(c) O número de tuplas resultantes da aplicação do operador de JUNÇ Ã O em duas\nrelações R e S é sempre maior do que o número de tuplas resultantes do PRO-\nDUTO CARTESIANO de R e S.",
      "(d) A aplicação das operações de UNIÃ O e INTERSEÇ Ã O requerem que as relações\nenvolvidas sejam compatíveis quanto à união.",
      "(e) O número de tuplas resultantes da aplicação do operador de SELEÇ Ã O em uma\nrelação R é sempre menor do que o número de tuplas de R."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-42",
    "numero": 42,
    "enunciado": "Considere os esquemas das relações abaixo:\nEmpregado(rg, nome, rua, cidade, rg-gerente), onde o atributo ”rg”é chave da relação\nEmpregado.\nEmpresa(cod, nome, cidade), onde o atributo ”cod”é chave da relação Empresa.\nTrabalha(rg-emp, cod-empresa, salario), onde ”rg-emp”referencia o atributo ”rg”na\nrelação Empregado, ”cod-empresa”referencia o atributo ”cod”na relação Empresa\ne os atributos ”rg-emp”e ”cod-empresa”formam a chave da relação trabalha.",
    "alternativas": [
      "(a) ”Quais são os nomes dos empregados que trabalham na cidade em que moram?”",
      "(b) ”Quais são os nomes dos gerentes dos empregados que trabalham na cidade em\nque moram?”",
      "(c) ”Quais são os nomes dos empregados que trabalham em alguma cidade?”",
      "(d) ”Quais são os nomes dos gerentes dos empregados?”",
      "(e) ”Quais os nomes dos empregados que trabalham na cidade em que mora o seu\ngerente?”"
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-43",
    "numero": 43,
    "enunciado": "Considere uma relação A com 1000 registros e taxa de ocupação de 5 registros por",
    "alternativas": [
      "",
      "",
      "",
      "",
      ""
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-44",
    "numero": 44,
    "enunciado": "Assinalar a opção correta acerca das sentenças abaixo:\nI. Os níveis de isolamento de uma transação SQL são: Read Uncommitted, Read\nCommitted, Repeatable Read e Serializable.\nII. Atomicidade e Durabilidade são garantidas pelo Gerenciador de Recuperação do\nSGBD.\nIII. São propriedades de uma transação: Atomicidade, Consistência, Integridade e\nDurabilidade.",
    "alternativas": [
      "(a) Apenas I é verdadeira.",
      "(b) Apenas I e II são verdadeiras.",
      "(c) Apenas II e III são verdadeiras.",
      "(d) Apenas I e III são verdadeiras.",
      "(e) Todas são verdadeiras"
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-45",
    "numero": 45,
    "enunciado": "Considere os seguintes esquemas de relação:\nDepartamentos (codDepto, nome, gerente)\nEmpregados (codEmp, nome, codDepto, salario)\nSELECT d.codDepto\nFROM Empregados e, Departamentos d\nWHERE e.codDepto = d.codDepto\nGROUP BY d.codDepto\nHAVING AVG(sal) > ALL (SELECT e.sal\nFROM Empregados e, Departamentos d\nWHERE e.codDepto = d.codDepto\nAND d.nome = ’vendas)",
    "alternativas": [
      "",
      "",
      "",
      "",
      ""
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-46",
    "numero": 46,
    "enunciado": "A respeito da gramática G abaixo,\nS -> a A a\nS -> b A b\nA -> b\nA -> epsilon\nI. G é SLR(1).\nII. G é LL(1).\nIII. G é sensível ao contexto.",
    "alternativas": [
      "(a) Somente I é verdadeira",
      "(b) Somente II é verdadeira",
      "(c) Somente III é verdadeira",
      "(d) Somente I e III são verdadeiras",
      "(e) Todas as 3 afirmativas são verdadeiras"
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-47",
    "numero": 47,
    "enunciado": "Considere os filtros espaciais da média (m) e Mediana (M) aplicados em imagens",
    "alternativas": [
      "(a) m(f + g) = m(f ) + m(g); M(f + g) (cid:54)= M(f ) + M(g)",
      "(b) ruído gaussiano; ruído impulsivo",
      "(c) convolução; filtro estatístico da ordem",
      "(d) preservação de pequenos componentes; não preservação de pequenos componentes",
      "(e) filtragem com preservação de contornos; filtragem sem preservação de contornos"
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-48",
    "numero": 48,
    "enunciado": "com uma linha de uma imagem contendo",
    "alternativas": [
      "(a) [. . . 3 4 5 6 7 8 9 10 . . .] e representa o filtro da média com 2-vizinhos mais próximos",
      "(b) [. . . 0 0 0 0 0 0 0 0 . . .] e representa o laplaciano no espaço discreto",
      "(c) [. . . 0 0 0 0 0 0 0 0 . . .] e representa uma erosão morfológica",
      "(d) [. . . 1 1 1 1 1 1 1 1 . . .] e é equivalente a um filtro passa-baixas",
      "(e) [. . . 7 9 11 13 15 17 19 . . .] e é equivalente a um filtro passa-altas"
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-49",
    "numero": 49,
    "enunciado": "Considere as afirmações abaixo:",
    "alternativas": [
      "(a) Apenas I - II - III são verdadeiras",
      "(b) Apenas II - IV - V são verdadeiras",
      "(c) Todas são verdadeiras",
      "(d) Todas são falsas",
      "(e) Apenas I - II são verdadeiras."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-50",
    "numero": 50,
    "enunciado": "Considere o plano definido pelos pontos A(10, 0, 0), B(0, 10, 0) e C(2, 2, 20). A",
    "alternativas": [
      "(a) (300/13, 40/13, −100/13)",
      "(b) (150/13, 80/13, −200/13)",
      "(c) (150/13, 40/13, −200/13)",
      "(d) (300/13, 80/13, −100/13)",
      "(e) (300/13, 40/13, −200/13)"
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-51",
    "numero": 51,
    "enunciado": "Quando se aplica um filtro passa-baixas (low-pass filter) a uma imagem com",
    "alternativas": [
      "(a) Fica reduzida à metade das dimensões da imagem original",
      "(b) Fica ampliada ao dobro das dimensões da imagem original",
      "(c) Tem as mesmas dimensões da imagem original, com todos os pixels na cor preta",
      "(d) Tem as mesmas dimensões da imagem original, com todos os pixels na cor branca",
      "(e) Nenhuma das afirmações acima é correta"
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-52",
    "numero": 52,
    "enunciado": "A notação da Unified Modeling Language (UML) que descreve a sequência de",
    "alternativas": [
      "(a) Casos de uso.",
      "(b) Diagrama de sequência.",
      "(c) Diagrama de classes.",
      "(d) Diagrama de atividades.",
      "(e) Diagrama de estados."
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-53",
    "numero": 53,
    "enunciado": "Dentre as afirmações dadas a seguir, assinale a afirmação falsa.",
    "alternativas": [
      "(a) O ob jetivo dos testes é detectar erros.",
      "(b) Os testes aplicados a um software também devem ter controle de versões.",
      "(c) As atividades de teste começam após o término da fase de codificação.",
      "(d) Testes devem verificar não somente se o software faz o que é desejado, mas também\nse ele não faz algo indesejado.",
      "(e) As atividades de teste compreendem, entre outras, o pro jeto, a especificação e a\nimplementação de casos de teste."
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-54",
    "numero": 54,
    "enunciado": "Os pontos de função em um software são calculados estimando-se as seguintes",
    "alternativas": [
      "(a) Entradas e saídas externas, interações com usuários, interfaces externas, e ar-\nquivos utilizados pelo sistema.",
      "(b) Tamanho do código, entradas e saídas externas, interfaces externas, e produtivi-\ndade do sistema.",
      "(c) Complexidade do produto, experiência pessoal, prazo, número de pessoas envolvi-\ndas, e confiabilidade.",
      "(d) Tamanho do código, produtividade do sistema, experiência pessoal, prazo, e ar-\nquivos utilizados pelo sistema.",
      "(e) Volatilidade da plataforma de desenvolvimento, entradas e saídas externas, número\nde pessoas envolvidas, interações com usuários, e confiabilidade."
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-55",
    "numero": 55,
    "enunciado": "No desenvolvimento em espiral, cada loop representa uma fase do processo de",
    "alternativas": [
      "(a) Definição dos requisitos, análise, pro jeto e testes.",
      "(b) Descrição dos ob jetivos, planejamento, identificação dos riscos e testes.",
      "(c) Requisitos, desenvolvimento, validação e evolução.",
      "(d) Identificação dos riscos, pro jeto, implementação e testes.",
      "(e) Definição de ob jetivos, avaliação e redução dos riscos, desenvolvimento e va-\nlidação, e planejamento."
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-56",
    "numero": 56,
    "enunciado": "Suponha que são dados 3 valores inteiros, A, B e C, em ordem decrescente,",
    "alternativas": [
      "(a) (5, 3, 4), (0, 0, 0), (10, 5, 5)",
      "(b) (101, 20, 5), (1, 0, 0), (30, 1, -1)",
      "(c) (3, 4, 7), (12, 9, 6), (1,1,1)",
      "(d) (2, 2, 2), (3, 5, 8), (5, 5, 5)",
      "(e) (0,0,0), (minint, maxint, maxint), (0, 0, -1) onde maxint representa o maior inteiro\npossível e minint, o menor."
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-57",
    "numero": 57,
    "enunciado": "O código abaixo implementa uma função que calcula o MDC de dois números\nfunction mdc (int a, int b)\nint temp, value;\na := abs(a);\nb := abs(b);\nif (a = 0) then\nvalue := b; // b é o MDC\nelse if (b = 0) then\nexceção;\nelse\nrepeat\ntemp := b;\nb := a mod b;\na := temp;\nuntil (b = 0)\nvalue := a;\nend if;\nreturn value;\nend mdc",
    "alternativas": [
      "(a) {(0, 3), (4, −2), (5, 4)}",
      "(b) {(0, −1), (4, 0), (−1, 0)}",
      "(c) {(6, 3), (4, 2), (0, 0)}",
      "(d) {(12, 9), (0, 2), (4, 0)}",
      "(e) {(3, 5), (−1, −1), (9, 4)}"
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-58",
    "numero": 58,
    "enunciado": "A percepção humana é um processo ativo fundamental na interação humano-",
    "alternativas": [
      "(a) A abordagem construtivista possibilita entender como a informação que chega à\nretina é decomposta em partes significativas.",
      "(b) A abordagem ecológica possibilita entender as propriedades visuais de ob jetos em\ntermos de quanto esses ob jetos evocam ações a serem realizadas sobre eles.",
      "(c) Affordance é um conceito relacionado à abordagem construtivista.",
      "(d) Psicólogos Gestaltistas foram os primeiros a descrever princípios gerais sub ja-\ncentes ao processo de organização perceptual.",
      "(e) São princípios da Gestalt para organização perceptual: proximidade, similaridade,\nfecho, continuidade e simetria."
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-59",
    "numero": 59,
    "enunciado": "Os modelos de ciclo de vida surgidos na área de Interação Humano-computador",
    "alternativas": [
      "(a) O desenvolvimento de protótipos é parte integral do design iterativo centrado no\nusuário porque possibilita que designers testem suas idéias com usuários.",
      "(b) O modelo de ciclo de vida Estrela surgiu de um trabalho empírico de observação\nde como os designers de interface de usuário trabalhavam.",
      "(c) O modelo de ciclo de vida Estrela não especifica a ordem em que as atividades\ndevem ser realizadas.",
      "(d) O modelo de ciclo de vida Estrela é centrado na avaliação; sempre que uma\natividade é completada, seu resultado deve ser avaliado.",
      "(e) No modelo de ciclo de vida Estrela o pro jeto deve iniciar com a avaliação de uma\nsituação existente."
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-60",
    "numero": 60,
    "enunciado": "Avaliação de interface de usuário, em sentido amplo, envolve coletar dados sobre\nconsultores.\nrealização de tarefas em laboratório.\ndo design em atividades naturais do usuário em seu contexto.\nde usuários típicos visando prever problemas de usabilidade.",
    "alternativas": [
      "",
      "",
      "",
      "",
      ""
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-61",
    "numero": 61,
    "enunciado": "Considere o seguinte problema de programação linear:\nMax c x + c y\n1 2\nSujeito a x + y ≥ 3\nx ≥ 1\ny ≥ 1",
    "alternativas": [
      "(a) Como (λ, λ) é solução viável para λ ≥ 3/2, então não existe solução ótima.",
      "(b) Como (λ, λ) é solução viável para λ ≥ 3/2, então existe um número infinito de\nsoluções ótimas.",
      "(c) Existe uma solução ótima apenas se c ≤ 0 e c ≤ 0.\n1 2",
      "(d) (1, 2) ou (2, 1) é necessariamente uma solução ótima.",
      "(e) O problema dual é inviável."
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-62",
    "numero": 62,
    "enunciado": "Dado um perceptron simples de duas entradas e um bias , cujos pesos são w1 =",
    "alternativas": [
      "(a) o perceptron realiza a função NOR",
      "(b) o perceptron realiza a função AND",
      "(c) o perceptron realiza a função OR",
      "(d) o perceptron realiza a função XOR",
      "(e) nenhuma das alternativas"
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-63",
    "numero": 63,
    "enunciado": "Considere o programa Prolog:\nblabla([ ],L,L).\nblabla([X|L1],L2,[X|L3]):- blabla(L1,L2,L3).",
    "alternativas": [
      "",
      "",
      "",
      "",
      ""
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-64",
    "numero": 64,
    "enunciado": "Sobre o protocolo IP (Internet Protocol), é correto afirmar:",
    "alternativas": [
      "(a) O tamanho do cabeçalho do IPv4 é fixado em 96 bits;",
      "(b) O espaço de endereçamento do IPv4 e do IPv6 é de 32 e 128 bits, respectivamente;",
      "(c) O cabeçalho IP inclui informação sobre o protocolo de camada de enlace empre-\ngado;",
      "(d) A classe C de endereços IPv4 reserva 16 bits para endereço de rede;",
      "(e) O roteamento IP associa o endereço IP com o número de porta em nível de trans-\nporte."
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-65",
    "numero": 65,
    "enunciado": "Duas tecnologias utilizadas para acesso residencial à Internet são ADSL e Cable",
    "alternativas": [
      "(a) Ambas permitem taxas de transmissão diferentes para upstream e downstream",
      "(b) Os canais de upstream e downstream da tecnologia ADSL não necessitam de con-\ntenção de acesso",
      "(c) Os canais de upstream e downstream da tecnologia Cable Modem necessitam de\ncontenção de acesso",
      "(d) ADSL utiliza par trançado dedicado para cada residência",
      "(e) Cable Modem utiliza cabo compartilhado para diversas residências"
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-66",
    "numero": 66,
    "enunciado": "Os endereços IP são divididos em classes. Qual afirmação é incorreta?",
    "alternativas": [
      "(a) Existem mais redes classe B do que classe A",
      "(b) Uma rede classe C permite mais hosts do que uma rede classe B",
      "(c) A classe D é dedicada a endereços multicast",
      "(d) Máscaras podem dividir o campo Rede do endereço IP em Rede e Sub-rede para\nfacilitar o roteamento interno",
      "(e) NAT (Tradução de Endereço de Rede) é utilizada em redes com vários hosts que\nse conectam à Internet através de poucos endereços IP"
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-67",
    "numero": 67,
    "enunciado": "Considere os seguintes parˆametros de Qualidade de Serviço (QoS) para trans-\nAplicação Confiabilidade Atraso Jitter Largura de banda",
    "alternativas": [
      "",
      "",
      "",
      "",
      ""
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-68",
    "numero": 68,
    "enunciado": "A comunicação entre processos em um sistema distribuído pode ser realizada por",
    "alternativas": [
      "(a) Processos comunicantes compartilham o mesmo espaço de endereçamento.",
      "(b) Os stubs cliente e servidor são responsáveis pela conversão de formato dos parˆametros\nde entrada e saída, caso ha ja necessidade.",
      "(c) A geração dos stubs é comumente realizada por compilação a partir de uma es-\npecificação de interface realizada em uma linguagem de execução de interface\n(IEL).",
      "(d) O mecanismo faz uso de uma porta fixa, de número 8080, para comunicar difer-\nentes processos e serviços entre computadores de um sistema distribuído.",
      "(e) A falha de um cliente RPC gera uma chamada dita orfã no servidor que neste caso\nrepassa sempre os resultados do procedimento remoto para um proxy de retorno\nespecificado na chamada"
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-69",
    "numero": 69,
    "enunciado": "Sobre algoritmos de exclusão mútua em sistemas distribuídos é correto afirmar",
    "alternativas": [
      "(a) O algoritmo centralizado tem como principal desvantagem o alto número de troca\nde mensagens.",
      "(b) O algoritmo distribuído é totalmente independente da ordem dos eventos do sis-\ntema distribuído.",
      "(c) A maioria simples de permissões dos participantes para entrada em região crítica\né suficiente para garantir a exclusão mútua no algoritmo distribuído.",
      "(d) No algoritmo do token , a exclusão mútua é garantida por uma concessão de\nbloqueio fornecida pelo gerente que mantém uma lista de tokens.",
      "(e) Três mensagens são suficientes para fechar o ciclo de concessão, liberação e nova\nconcessão de acesso no algoritmo do token."
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2006,
    "id": "2006-70",
    "numero": 70,
    "enunciado": "Um sistema distribuído pode manter diferentes cópias de um mesmo item de dado",
    "alternativas": [
      "(a) O protocolo baseado em cópia primária permite sempre a atualização da cópia\nmais próxima e difunde o novo valor via unicast para todos os nós que mantém\numa outra cópia.",
      "(b) A atualização de todas as cópias, no protocolo baseado em cópia primária, é\nrealizada através de um processo síncrono, onde o cliente é liberado para continuar\no fluxo de execução imediatamente após ter solicitado a atualização da cópia\nprimária.",
      "(c) Nos protocolos baseados em quorum, os conflitos leitura-escrita e escrita-escrita\nsão evitados por autorizações de bloqueio (lock) emitidas por um coordenador\ncentral ou sequenciador.",
      "(d) Protocolos baseados em coerência de cache são mecanismos de consistência de\ncópias que repassam a responsabilidade de manter essa consistência para os servi-\ndores que detém cópias.",
      "(e) No protocolo de replicação ativa, todas as réplicas são atualizadas através de uma\núnica operação de escrita realizada por um mecanismo de multicast totalmente\nordenado."
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-01",
    "numero": 1,
    "enunciado": "A representação polar do número complexo 3i é dada por:\n(cid:0)",
    "alternativas": [
      "(a) (3, 90(cid:14) )\n(cid:0)",
      "(b) (3, 90(cid:14))",
      "(c) ( 3, 180(cid:14))\n(cid:0)",
      "(d) (3, 180(cid:14))\n(cid:0)",
      "(e) ( 3, 270(cid:14))\n(cid:0)"
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-02",
    "numero": 2,
    "enunciado": "Se x = 3 2i e y = 1 + 4i são números complexos, então o produto x y é dado por:\n(cid:0) (cid:1)",
    "alternativas": [
      "(a) 3 8i\n(cid:0)",
      "(b) 4 + 2i",
      "(c) 11 + 10i",
      "(d) 8 + 3i\n(cid:0)",
      "(e) 3 + 2i"
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-03",
    "numero": 3,
    "enunciado": "Considere a matriz abaixo:\n1 3 1 1 5\nA = 2 6 0 4 2\n0 (cid:0) (cid:0) (cid:0) 1\n1 3 2 3 9\n@ A",
    "alternativas": [
      "(a) 3, 3, 2, (1; 2; 1); (1; 0; 2); (1; 4; 3)\nf (cid:0) g",
      "(b) 3, 3, 2, (1; 2; 1); (1; 0; 2); (5; 2; 9)\nf (cid:0) (cid:0) g",
      "(c) 3, 2, 3, (1; 2; 1); (1; 0; 2)\nf (cid:0) g",
      "(d) 2, 3, 2, (1; 2; 1); (1; 0; 2); (5; 2; 9)\nf (cid:0) (cid:0) g",
      "(e) 2, 3, 2, (1; 2; 1); (1; 0; 2)\nf (cid:0) g"
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-04",
    "numero": 4,
    "enunciado": "Dada a matriz de transformação linear\n1 3 2\nA = 2 1 1\n0 1\n3 2 3\nPSfrag replacements @ A\nMáquina Cliente",
    "alternativas": [
      "(a) o vetor (1, 0, 0) é mapeMaeddoiapara (1, 3, 2).",
      "(b) o vetor (1, 0, 1) é mapPealadyoerpara (3, 0, 2).\nBu(cid:11)er",
      "(c) o vetor (0, 1, 0) é mapeado para (3, 1, 2).\nMarcador",
      "(d) o vetor (0, 0, 1)dée Ámgaupa eBaadixoopara (3, 2, 3).\n(MAB)",
      "(e) o vetor (1, 1, 0) é mapeado para (3, 2, 3).\nMarcador\nde Á gua Alto\n(MAA)"
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-05",
    "numero": 5,
    "enunciado": "Seja T um tabuleiro xadrez n m. Denominamos um circuito equestre em T a\nn;m Máquina Servidora (cid:2) n;m\nMedia\nn;m\nexaStearvmerente uma vez, e que começa e termina numa mesma\n5;5\né:\nP\n1\nP\n2\n(I)\n(II)\n(III)\n(IV)\nFigura 1: Exemplo de movimentos válidos de um cavalo.",
    "alternativas": [
      "(a) 0",
      "(b) 1",
      "(c) 5",
      "(d) 25",
      "(e) 5!"
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-06",
    "numero": 6,
    "enunciado": "Considere a função f (x) = 1=x. Seja A a área compreendida entre o gráfico de f e o\n1\n1",
    "alternativas": [
      "(a) A < e A < V .\n1\n1 1\n(c) A < e V = .\n1 1\n1 1\n(e) A = e V < .\n1 1",
      "",
      "",
      "",
      ""
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-07",
    "numero": 7,
    "enunciado": "Considere as afirmações a seguir:\n(I) Se f : R R é uma função tal que f (x) = f ( x) para todo x R e f é derivável\n(cid:0)! (cid:0) 2\nno ponto a = 0, então f 0(0) = 0.\n1\ne lim n!0 a n = 0, então lim n!0 a nb n não existe.\ne\n= 3.\n2 !",
    "alternativas": [
      "(a) Somente as afirmações (I), (III) e (V) são verdadeiras.\n(c) Somente as afirmações (I) e (V) são verdadeiras.\n(e) Somente as afirmações (II), (III) e (IV) são verdadeiras.\n(MAB)\nMarcador",
      "",
      "",
      "",
      ""
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-08",
    "numero": 8,
    "enunciado": "Na figura abaixo, a curva é o gráfico dadefuÁngçuaãoAlfto(x) = x2 e a região marcada no\nf Má2quina Se(cid:20)rvid(cid:20)ora (cid:20) (cid:20) g\nMedia\nServer\nP\n0\nR P 1\nP\n2\n(I)\n(II)\n(III)\ni i+1 (IV)",
    "alternativas": [
      "(a)\n(i+1)2\n3",
      "(b) 2i+1\n2",
      "(c) 3i+2\n3",
      "(d) 3i2 +3i+1\n3",
      "(e) i + 1"
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-09",
    "numero": 9,
    "enunciado": "A sequência x é definida recursivamente por\nn\n1 se n = 0;\nx =\nn+1 (1 + 1+1\nxn\ncaso contrário.",
    "alternativas": [
      "(a) L = 1",
      "(b) L = 1 + 1\n2",
      "(c) L = 2",
      "(d) L = 1 + 1\n2\nq",
      "(e) L = p2"
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-10",
    "numero": 10,
    "enunciado": "Uma equação do segundo grau em x e y, da forma ax2 + by 2 + cxy + dx + ey + f = 0,",
    "alternativas": [
      "(a) Uma curva arbitrária.\n(c) Uma reta.\n(e) Simultaneamente duas parábolas.",
      "",
      "",
      "",
      ""
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-11",
    "numero": 11,
    "enunciado": "Denote por x; y o produto escalar dos vetores x = (x ; x ; x ) e y = (y ; y ; y ) em\nh i 1 2 3 1 2 3\nh i 2",
    "alternativas": [
      "(a) a circunferência de raio r e centro 1\n(c) um plano com vetor normal 1\n(e) um hiperbolóide",
      "",
      "",
      "",
      ""
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-12",
    "numero": 12,
    "enunciado": "Determine qual das seguintes proposições não pode ser provada a partir da premissa:\n((a b) c) (c d)\n^ _ ^ !",
    "alternativas": [
      "(a) (a d) (b d)\n_ ^ _\n: _ : ! ^\n(c) (a b) d\n^ ! :\n: !\n(e) d b\n: !",
      "",
      "",
      "",
      ""
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-13",
    "numero": 13,
    "enunciado": "Dadas as quatro premissas:\nSe o universo é finito, então a vida é curta.\n(cid:15)\nSe a vida vale a pena, então a vida é complexa.\n(cid:15)\nSe a vida é curta ou complexa, então a vida tem sentido.\n(cid:15)\nA vida não tem sentido.\n(cid:15)\n(I) se o universo é finito e a vida vale a pena, então a vida tem sentido;\n(II) a vida não é curta;",
    "alternativas": [
      "(a) Somente (I) e (III)",
      "(b) Somente (II) e (III)",
      "(c) Somente (I) e (II)",
      "(d) (I), (II) e (III)",
      "(e) Somente a assertiva (I)."
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-14",
    "numero": 14,
    "enunciado": "Considere a seguinte proposição:\nP : x[B x [Lx C x]]\n8 ! ^\n:",
    "alternativas": [
      "(a) x [B x [Lx C x]].\n8 : ! ^",
      "(b) x[B x [ Lx C x]].\n9 ^ : _ :",
      "(c) x[B x [Lx C x]].\n8 ! : ^",
      "(d) x[ B x [ Lx C x]].\n9 : ^ : _ :",
      "(e) x[ B x [Lx C x]].\n9 : _ ^"
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-15",
    "numero": 15,
    "enunciado": "Quantas cadeias de 7 bits contêm pelo menos 3 zeros consecutivos?",
    "alternativas": [
      "(a) 81",
      "(b) 80",
      "(c) 48",
      "(d) 47",
      "(e) 16"
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-16",
    "numero": 16,
    "enunciado": "Sejam a; b e n inteiros, com n > 0. Considere a equação\nax b (mod n):\n(cid:17)",
    "alternativas": [
      "(a) A equação acima não tem solução.",
      "(b) A equação acima sempre tem solução.",
      "(c) A equação acima tem solução se mdc(a; n) = 1.",
      "(d) A equação acima tem solução se mdc(a; b) = 1.",
      "(e) A equação acima tem solução se mdc(b; n) = 1."
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-17",
    "numero": 17,
    "enunciado": "O número máximo de nós no nível i de uma árvore binária é:",
    "alternativas": [
      "(a) 2i+1, i 0\n(cid:21)",
      "(b) 2i(cid:0)1, i 1\n(cid:21)",
      "(c) 2i, i 1\n(cid:21)",
      "(d) 2i + 1, i 1\n(cid:21)",
      "(e) 2i 1, i 1\n(cid:0) (cid:21)"
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-18",
    "numero": 18,
    "enunciado": "Dadas as seguintes afirmações:\n(I) se R é uma relação transitiva, a sua inversa também é transitiva.\n(II) se R é uma relação re(cid:13)exiva, anti-simétrica e transitiva, então a sua inversa\ntambém é uma relação re(cid:13)exiva, anti-simétrica e transitiva.",
    "alternativas": [
      "(a) Somente (I) e (II)",
      "(b) Somente (II) e (III)",
      "(c) Somente (I) e (III)",
      "(d) (I), (II) e (III)",
      "(e) Somente (I) é verdadeira.\nMarcador\nde Á gua Alto"
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-19",
    "numero": 19,
    "enunciado": "Considere(MquAeAt)odos os relês do circuito representado na figura abaixo funcionam inde-\nMedia\nServer\nP\n0\nP\nP1 A 1 2 B\n2\n(I)\n(II) 3 4\n(III)\n(IV)",
    "alternativas": [
      "(a) p2",
      "(b) 2p2",
      "(c) p4",
      "(d) 2p2 p4\n(cid:0)",
      "(e) 4p"
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-20",
    "numero": 20,
    "enunciado": "Seja R o reticulado no plano formado pelos pares de números inteiros no intervalo\n(cid:0)\nR = (i; j ) Z2 : 2n i 2n e 2n j 2n ;\n2 (cid:0) (cid:20) (cid:20) (cid:0) (cid:20) (cid:20)\nS = (x; y) R2 : x2 + y2 = n2 :\n(cid:8) 2 (cid:9)",
    "alternativas": [
      "(a) 0; 5 (4n + 1)2\n(cid:1)",
      "(b) 0; 5 4 (i; j ) Z2 : i2 + j 2 < n2 e i > 0; j > 0 .\n(cid:1) (cid:1) jf 2 gj",
      "(c) 0; 5 (cid:25)n2\n(cid:1)",
      "(d) 0; 5\n(cid:25)n2\n(cid:1) (4n+1)2",
      "(e) 0; 5 (i; j ) Z2 : i2 + j 2 < n2 .\n(cid:1) jf 2 gj\nQUESTÕES DE FUNDAMENTOS DA COMPUTAÇÃO"
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-21",
    "numero": 21,
    "enunciado": "Considere uma cpu usando uma estrutura pipeline com 5 estágios (IF, ID, EX, MEM,\nI1: lw $2, 100($5)\nI2: add $1, $2, $3\nI3: sub $3, $2, $1\nI4: sw $2, 50($1)\nI5: add $2, $3, $3\nI6: sub $2, $2, $4",
    "alternativas": [
      "(a) 30",
      "(b) 17",
      "(c) 16",
      "(d) 11",
      "(e) 10"
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-22",
    "numero": 22,
    "enunciado": "Para a representação de número ponto (cid:13)utuante no padrão IEEE, quais das afirmações\n(I) Quando a fração e o expoente são zero, o número representado é zero.\n(II) Quando o expoente é zero, o número representado é desnormalizado.\n+ ou .\n1 (cid:0)1\na representação não é número.",
    "alternativas": [
      "(a) Somente as afirmações (II), (III) e (IV).",
      "(b) Somente as afirmações (I), (II) e (IV).",
      "(c) Somente as afirmações (I), (II) e (III).",
      "(d) Somente as afirmações (I), (III) e (IV).",
      "(e) Todas as afirmações."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-23",
    "numero": 23,
    "enunciado": "Das afirmações a seguir, sobre memória cache, quais são verdadeiras?\n(I) Numa estrutura totalmente associativa, um bloco de memória pode ser mapeado\nem qualquer slot do cache.\n(II) O campo tag do endereço é usado para identificar um bloco válido no cache, junto\ncom o campo de índice.\ndireto.",
    "alternativas": [
      "(a) Somente as afirmações (I), (III) e (IV).",
      "(b) Somente as afirmações (II), (III) e (IV).",
      "(c) Somente as afirmações (I) e (II).",
      "(d) Somente as afirmações (I), (II) e (III).",
      "(e) Somente as afirmações (II) e (III)."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-24",
    "numero": 24,
    "enunciado": "Considere as seguintes expressões booleanas:\n(A) (a b) + (c d e)\n(cid:1) (cid:1) (cid:1)\n(B) (a b) (c d e)\n(cid:1) (cid:1) (cid:1) (cid:1)\n(C) (a + b) (c + d + e)\n(cid:1)\n(D) (a + b) + (c + d + e)\n(I) A é equivalente a B.\n(II) C é equivalente a D.",
    "alternativas": [
      "(a) Somente as afirmações (I) e (II) são verdadeiras.",
      "(b) Somente as afirmações (I) e (III) são verdadeiras.",
      "(c) Somente as afirmações (II) e (IV) são verdadeiras.",
      "(d) Todas as afirmações são verdadeiras.",
      "(e) Todas as afirmações são falsas."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-25",
    "numero": 25,
    "enunciado": "Uma lista ligada possui a seguinte definição de nó:\ntype ap = no;\n\"\nno = record\ninfo : integer;\nlink : ap\nend;\nprocedure inverte(var h: no);\n\"\nvar p,q : no;\n\"\nbegin\nif h <> NIL\nthen begin\np := h link;\n:\n\"\nh link := NIL;\n:\n\"\nwhile p <> NIL do\nbegin\n;\n;\n;\n;\nend\nend\nend;",
    "alternativas": [
      "(a) p link:=h; q:=p link; h:=p; p:=q;\n: :\n\" \"\n: :\n\" \"\n(c) p link:=h; h:=p; p:=q; q:=p link;\n: :\n\" \"\n: :\n\" \"\n(e) p link:=h; h:=p; q:=p link; p:=q;\n: :\n\" \"",
      "",
      "",
      "",
      ""
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-26",
    "numero": 26,
    "enunciado": "Considere um heap H com 24 elementos tendo seu maior elemento na raiz. Em quantos",
    "alternativas": [
      "(a) 18",
      "(b) 15",
      "(c) 14",
      "(d) 13",
      "(e) 12"
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-27",
    "numero": 27,
    "enunciado": "Dadas as seguintes características para uma Á rvore B de ordem n:\n(I) Toda página contém no máximo 2n itens (chaves).\n(II) Toda página, exceto a página raiz, contém no mínimo n itens.\nnúmero de chaves.",
    "alternativas": [
      "(a) As características (I), (II), (III) e (IV) são falsas.",
      "(b) As características (I) e (IV) são verdadeiras.",
      "(c) As características (II), (III) e (IV) são verdadeiras.",
      "(d) As características (I), (II), (III) e (IV) são verdadeiras.",
      "(e) As características (II), (III) e (IV) são falsas"
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-28",
    "numero": 28,
    "enunciado": "Qual das seguintes afirmações é falsa?",
    "alternativas": [
      "(a) Dada uma máquina de Turing M com alfabeto de entrada (cid:6) e uma string w (cid:6),\n2\nnão se sabe se a computação de M com entrada w vai ou não parar.",
      "(b) O problema da parada é indecidível.",
      "(c) Não existe algoritmo que determina quando uma gramática livre de contexto\narbitrária é ambígua.",
      "(d) Não existe autômato finito determinístico que reconheça alguma linguagem livre\nde contexto.",
      "(e) Um autômato com duas pilhas pode ser simulado por uma máquina de Turing."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-29",
    "numero": 29,
    "enunciado": "Considere as seguintes afirmações:\n(I) O paradigma da programação funcional é baseado em funções matemáticas e com-\nposição de funções.\ncada do cálculo de predicados e seu método de inferência é uma forma restrita de\nResolução.\ne usam um processo de inferência lógica para produzir resultados.",
    "alternativas": [
      "(a) Somente (I) e (V).\n(c) Somente (I), (II) e (V).\n(e) Todas as afirmações são verdadeiras.",
      "",
      "",
      "",
      ""
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-30",
    "numero": 30,
    "enunciado": "Dadas duas funções f ; g : N R, dizemos que f = o(g) se lim n!1 f (n)=g(n) = 0.\n!\n2",
    "alternativas": [
      "(a) para todo (cid:15) > 0, existe n > 0 tal que T (n) log n < (cid:15) para todo n > n .\n0 j (cid:0) 2 j 0\n0 (cid:20) 2 0\n(c) existem constantes c > 0 e n > 0 tais que T (n) c log n para todo n > n .\n0 (cid:20) 2 0\n1 2 0 1 2 (cid:20) (cid:20) 2 2\npara todo n > n .\n0\n(e) existem constantes c > 0 e n > 0 tais que T (n) c log n para todo n > n .\n0 (cid:21) 2 0",
      "",
      "",
      "",
      ""
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-31",
    "numero": 31,
    "enunciado": "Considere o programa :\nif n < 1 then FUN := 1\nelse begin\nx := n * FUN (n-1);\nm := m-1;\nFUN := m+x;\nend;\nreadln (m,n);\nwriteln (m, n, FUN ( n ) );",
    "alternativas": [
      "(a) 5, 4, 5\n(c) 1, 4, 14400\n(e) 1, 4, 120",
      "",
      "",
      "",
      ""
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-32",
    "numero": 32,
    "enunciado": "Considere o algoritmo máximo(v; i; f ) que devolve o índice de um elemento máximo de\nv[i]; : : : ; v[f ] :\nmáximo(v; i; f )\nse i = f , devolva i\np máximo(v; i; (i + f )=2 )\nb c\nq máximo(v; (i + f )=2 + 1; f )\nb c\nse v[p] v[q], devolva p\n(cid:21)\ndevolva q\nmáximo(v(cid:0)\n; i; f ) é",
    "alternativas": [
      "(a) n log n\n2",
      "(b) n=2",
      "(c) n 1\n(cid:0)",
      "(d) log n\n2",
      "(e) 2n"
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-33",
    "numero": 33,
    "enunciado": "Um algoritmo de ordenação é estável se a ordem relativa dos itens com chaves iguais\n(I) BubbleSort (ordenação por bolha);\n(II) InsertionSort (ordenação por inserção);",
    "alternativas": [
      "(a) Somente (II).",
      "(b) Somente (I) e (II).",
      "(c) Somente (I), (II) e (III).",
      "(d) Somente (II), (III) e (IV).",
      "(e) Somente (I), (III) e (IV)."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-34",
    "numero": 34,
    "enunciado": "Seja A = a ; : : : ; a uma sequência de n números, todos distintos entre si. Dados\n1 n\nj i\n(cid:20) (cid:20)",
    "alternativas": [
      "(a) n\n2\n(c) n(cid:0) (cid:1) 1\n(cid:0)\n(e) n2",
      "",
      "",
      "",
      ""
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-35",
    "numero": 35,
    "enunciado": "Em uma estrutura de árvore binária de busca, foram inseridos os elementos \\h\",\\a\",\\b\",",
    "alternativas": [
      "(a) 2\n(c) 4\n(e) 3",
      "",
      "",
      "",
      ""
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-36",
    "numero": 36,
    "enunciado": "Quatro tarefas, A, B, C e D, estão prontas para serem executadas num único proces-",
    "alternativas": [
      "(a) C, D, B, A\n(c) C, B, D, A\n(e) O tempo médio de resposta independe da ordem.",
      "",
      "",
      "",
      ""
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-37",
    "numero": 37,
    "enunciado": "Qual das alternativas a seguir melhor define uma Região Crítica em Sistemas Opera-",
    "alternativas": [
      "(a) Um trecho de programa que deve ser executado em paralelo com a Região Crítica\nde outro programa.",
      "(b) Um trecho de programa cujas instruções podem ser executadas em paralelo e em\nqualquer ordem.",
      "(c) Um trecho de programa onde existe o compartilhamento de algum recurso que\nnão permite o acesso concomitante por mais de um programa.\n(PdS) frUamg rterpelcahcoemdeenptsrograma onde existe algum recurso cujo acesso é dado por uma\nprioridade.\nMáquina Cliente\n(e) Um trecho dMeedpiraograma onde existe algum recurso a que somente o sistema ope-\nracional podPelayteerr acesso.",
      "",
      ""
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-38",
    "numero": 38,
    "enunciado": "Á rvores binárias pB ou(cid:11) de er m ser usadas para guardar e recuperar informações com número\nMarcador\n(MAB)\nMarcador\nde Á gua Alto\n(MAA)\nMáquina Servidora\n(I)\nMedia\nServer (II)\nP\n0\nP\n1\nP\n2\n(III) (IV)",
    "alternativas": [
      "(a) Somente (I) e (IV) são árvores binárias AVL.",
      "(b) Somente (I) é árvore binária AVL.",
      "(c) Somente (I), (II) e (III) são árvores binárias AVL.",
      "(d) Somente (II) e (III) são árvores binárias AVL.",
      "(e) Todas (I), (II), (III) e (IV) são árvores binárias AVL.\nMedia"
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-39",
    "numero": 39,
    "enunciado": "Os grafos GSe=rver(V ; E ) e H = (V ; E ) são isomorfos. Assinale a alternativa que\nG G H H\nP\n1\nP\n2\n(I)\n(II)\n(III)\n(IV) G H",
    "alternativas": [
      "(a) As sequências dos graus dos vértices de G e H são iguais.\n(c) Existe uma bijeção de V em V que preserva adjacências.\nG H\n(e) Ambos os grafos admitem um circuito que passa por cada aresta exatamente uma\nvez.",
      "",
      "",
      "",
      ""
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-40",
    "numero": 40,
    "enunciado": "Dadas as seguintes afirmações\n(I) Qualquer grafo conexo com n vértices deve ter pelo menos n 1 arestas.\n(cid:0)\nm;n",
    "alternativas": [
      "(a) Somente a afirmação (I).\n(c) Somente as afirmações (II) e (III).\n(e) Todas as afirmações.\nQUESTÕES DE TECNOLOGIA DA COMPUTAÇÃO",
      "",
      "",
      "",
      ""
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-41",
    "numero": 41,
    "enunciado": "Qual das seguintes afirmações é verdadeira?",
    "alternativas": [
      "(a) Nem toda relação que está na FNBC (Forma Normal de \\Boyce-Codd\") está\ntambém na 3FN (Terceira Forma Normal).\n(c) Se a relação R está na 3FN e toda chave candidata é simples, então não podemos\nafirmar que R está na FNBC.\ntrivial somente se XY = R .\n(e) Uma dependência funcional multivalorada na relação R, na forma X(cid:16)Y, é dita\ntrivial se Y X ou XY = R\n(cid:18)",
      "",
      "",
      "",
      ""
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-42",
    "numero": 42,
    "enunciado": "Em um banco de dados relacional, considere os esquemas de relação:\nPessoa (CPF, Profissao)\n(cid:15)\nTrabalha (CPF, CGC, Periodo)\n(cid:15)\nFirma (CGC, nome, endereco)\n(cid:15)",
    "alternativas": [
      "(a) Interseção de Pessoa, Trabalha e Firma.\n(c) União de Pessoa, Trabalha e Firma.\n(e) Nada pode ser afirmado porque os dados não foram fornecidos.",
      "",
      "",
      "",
      ""
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-43",
    "numero": 43,
    "enunciado": "Em um banco de dados relacional, considere os esquemas de relação:\nPessoa (CPF, Profissao)\n(cid:15)\nTrabalha (CPF, CGC, Periodo)\n(cid:15)\nFirma (CGC, nome, endereco)\n(cid:15)\nC1 Quais as profissões de todas as pessoas?\nC2 Qual a profissão da pessoa de CPF = ’X’, onde X é um CPF válido?\nC3 Qual o endereço da firma de CGC diferente de ’Z’, onde Z é um CGC válido?\nC4 Quais os períodos na década 1990-1999 em que ningúem trabalhou, onde o banco\nde dados contém informações entre 1980 e 2005?",
    "alternativas": [
      "(a) A consulta C1 porque só exige uma pro jeção na relação Pessoa sem precisar olhar\no índice.\nacessar Pessoa.\n(c) A consulta C3 porque pode ser processada sequencialmente sobre a relação Firma\ndescartando-se a tupla com CGC de valor Z.\nrelação Trabalha.\n(e) Nada se pode afirmar porque rapidez, neste caso, não pode ser medida.",
      "",
      "",
      "",
      ""
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-44",
    "numero": 44,
    "enunciado": "Sejam T1 e T2 duas transações sendo processadas por um SGBD. Os termos lockR\n(I) O trecho mostra um exemplo de aplicação do protocolo 2PL (two phase lock ou\ntranca em 2 fases).",
    "alternativas": [
      "(a) Somente (I) e (III)\n(c) Somente (II) e (III)\n(e) Somente (V)",
      "",
      "",
      "",
      ""
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-45",
    "numero": 45,
    "enunciado": "No processo de geração de um código executável (em linguagem de máquina) a par-",
    "alternativas": [
      "(a) B C H G A D F E\n(c) B C H G A D E F\n(e) B C H A G D E F",
      "",
      "",
      "",
      ""
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-46",
    "numero": 46,
    "enunciado": "No que diz respeito à geração de imagens por RayTracing, qual das afirmações a seguir",
    "alternativas": [
      "(a) O número de raios lançados independe do número de ob jetos da cena.\n(c) O lançamento de raios é dependente da posição da câmera.\n(e) Este método pode ser facilmente paralelizado.",
      "",
      "",
      "",
      ""
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-47",
    "numero": 47,
    "enunciado": "Requisitos são capacidades e condições para as quais um sistema deve ter conformidade.\n(I) No Processo Unificado, requisitos são categorizados de acordo com o modelo\nFURPS+, onde o U do acrônimo representa requisitos de usabilidade.\ncasos de uso é basicamente um ato de escrever estórias de uso de um sistema.\ncasos de uso, que ilustra os nomes dos casos de uso, atores e seus relacionamentos.",
    "alternativas": [
      "(a) Somente as afirmações (I) e (II) estão corretas.\n(c) Somente as afirmações (I) e (III) estão corretas.\n(e) Somente a afirmação (III) está correta.",
      "",
      "",
      "",
      ""
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-48",
    "numero": 48,
    "enunciado": "Qual das alternativas a seguir não representa um artefato da disciplina de Requisitos",
    "alternativas": [
      "(a) Modelo de Casos de Uso.\n(c) Modelo do Domínio.\n(e) Glossário.",
      "",
      "",
      "",
      ""
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-49",
    "numero": 49,
    "enunciado": "Considere as seguintes afirmações sobre o ob jetivo da atividade de validação de soft-\n(I) Verificar se o produto está sendo corretamente constrú(cid:16)do.",
    "alternativas": [
      "(a) Somente a afirmação (II).\n(c) Somente as afirmações (I) e (II).\n(e) Afirmações (I), (II) e (III).",
      "",
      "",
      "",
      ""
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-50",
    "numero": 50,
    "enunciado": "Considere as seguintes afirmações sobre o diagrama de classes e outros modelos UML\n(I) O diagrama de classes pode representar as classes sob diferentes perspectivas, tais\ncomo a conceitual, a de especificação e a de implementação.\nmensagens.",
    "alternativas": [
      "(a) Somente a afirmação (I).\n(c) Somente as afirmações (I) e (III).\n(e) Afirmações (I), (II) e (III).",
      "",
      "",
      "",
      ""
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-51",
    "numero": 51,
    "enunciado": "A Atividade de Teste é considerada uma atividade dinâmica, pois implica na execução",
    "alternativas": [
      "(a) de pro jeto.\n(c) inicial de desenvolvimento.\n(e) de validação.",
      "",
      "",
      "",
      ""
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-52",
    "numero": 52,
    "enunciado": "Dentre as definições a seguir, conceitos de computação evolutiva da Inteligência Arti-",
    "alternativas": [
      "(a) A computação evolutiva deve ser entendida como um conjunto de técnicas e pro-\ncedimentos genéricos e adaptáveis, a serem aplicados na solução de problemas\ncomplexos, para os quais outras técnicas conhecidas são ineficazes ou nem sequer\nsão aplicáveis.\nções potenciais, aplicam processos de seleção baseados na adaptação de um in-\ndivíduo e também empregam outros operadores \\genéticos.\"\n(c) A roleta é um método de seleção no qual se atribui a cada indivíduo de uma po-\npulação uma probabilidade de passar para a próxima geração proporcional ao seu\nfitness, medido em relação à somatória do fitness de todos os indivíduos da popu-\nlação. Assim, algoritmos genéticos são métodos de busca puramente aleatórios.\nlução natural e da genética. Um indivíduo da população é representado por um\núnico cromossomo, o qual contém a codificação (genótipo) de uma possível solução\ndo problema (fenótipo).\n(e) O processo de evolução executado por um algoritmo genético corresponde a um\nprocedimento de busca em um espaço de soluções potenciais para o problema.",
      "",
      "",
      "",
      ""
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-53",
    "numero": 53,
    "enunciado": "Considere as cláusulas:",
    "alternativas": [
      "(a) L(C; C; g(A; C ); D)\n(c) L(x; C; g(A; C ); D)\n(e) L(A; A; g(A; A); D)",
      "",
      "",
      "",
      ""
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-54",
    "numero": 54,
    "enunciado": "Considere h(x) como uma função heurística que define a distância de x até a meta;",
    "alternativas": [
      "(a) n h(n) hr (n).\n9 (cid:20)\n8 (cid:20)\n(c) n h(n) > hr (n).\n8\n9\n(e) n h(n) < hr (n).\n9",
      "",
      "",
      "",
      ""
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-55",
    "numero": 55,
    "enunciado": "Inspeção de Usabilidade é o nome genérico para um conjunto de métodos baseados em",
    "alternativas": [
      "(a) Avaliação Heurística.\n(c) Walktrough Cognitivo.\n(e) Revisões de Guidelines.",
      "",
      "",
      "",
      ""
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-56",
    "numero": 56,
    "enunciado": "Modelos gráficos, desenvolvidos para uso humano em displays convencionais devem ser\n(I) tamanho e textura;\n(II) contraste, claridade e brilho;",
    "alternativas": [
      "(a) Somente as afirmações (I) e (II) estão corretas.",
      "(b) Somente as afirmações (II) e (III) estão corretas.",
      "(c) Somente as afirmações (I) e (III) estão corretas.",
      "(d) As afirmações (I), (II) e (III) estão corretas.",
      "(e) Somente a afirmação (III) está correta."
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-57",
    "numero": 57,
    "enunciado": "O desenvolvimento de protótipos de sistemas e suas interfaces de usuário possibilitam\n(I) Na prototipação vertical, a interface de usuário é mostrada ao usuário em uma\nsérie de representações pictóricas da interface chamadas storyboards;\n(II) Na prototipação dirigida (Chau(cid:11)eured Prototyping), o usuário observa enquanto\numa outra pessoa, usualmente um membro da equipe de desenvolvimento, interage\ncom o sistema;\nmas em lugar de respostas do sistema, estas são enviadas por um desenvolvedor\nsentado em outra máquina.",
    "alternativas": [
      "(a) Somente as afirmações (I) e (II) estão corretas.",
      "(b) Somente as afirmações (II) e (III) estão corretas.",
      "(c) Somente as afirmações (I) e (III) estão corretas.",
      "(d) As afirmações (I), (II) e (III) estão corretas.",
      "(e) Somente a afirmação (III) está correta."
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-58",
    "numero": 58,
    "enunciado": "Considere o esquema abaixo para download de um (cid:13)uxo de áudio na Internet. Considere\nMáquina Cliente Máquina Servidora\nBu(cid:11)er\nPlayer Server\nde Á gua Baixo de Á gua Alto\n(MAB) (MAA)",
    "alternativas": [
      "(a) MAA 40 KB e MAB 980 KB.\n(cid:21) (cid:20)\n(cid:21) (cid:20)\n(c) MAA 40 KB e MAB 960 KB.\n(cid:21) (cid:20)\n(cid:21) (cid:20)\n(e) MAA 20 KB e MAB 1 MB.\n(cid:21) (cid:20)",
      "",
      "",
      "",
      ""
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-59",
    "numero": 59,
    "enunciado": "O processo de análise de imagens é uma sequência de etapas que são iniciadas a partir",
    "alternativas": [
      "(a) pré-processamento, aquisição, segmentação, representação, reconhecimento.\n(c) aquisição, pré-processamento, representação, segmentação, reconhecimento.\n(e) pré-processamento, aquisição, representação, segmentação, reconhecimento.",
      "",
      "",
      "",
      ""
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-60",
    "numero": 60,
    "enunciado": "O termo imagem se refere a uma função bidimensional de intensidade de luz, denotada",
    "alternativas": [
      "(a) translação e escala.\n(c) resolução e ampliação.\n(e) resolução e quantização.",
      "",
      "",
      "",
      ""
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-61",
    "numero": 61,
    "enunciado": "Qual a capacidade máxima segundo o Teorema de Nyquist de um canal de 2 MHz sem",
    "alternativas": [
      "(a) 4 Mbps\n(c) 8 Mbps\n(e) 16 Mbps",
      "",
      "",
      "",
      ""
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-62",
    "numero": 62,
    "enunciado": "A aplicação A deseja enviar a mensagem m para a aplicação B com as propriedades\n(I) A criptografa m usando PUBB e depois PRIA.\n(II) A criptografa m usando PUBB e depois PUBA.",
    "alternativas": [
      "(a) Somente (I) e (II).",
      "(b) Somente (II) e (IV).",
      "(c) Somente (I) e (III).",
      "(d) Somente (III) e (IV).",
      "(e) Todas as alternativas."
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-63",
    "numero": 63,
    "enunciado": "Os protocolos de transporte atribuem a cada serviço um identificador único, o qual",
    "alternativas": [
      "(a) Endereço IP.",
      "(b) Porta.",
      "(c) Conexão.",
      "(d) Identificador do processo (PID).",
      "(e) Protocolo de aplicação."
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-64",
    "numero": 64,
    "enunciado": "O DNS (Domain Name System) é um serviço de diretórios na Internet que:",
    "alternativas": [
      "(a) Traduz o nome de um hospedeiro (host) para seu endereço IP.",
      "(b) Localiza a instituição à qual um dado host pertence.",
      "(c) Retorna a porta da conexão TCP do host.",
      "(d) Retorna a porta da conexão UDP do host.",
      "(e) Traduz o endereço IP de um hospedeiro para um nome de domínio na Internet."
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-65",
    "numero": 65,
    "enunciado": "Um dos mecanismos de congestionamento na rede é o que utiliza temporizadores de",
    "alternativas": [
      "(a) A quantidade de mensagens não confirmadas na transmissão, num dado instante,\ndeve ser superior ao mínimo entre a Janela de Congestionamento e a Janela de\nRecepção desta conexão.",
      "(b) A Janela de Congestionamento dobra de tamanho (cresce exponencialmente)\nquando a confirmação das mensagens enviadas ocorre antes dos temporizadores\nde retransmissão se esgotarem (time-out), até o limite do Patamar.",
      "(c) Após exceder o valor de Patamar ainda sem esgotar os temporizadores, a janela\ndecresce linearmente.",
      "(d) Quando excede o valor de Patamar e esgotam os temporizadores, a janela decresce\nexponencialmente.",
      "(e) Todas as alternativas estão corretas."
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-66",
    "numero": 66,
    "enunciado": "Algoritmos de roteamento são o meio que um roteador utiliza para encaminhar men-",
    "alternativas": [
      "(a) Nos algoritmos de roteamento estáticos as rotas são determinadas via tabelas\ndefinidas a priori e fixadas para o roteador, em geral manualmente.",
      "(b) No roteamento de Estado de Enlace (Link State), os valores dos enlaces são cal-\nculados pelo pro jetista da rede e os roteadores atualizam suas tabelas por estes\nvalores.",
      "(c) No roteamento por Vetor de Distância (Distance Vector), as tabelas de roteamento\ndefinidas pelos roteadores vizinhos são repassadas periodicamente a cada roteador\npara obtenção de sua própria tabela.",
      "(d) Algoritmos de roteamento buscam estabelecer o caminho de menor custo entre\ndois hosts através do cálculo dos custos acumulados mínimos entre os enlaces\ndisponíveis, dada a topologia da rede.",
      "(e) O OSPF é um exemplo de protocolo de roteamento baseado em Estado de Enlace e\no BGP é um exemplo de protocolo de roteamento baseado em Vetor de Distâncias."
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-67",
    "numero": 67,
    "enunciado": "Sejam as afirmações:\n(I) O HTTP e o FTP são protocolos da camada de aplicação e utilizam o protocolo\nde transporte TCP.\nferência e outra para envio dos dados transferidos (controle fora da banda).\nconexões não persistentes. O modo default do HTTP/1.1 usa conexões persistentes.",
    "alternativas": [
      "(a) (I), (II) e (III) são verdadeiras.\n(c) Somente (I) é verdadeira.\n(e) (I), (II) e (III) são falsas.",
      "",
      "",
      "",
      ""
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-68",
    "numero": 68,
    "enunciado": "Segundo o W3C (World Wide Web Consortium), um Serviço Web é um sistema de",
    "alternativas": [
      "(a) A interface do Serviço Web é descrita em WSDL.\n(c) O transporte das mensagens é feito tipicamente pelo HTTP.\n(e) Cliente e Servidor devem ser escritos na mesma linguagem de programação.",
      "",
      "",
      "",
      ""
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-69",
    "numero": 69,
    "enunciado": "Considere o diagrama espaço-tempo da Figura 2; ele representa uma computação dis-\n0 10 20 30 40 50 60 70 80 90 100\n0\n0 7\nP\n1\nP\n2\n0 5 10 15 20 25 30 35\nFigura 2: Diagrama espaço-tempo.",
    "alternativas": [
      "(a) P (14; 21; 28; 35; 42; 49; 56; 63; 70) P (40; 45; 50)\n1 2\n1 2\n(c) P (8; 15; 22; 29; 36; 61; 68; 75; 88) P (40; 69; 74)\n1 2\n1 2\n(e) P (8; 15; 22; 29; 36; 49; 56; 63; 70) P (40; 45; 50)\n1 2",
      "",
      "",
      "",
      ""
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2005,
    "id": "2005-70",
    "numero": 70,
    "enunciado": "A abordagem geral para tolerância a falhas é o uso de redundância. Considere as\n(I) Um exemplo de redundância de informação é o uso de bits extras para permitir\na recuperação de bits corrompidos.\n(II) Redundância de tempo é útil principalmente quando as falhas são transientes ou\nintermitentes.\nprimário.",
    "alternativas": [
      "(a) Somente as afirmações (I),(II) e (III).",
      "(b) Somente as afirmações (I), (II) e (IV).",
      "(c) Somente as afirmações (I), (III) e (IV).",
      "(d) Somente as afirmações (II), (III) e (IV).",
      "(e) Todas as afirmações."
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-01",
    "numero": 1,
    "enunciado": "Qual é o número inteiro mais próximo de log 1.000.000?\n2",
    "alternativas": [
      "(a) 6",
      "(b) 10",
      "(c) 20",
      "(d) 100",
      "(e) 1000"
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-02",
    "numero": 2,
    "enunciado": "Seja V um espaço vetorial real com produto interno. Para x e y vetores quaisquer de\n||x + y || = ||x|| + ||y ||",
    "alternativas": [
      "(a) x 6= 0 e y = λx para todo número real λ.",
      "(b) x = 0, ou y = 0, ou (x 6= 0 e y = λx) onde λ é um número real não-negativo.",
      "(c) x = 0, ou y = 0.",
      "(d) x = 0, ou y = 0, ou (x 6= 0 e x, y são linearmente dependentes).",
      "(e) x = 0, ou y = 0, ou (x 6= 0 e x, y são linearmente independentes).\n1 0"
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-03",
    "numero": 3,
    "enunciado": "Sobre a transformação linear T : R2 → R2 definida pela matriz podemos dizer\n−1 0",
    "alternativas": [
      "(a) a imagem é a reta y = x e o núcleo é {(0, 0)}",
      "(b) a imagem é a reta x = 0 e o núcleo é a reta y = −x",
      "(c) a imagem é a reta y = x e o núcleo é o R2",
      "(d) a imagem é a reta y = −x e o núcleo é a reta x = 0",
      "(e) a imagem é o R2 e o núcleo é a reta y = x"
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-04",
    "numero": 4,
    "enunciado": "A transformação T (x, y ) = 1 (−4x + 3y , 3x + 4y ) do plano no plano é\n5",
    "alternativas": [
      "(a) uma reflexão através da reta y = 3x",
      "(b) uma expansão uniforme",
      "(c) uma contração uniforme",
      "(d) uma translação",
      "(e) um cisalhamento horizontal"
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-05",
    "numero": 5,
    "enunciado": "No R3 com o produto escalar usual, tome v = (1, −1, 0) e o subespaço S gerado por",
    "alternativas": [
      "(a) (1/2, −1, 1/2)",
      "(b) (1, −1, 1)",
      "(c) (2/3, −1, 1/3)",
      "(d) (1/100, −1, 1/100)",
      "(e) (2, −1, 2)"
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-06",
    "numero": 6,
    "enunciado": "Considere o espaço amostral Ω = {ω1, ω2, . . . , ωn} onde ωi ocorre com probabilidade pi\nhx, yi = p1x1 y1 + p2x2 y2 + · · · + pnxnyn,\nhX, 1i\nhX − hX, 1i1, X − hX, 1i1i\n||X − hX, 1i1||",
    "alternativas": [
      "(a) média, variˆancia, desvio padrão",
      "(b) variˆancia, média, desvio padrão",
      "(c) média, desvio padrão, variˆancia",
      "(d) desvio padrão, média, variˆancia",
      "(e) desvio padrão, variˆancia, média"
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-07",
    "numero": 7,
    "enunciado": "Se A é uma matriz n × n de entradas reais, cujas linhas são linearmente independentes,",
    "alternativas": [
      "(a) A é inversível.",
      "(b) A · X = B tem solução única X para todo B ∈ Rn .",
      "(c) As colunas de A são linearmente independentes.",
      "(d) det(A) = 1.",
      "(e) O posto de A é n.\nn\nr + k"
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-08",
    "numero": 8,
    "enunciado": "A soma de coeficientes binomiais vale\nk\nk=0 (cid:18) (cid:19)\nX\n1 r − n + 1",
    "alternativas": [
      "(a)\n2 n\n(cid:18) (cid:19)\n1 r − 1 + n",
      "(b)\n2 n\n(cid:18) (cid:19)\nr + n",
      "(c)\nn − 1\n(cid:18) (cid:19)\nr + n",
      "(d)\nn + 1\n(cid:18) (cid:19)\nr + n + 1",
      "(e) .\nn\n(cid:18) (cid:19)"
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-09",
    "numero": 9,
    "enunciado": "De quantas maneiras distintas podemos distribuir m ≥ k centavos entre k meninas e `\nm m−k",
    "alternativas": [
      "(a)\nk `\nm−k",
      "(b) (cid:0) k+(cid:1)(cid:0)` (cid:1)",
      "(c)\n(cid:0)m+`+ (cid:1)k\nk+`−1",
      "(d)\n(cid:0)m+`−1\n(cid:1)\nk+`−1",
      "(e)\n(cid:0)m+`\n(cid:1)\nk+`\n(cid:0) (cid:1)"
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-10",
    "numero": 10,
    "enunciado": "Quais são as raízes da equação característica da relação de recorrência:\na1 = 0\na2 = 1\n\n\nan = −an−2 (n ≥ 3)",
    "alternativas": [
      "(a) 0, 1 e -1; ",
      "(b) i, 0 e -i;",
      "(c) i e -i.",
      "(d) 0 e 1;",
      "(e) 0 e -1;"
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-11",
    "numero": 11,
    "enunciado": "A sequência definida recursivamente por\nn−1\n2\nTn = n + 1 + Tk (∀n > 0; T0 = 0)\nn\nk=0\nX",
    "alternativas": [
      "(a) n, 1 e n\n2\nkn =− 02 Tk ;",
      "(b) n, (n + 1) e 2n.\nP\nn−2",
      "(c) n, 1 e 2n\nk=0\nTk ;",
      "(d) n, (n + 1) e 2 ;\nP n",
      "(e) n, 1 e n2 kn =− 02 Tk ;"
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-12",
    "numero": 12,
    "enunciado": "Num espaço fiPnito de probabilidades Ω com distribuição P : Ω → (0, 1), dados os eventos",
    "alternativas": [
      "(a) (I), (II)",
      "(b) (I), (III)",
      "(c) (I), (III), (IV)",
      "(d) (II), (III)",
      "(e) (III), (IV)"
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-13",
    "numero": 13,
    "enunciado": "Quantas cadeias de 7 bits não contêm 3 zeros consecutivos?",
    "alternativas": [
      "(a) 44",
      "(b) 48",
      "(c) 80",
      "(d) 81",
      "(e) 123"
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-14",
    "numero": 14,
    "enunciado": "Para uma função contínua f definida no intervalo [0, 1], quais dos itens abaixo são\n1 2 1\n(cid:18)Z0 (cid:19) Z0\n1 1\n(cid:12)Z0 (cid:12) Z0\n(cid:12) (cid:12) 1\n(cid:12) (cid:12)\nZ0",
    "alternativas": [
      "(a) (I), (II), (III)",
      "(b) (I), (II)",
      "(c) (I), (III)",
      "(d) (II), (III)",
      "(e) nenhum, todos são falsos"
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-15",
    "numero": 15,
    "enunciado": "Para fazermos uma caixa, removemos de uma folha quadrada de lado a um quadrado\nx x\nx x\nx x\nx x",
    "alternativas": [
      "(a) a solução de (a − 2x)(a − 6x) = 0 no intervalo (a/3, ∞)",
      "(b) a solução de (a − 2x)(a − 6x) = 0 no intervalo (−∞, a/3)",
      "(c) x = a/3",
      "(d) a solução positiva de x(a − 2x)2 = 0",
      "(e) o valor que maximiza a área da base da caixa, ou seja, o valor máximo da função\n(a − 2x)2."
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-16",
    "numero": 16,
    "enunciado": "A equação 2x2 + 2y 2 + 4xy − 4x − 4y + 2 = 0 descreve:",
    "alternativas": [
      "(a) Uma única reta.",
      "(b) Duas retas.",
      "(c) Um único ponto.",
      "(d) Uma elipse ou uma circunferência.",
      "(e) Uma parábola ou uma hipérbole."
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-17",
    "numero": 17,
    "enunciado": "Um reservatório cˆonico de altura H e raio R é preenchido com água de modo que V\n3\nR\nH\nr\nh\nh H\ndh 4 dV",
    "alternativas": [
      "(a) =\ndt πR2 dt\n(cid:18) (cid:19)\ndh 12 dV",
      "(b) =\ndt πR2 dt\n(cid:18) (cid:19)\ndh H 2 dV",
      "(c) = 3\ndt s πR2 dt\n(cid:18) (cid:19)\ndh H 2 dV",
      "(d) =\ndt s πR2 dt\n(cid:18) (cid:19)\ndh 12V",
      "(e) =\ndt πR2"
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-18",
    "numero": 18,
    "enunciado": "O valor do parˆametro m, para que o sistema\nx + y + (1 − m)z = 0\nx + (m − 1)y − z = 0\n\nx + my + z = 0\n",
    "alternativas": [
      "",
      "",
      "",
      "",
      ""
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-19",
    "numero": 19,
    "enunciado": "Zezé tem n reais. Todo dia compra exatamente 1 chocolate (2 reais) ou 1 brigadeiro",
    "alternativas": [
      "(a) bn = bn−1 + 2bn−2 , n ≥ 3; b1 = 1; b2 = 3",
      "(b) bn = 2bn−1 + bn−2 , n ≥ 3; b1 = 1; b2 = 3",
      "(c) bn = bn−1 + 2bn−2 , n ≥ 3; b1 = 1; b2 = 2",
      "(d) bn = 2bn−1 + bn−2 , n ≥ 3; b1 = 1; b2 = 2",
      "(e) bn = bn−1 + bn−2 , n ≥ 3; b1 = 1; b2 = 3"
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-20",
    "numero": 20,
    "enunciado": "Considere a fórmula e o domínio de interpretação a seguir:\n[ ∀x [ F x ⇒ [ E x ∧ T xa ] ] ] ∧\n[ ∃x [ [ E x ∧ T xa ] ∧ F x ] ] ∧\n[ ∃x [ [ E x ∧ T xa ] ∧ ¬F x ] ]",
    "alternativas": [
      "(a) Todos os estudantes que trabalharam mais que Alberto formaram-se.",
      "(b) Somente estudantes que trabalharam mais que Alberto formaram-se.",
      "(c) Alberto trabalhou mais que qualquer estudante que não se formou.",
      "(d) Somente estudantes que se formaram trabalharam mais que Alberto.",
      "(e) Todos os estudantes que não se formaram trabalharam menos que Alberto."
    ],
    "area_conhecimento": "Matemática",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-21",
    "numero": 21,
    "enunciado": "Seja Σ = {a, b}. Uma expressão regular denotando a linguagem L = {w ∈ Σ∗ tal que",
    "alternativas": [
      "(a) (a∗b)∗",
      "(b) (b + ab)∗",
      "(c) a∗b",
      "(d) b + (ab)∗",
      "(e) (ab)∗"
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-22",
    "numero": 22,
    "enunciado": "Quanto vale k no fim da execução do seguinte trecho de código?\nk = 0;\nfor (i=1; i <= n; i++)\nfor(j = i; j <= n; j++)\nk = k + 1;",
    "alternativas": [
      "(a) n − 1",
      "(b) n",
      "(c) (n2 − n)/2",
      "(d) n(n + 1)/2",
      "(e) n3"
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-23",
    "numero": 23,
    "enunciado": "O programa abaixo, quando executado para A(1, 2), faz quantas chamadas recursivas\nint A (int m, int n) {\nif (m == 0) return n + 1;\nelse if (n == 0) return A (m - 1, 1);\nelse return A (m - 1, A (m, n - 1));\n}",
    "alternativas": [
      "(a) 6",
      "(b) 5",
      "(c) 4",
      "(d) 3",
      "(e) 2"
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-24",
    "numero": 24,
    "enunciado": "Considere as seguintes estruturas de dados:",
    "alternativas": [
      "(a) Somente (I)",
      "(b) Somente (II)",
      "(c) Somente (III)",
      "(d) Somente (IV)",
      "(e) Todas."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-25",
    "numero": 25,
    "enunciado": "Considere as seguintes afirmativas sobre o algoritmo de pesquisa binária:",
    "alternativas": [
      "(a) Somente I e II.",
      "(b) Somente I, II e III.",
      "(c) Somente II e III.",
      "(d) Somente III e IV.",
      "(e) Todas as afirmativas estão corretas."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-26",
    "numero": 26,
    "enunciado": "Em sistemas de memória virtual de paginação sob demanda, qual seria o critério ideal",
    "alternativas": [
      "(a) retirar a página que acabou de ser referenciada",
      "(b) retirar a página que será necessária no futuro mais distante",
      "(c) retirar a página que está há mais tempo na memória",
      "(d) retirar a página que foi referenciada menos vezes",
      "(e) retirar a página que está há mais tempo sem ser utilizada"
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-27",
    "numero": 27,
    "enunciado": "Considere o seguinte programa com dois processos concorrentes. O escalonador poderá\nprograma P\nint x = 0;\nint y = 0;\nprocesso A {\nwhile (x == 0);\nprint(‘‘a’’);\ny = 1;\ny = 0;\nprint(‘‘d’’);\ny = 1;\n}\nprocesso B {\nprint(‘‘b’’);\nx = 1;\nwhile (y == 0);\nprint(\"c\");\n}",
    "alternativas": [
      "(a) adbc ou bcad",
      "(b) badc ou bacd",
      "(c) abdc ou abcd",
      "(d) dbca ou dcab",
      "(e) Nenhuma das opções anteriores."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-28",
    "numero": 28,
    "enunciado": "Qual das seguintes expressões posfixas é equivalente à expressão infixa A+(B/C)*((D-E)/F)?",
    "alternativas": [
      "(a) ABC/-DE*F+/",
      "(b) ABC/DE-/F+*",
      "(c) ABC/DE-F/*+",
      "(d) ABC/D-EF*/+",
      "(e) ABD/CE+/F-*"
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-29",
    "numero": 29,
    "enunciado": "Considerando A e B duas variáveis lógicas, a expressão (not(A) and B) or (A and",
    "alternativas": [
      "(a) para todos os valores de A e de B",
      "(b) sempre que A é igual a B",
      "(c) sempre que A é diferente de B",
      "(d) sempre que A é falso",
      "(e) sempre que B é falso"
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-30",
    "numero": 30,
    "enunciado": "Ao segmentar um processador, transformando-o num pipeline, obtém-se:",
    "alternativas": [
      "(a) redução no número de ciclos necessários para executar uma instrução",
      "(b) redução no número de ciclos necessários para executar um programa",
      "(c) redução no número de ciclos necessários para tratar uma exceção",
      "(d) redução no número de ciclos necessários para tratar uma interrupção",
      "(e) o circuito do processador fica mais simples"
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-31",
    "numero": 31,
    "enunciado": "Um registrador de deslocamento (shift register) é um componente importante dos dis-",
    "alternativas": [
      "(a) somente I e II",
      "(b) somente II e IV",
      "(c) somente III e IV",
      "(d) somente I e III",
      "(e) somente II e III"
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-32",
    "numero": 32,
    "enunciado": "Considere as seguintes afirmativas:\nI. Uma modificação em uma CPU fez o cycle time e o CPI aumentarem de 10%\nenquanto o número de instruções executadas para uma dada aplicação decresceu\nde 20%. Podemos concluir que o tempo de execução desta aplicação será mantido.\nII. Um page fault ocorre quando a entrada correspondente à página requerida não é\nencontrada no translation lookside buffer.\nIII. Para armazenar uma mesma quantidade de dados, uma cache direct mapped é\ntipicamente menor que uma cache set associative, assumindo blocos de mesmo\ntamanho.\nIV. Aumentando–se o tamanho do bloco de uma cache aumenta–se as vantagens ob-\ntidas com a localidade espacial.\nV. Memória virtual tipicamente usa a estratégia write–through ao invés de estratégia\nwrite–back.",
    "alternativas": [
      "(a) Somente as afirmativas I, II, III e IV são verdadeiras.",
      "(b) Somente as afirmativas I, III e IV são verdadeiras.",
      "(c) Somente as afirmativas II, III e IV são verdadeiras.",
      "(d) Somente as afirmativas III e IV são verdadeiras.",
      "(e) Todas as afirmativas são verdadeiras."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-33",
    "numero": 33,
    "enunciado": "Considere as seguintes afirmações sobre um grafo G com n > 0 vértices:",
    "alternativas": [
      "(a) I e II",
      "(b) I e III",
      "(c) II e III",
      "(d) II e IV",
      "(e) II, III e IV"
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-34",
    "numero": 34,
    "enunciado": "Um algoritmo é executado em 10 segundos para uma entrada de tamanho 50. Se o",
    "alternativas": [
      "",
      "",
      "",
      "",
      ""
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-35",
    "numero": 35,
    "enunciado": "Considere as seguintes definições de ordens de percurso de uma árvore binária:\nse a árvore binária não for vazia, então:\n{visitar a raiz;\npercorrer a sub-árvore esquerda em Ordem B;\npercorrer a sub-árvore direita em Ordem B;\n}\nse a árvore binária não for vazia, então:\n{visitar a raiz;\npercorrer a sub-árvore direita em Ordem A;\npercorrer a sub-árvore esquerda em Ordem A;\n}\nA\nB E\nC D F K\nG I L M\nH J",
    "alternativas": [
      "(a) A B D C E K L M F I J G H",
      "(b) A B C D E F G H I J K L M",
      "(c) A B D C E K L M F G H I J",
      "(d) A B E C D F K G I L M H J",
      "(e) A B D C E F I J G H K L M"
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-36",
    "numero": 36,
    "enunciado": "As seguintes expressões regulares denotam as linguagens P , Q, L e R, respectivamente:",
    "alternativas": [
      "(a) P ∩ Q 6= ∅",
      "(b) P ∪ Q 6= L",
      "(c) P ∩ Q = {(cid:15)}",
      "(d) (1 + 0)∗ \\ P = Q",
      "(e) R ⊂ L \\ (P ∪ Q)"
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-37",
    "numero": 37,
    "enunciado": "Qual é a função implementada pelo circuito CMOS mostrado na figura abaixo?\nVDD\nA B\nC D\nF\nA C\nB D",
    "alternativas": [
      "(a) F = (A · B ) + (C · D)",
      "(b) F = (A + B ) · (C + D)",
      "(c) F = (A · B ) + (C · D)",
      "(d) F = (A + B ) · (C + D)",
      "(e) F = (A · B ) + (C · D)"
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-38",
    "numero": 38,
    "enunciado": "Para um certo problema foram apresentados dois algoritmos de divisão e conquista, A e",
    "alternativas": [
      "(a) 16",
      "(b) 49",
      "(c) 63",
      "(d) 64",
      "(e) 65"
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-39",
    "numero": 39,
    "enunciado": "Em um sistema operacional, um processo pode, em um dado instante de tempo, estar\nI. Do estado em execução para o estado bloqueado\nII. Do estado em execução para o estado pronto\nIII. Do estado pronto para o estado em execução\nIV. Do estado pronto para o estado bloqueado\nV. Do estado bloqueado para o estado em execução\nVI. Do estado bloqueado para o estado pronto",
    "alternativas": [
      "(a) Somente as afirmativas I, II e III são verdadeiras.",
      "(b) Somente as afirmativas I, II, III e VI são verdadeiras.",
      "(c) Somente as afirmativas I, III, IV e VI são verdadeiras.",
      "(d) Somente as afirmativas I, III, IV e V são verdadeiras.",
      "(e) Todas as afirmativas são verdadeiras."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-40",
    "numero": 40,
    "enunciado": "Dado o trecho de programa abaixo:\nvar z:integer;\nbegin\nz:=x+a ;\nx:=y+1;\ny:=y+z;\nend;\nbegin\na:= 2;\nb:= 3;\nP (a,b);\nwriteln(a,b);\nend;\nT 1\nvalor referência\nvalor\nT 2\nreferência\n2 3 4 3",
    "alternativas": [
      "(a)\n2 7 4 7\n2 3 2 7",
      "(b)\n4 3 4 7\n2 3 4 7",
      "(c)\n2 3 4 7\n2 3 2 3",
      "(d)\n2 3 2 3\n4 7 4 7",
      "(e)\n4 7 4 7"
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-41",
    "numero": 41,
    "enunciado": "Considere as seguintes tabelas em uma base de dados relacional, contendo\ninformações sobre empregados, departamentos e a vinculação entre eles:\nFROM Departamento D, Empregado E\nWHERE D.CodDepto=E.CodDepto AND\nE.CodEmp IS NULL\nFROM Departamento D\nWHERE EXISTS\n(SELECT *\nFROM Empregado E\nWHERE CodDepto=D.CodDepto)\nFROM Departamento D)\nEXCEPT\n(SELECT NomeDepto\nFROM Departamento D, Empregado E\nWHERE D.CodDepto=E.CodDepto)\nFROM Departamento D, Empregado E\nWHERE D.CodDepto<>E.CodDepto\nFROM Departamento D\nWHERE CodDepto IN\n(SELECT CodDepto\nFROM Empregado E)",
    "alternativas": [
      "",
      "",
      "",
      "",
      ""
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-42",
    "numero": 42,
    "enunciado": "Considere um modelo entidade-relacionamento de uma indústria. Este modelo\nrepresenta peças com suas propriedades, bem como a composição de peças (peças\npodem ser usadas na composição de outras peças). Este modelo entidade-\nrelacionamento contém:\nx Uma entidade Peça, com atributos código e nome e peso.\nx Um auto-relacionamento de Peça, chamado Composição. Neste auto-\nrelacionamento uma peça tem papel de componente e outra peça papel de\ncomposto. O auto-relacionamento tem cardinalidade n:n e tem um atributo\nquantidade, que informa quantas unidades da peça componente são usadas na\npeça composto.\nComposicao(CodPecaComposto,CodPecaComponente,Quantidade)\nComposição.CodPecaComposto referencia Peca\nComposição.CodPecaComponente referencia Peca\nQuantidade)\nPeca.CodPecaComposto referencia Peca\nComposicao(CodPecaComposto,CodPecaComponente,Quantidade)\nComposição.CodPecaComposto referencia Peca\nComposição.CodPecaComponente referencia Peca\nCodPecaComponente,Quantidade)\nPeca.CodPecaComposto referencia Peca\nPeca.CodPecaComponente referencia Peca\nComponente (CodPeca, NomePeca, PesoPeca, CodPecaComposto\nQuantiade)\nComponente.CodPecaComposto referencia Composto",
    "alternativas": [
      "",
      "",
      "",
      "",
      ""
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-43",
    "numero": 43,
    "enunciado": "Na álgebra relacional, a operação de junção interna entre duas tabelas A e B e com\ncritério de junção C tem a função de:",
    "alternativas": [
      "a) Concatenar cada linha da tabela A com cada linha da tabela B sempre que o\ncritério de junção C for verdadeiro. Linhas de A e B para as quais o critério de\njunção não é verdadeiro não aparecem no resultado.",
      "b) Concatenar cada linha da tabela A com cada linha da tabela B sempre que o\ncritério de junção C for verdadeiro. Caso para uma linha de A não exista nenhuma\nlinha em B que torne o critério verdadeiro, a linha de A aparece no resultado\nconcatenada com campos vazios (NULL).",
      "c) Concatenar cada linha da tabela A com cada linha da tabela B sempre que o\ncritério de junção C for verdadeiro. Caso para uma linha de B não exista nenhuma\nlinha em A que torne o critério verdadeiro, a linha de A aparece no resultado\nconcatenada com campos vazios (NULL).",
      "d) Concatenar cada linha da tabela A com cada linha da tabela B.",
      "e) Concatenar a tabela A com a tabela B, isto é, formar uma tabela formada por\nlinhas que aparecem em A ou B."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-44",
    "numero": 44,
    "enunciado": "Considere as seguintes tabelas em uma base de dados relacional, contendo\ninformações sobre empregados, departamentos e a vinculação entre eles:\nEmpregado E\nE.SalarioEmp > 300",
    "alternativas": [
      "a) Para departamentos com mais que 20 empregados que tenham salário maior que\n300, obter o código do departamento e a média salarial dos empregados do\ndepartamento.",
      "b) Para departamentos que tem mais que 20 empregados nos quais todos empregados\ntem salário maior que 300, obter o código do departamento e a média salarial dos\nempregados que ganham mais que 300.",
      "c) Para departamentos que tem mais que 20 empregados nos quais todos empregados\ntem salário maior que 300, obter o código do departamento e a média salarial dos\nempregados do departamento.",
      "d) Para departamentos que tem mais que 20 empregados, obter o código do\ndepartamento e a média salarial dos empregados que ganham mais que 300.",
      "e) Para departamentos com mais que 20 empregados que tenham salário maior que\n300, obter o código do departamento e a média salarial dos empregados do\ndepartamento que ganham mais que 300."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-45",
    "numero": 45,
    "enunciado": "Transações em SGBD relacionais normalmente preenchem os requisitos ACID\n(atomicidade, consistência, isolamento e durabilidade). Considere as seguintes\nafirmações:\ntransação T não são vistas por outras transações, até que a transação T encerre.\npodem ser protegidos para alteração por outra transação.\nsobre a base de dados não pode ser desfeito.",
    "alternativas": [
      "",
      "",
      "",
      "",
      ""
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-46",
    "numero": 46,
    "enunciado": "A construção de sistemas é difícil devido à sua complexidade. Um fator crucial para\ngerenciar esta complexidade é o processo adotado para o desenvolvimento. O\nconjunto básico de atividades e a ordem em que são realizadas neste processo definem\no que é também denominado de ciclo de vida do software. Analise as seguintes\nafirmações sobre processos de software:\nI. Um modelo de processo de software é uma representação abstrata de um\nprocesso; Exemplos de modelo de processos de software genéricos são o\nmodelo waterfall (cascata) e o spiral (espiral);\nII. O modelo de processo waterfall ainda é hoje em dia um dos mais difundidos\ne tem por característica principal a codificação de uma versão executável do\nsistema desde as fases iniciais do desenvolvimento, de modo que o sistema\nfinal é incrementalmente construído, daí a alusão à idéia de “cascata”\n(waterfall);\nIII. Em um processo de software incremental, o desenvolvimento do sistema é\niterativo e partes de suas funcionalidades (denominadas “incrementos”) são\nentregues na medida em que são desenvolvidas; assim, estas entregas parciais\ntentam priorizar as necessidades mais urgentes do usuário e podem auxiliar a\nrevisão e a uma melhor definição das partes ainda não entregues;\nLevando-se em conta as três afirmações I, II e III acima, identifique a única",
    "alternativas": [
      "a) apenas a I e a II estão corretas;",
      "b) apenas a II e a III estão corretas;",
      "c) apenas a I e a III estão corretas;",
      "d) as afirmações I, II e III estão corretas;",
      "e) apenas a III está correta."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-47",
    "numero": 47,
    "enunciado": "Qual das alternativas abaixo não é um dos diagramas existentes na linguagem de\nmodelagem UML (Unified Modeling Language) :",
    "alternativas": [
      "a) Diagramas de Casos de Uso (use case diagrams)",
      "b) Diagramas de Classes (class diagrams);",
      "c) Diagramas de Seqüência (sequence diagrams)",
      "d) Diagramas Entidade-Relacionamento (entity-relationship diagrams);",
      "e) Diagramas de Estado (statechart diagram)"
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-48",
    "numero": 48,
    "enunciado": "A linguagem de modelagem UML contém a definição de vários diagramas que\npermitem representar diferentes partes de um modelo de sistema tipicamente aplicada\na sistemas orientados a objetos. Analise as seguintes afirmações referentes a UML:\ncomportamento pretendido do sistema através da representação das interações entre\natores e o próprio sistema;\nbásica entre eles é que os primeiros representam comportamento que causa\nmudanças de estado de um simples elemento (tipicamente um objeto) e são usados\ngeralmente durante o projeto do software enquanto os segundos representam\ncomportamento entre diferentes elementos e geralmente são usados para modelar os\nfluxos das atividades de negócios durante a análise do software;\nde algum comportamento do sistema, dando ênfase à ordenação temporal das trocas\nde mensagens entre os objetos;\nLevando-se em conta as três afirmações I, II e III acima, identifique a única alternativa\nválida:",
    "alternativas": [
      "a) apenas a I e a II estão corretas;",
      "b) apenas a II e a III estão corretas;",
      "c) apenas a I e a III estão corretas;",
      "d) as afirmações I, II e III estão corretas;",
      "e) apenas a III está correta."
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-49",
    "numero": 49,
    "enunciado": "Engenharia de Software inclui um grande número de teorias, conceitos, modelos,\ntécnicas e métodos. Analise as seguintes definições.\npara estimativa de custo e esforço. A técnica de Pontos por Função é uma técnica de\nestimativa que, embora não seja relacionada diretamente a linhas de código, é\nutilizada também para a obtenção de métricas de produtividade e qualidade do\ndesenvolvimento de software;\nEngineering Institute (SEI) que propõe níveis de competência organizacional\nrelacionados à qualidade do processo de desenvolvimento de software;\nnível (projeto ou especificação) a partir de um documento de mais baixo nível\n(tipicamente um código fonte);\nLevando-se em conta as três afirmações I, II e III acima, identifique a única\nalternativa válida:",
    "alternativas": [
      "a) apenas a I está correta;",
      "b) apenas a II está correta.",
      "c) apenas a II e a III estão corretas;",
      "d) apenas a I e a III estão corretas;",
      "e) as afirmações I, II e III estão corretas;"
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-50",
    "numero": 50,
    "enunciado": "As seguintes afirmações dizem respeito ao uso de Padrões de Projeto (Design\nPatterns), mais especificamente os padrões GoF (apresentados e descritos no livro\nclássico de E. Gamma, R. Helm, R. Johnson e J. Vlissides).\npara resolver um problema geral e recorrente num contexto determinado;\nem padrões estruturais (ou de estrutura), comportamentais (ou de comportamento) ,\nde criação, de delegação e de combinação.\ncoleções de objetos. O padrão Singleton, por exemplo, assegura que uma classe tem\nexatamente uma única instância;\nLevando-se em conta as três afirmações I, II e III acima, identifique a única\nalternativa válida:",
    "alternativas": [
      "a) apenas a I e a II estão corretas;",
      "b) apenas a II e a III estão corretas;",
      "c) apenas a I e a III estão corretas;",
      "d) todas as afirmações estão corretas;",
      "e) nenhuma das afirmações está correta;"
    ],
    "area_conhecimento": "Fundamentos da Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-51",
    "numero": 51,
    "enunciado": "A situação atual do desenvolvimento de software encontra-se aquém do ideal.\nSistemas são invariavelmente entregues com atraso ou com o orçamento estourado,\nisto quando são efetivamente entregues... E o que é pior, freqüentemente eles não\natendem os requisitos dos clientes. Existem várias alternativas de tentar enfrentar este\ndesafio, entre as quais a adoção de métodos formais, a sistematização do\ndesenvolvimento usando processos tais como o Unified Process e a integração de\nnovas tecnologias. Uma outra abordagem que recentemente vem ganhando adeptos é\no Desenvolvimento Ágil de software. As seguintes afirmações dizem respeito a ele.\nI. Suas idéias principais estão divulgadas em um Manifesto para o\nDesenvolvimento Ágil de Software escrito pela Aliança Ágil (Agile\nAlliance), que reúne autores famosos como Martin Fowler, Alistair\nCockburn, Scott Ambler, Ward Cunningham e Kent Beck;\nII. Desnvolvimento Ágil basicamente concentra-se em melhorias na\ncomunicação (interna à equipe e com os clientes), na entrega incremental de\nvárias versões funcionais do software continuamente até o fim do projeto e\nna maleabilidade e dinamicidade do desenvolvimento, facilitando as\nrespostas às mudanças que aparecem durante este desenvolvimento.\nIII. A técnica mais conhecida de Desenvolvimento Ágil é a Programação\neXtrema (Extreme Programming - XP) que entre suas práticas possui\nprogramação em pares (pair programming), entregas pequenas (small\nreleases) e frequentes, a propriedade coletiva do código (collective\nownership), abolindo as práticas de teste e os padrões de codificação;",
    "alternativas": [
      "a) apenas a I e a II estão corretas;",
      "b) apenas a II e a III estão corretas;",
      "c) apenas a I e a III estão corretas;",
      "d) todas as afirmações estão corretas;",
      "e) nenhuma das afirmações está correta;"
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-52",
    "numero": 52,
    "enunciado": "Considere as funções booleanas abaixo:\nI. p (cid:154) q (conjunção)\nII. p l q (equivalência)\nIII. p o q (implicação)",
    "alternativas": [
      "a) Somente I;",
      "b) Somente I e II;",
      "c) Somente I e III;",
      "d) Somente II e III;",
      "e) I, II e III."
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-53",
    "numero": 53,
    "enunciado": "Considere um algoritmo genético que opera sobre três indivíduos A, B, C, descritos\nrespectivamente pelos vetores binários\nA = [11011000], B = [00010000], C = [11001101],",
    "alternativas": [
      "a) Crossover pelo ponto central dos indivíduos A e C;",
      "b) Crossover pelo ponto central dos indivíduos A e B;",
      "c) Crossover pelo ponto central dos indivíduos A e B seguido de mutação de um bit em\ncada novo indivíduo (D e E);",
      "d) Crossover pelo ponto central dos indivíduos A e C seguido de mutação de um bit em\ncada novo indivíduo (D e E);",
      "e) Crossover pelo ponto central dos indivíduos B e C seguido de mutação de um bit em\ncada novo indivíduo (D e E)."
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-54",
    "numero": 54,
    "enunciado": "Considere as afirmações sobre características desejáveis do domínio e da tarefa, para\no uso de sistemas especialistas.\nI. O domínio é caracterizado por ser intensivo em conhecimento.\nII. A tarefa requer conhecimento de um grande número de áreas.\nIII. Abordagens tradicionais (algorítmicas) para a tarefa não são satisfatórias.",
    "alternativas": [
      "a) Apenas II",
      "b) Apenas I e II",
      "c) Apenas I e III",
      "d) Apenas II e III",
      "e) I, II e III"
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-55",
    "numero": 55,
    "enunciado": "Considere as afirmações sobre resolução de problemas em IA.\nI. Busca pela melhor escolha é um tipo de busca heurística .\nII. Satisfação de restrições é uma das formas de solução de problemas em IA.\nIII. O procedimento Alfa-Beta pode permitir a poda de boa parte de uma árvore de\nbusca em um jogo de dois jogadores.",
    "alternativas": [
      "a) Apenas II",
      "b) Apenas I e II",
      "c) Apenas I e III",
      "d) Apenas II e III",
      "e) I, II e III"
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-56",
    "numero": 56,
    "enunciado": "Considerando as declarações abaixo, é incorreto afirmar:",
    "alternativas": [
      "a) Filtros passa-altas são utilizados para detecção de bordas em imagens",
      "b) A transformada discreta de Fourier nos permite obter uma representação de uma\nimagem no domínio freqüência",
      "c) Filtragem no domínio espacial é realizada por meio de uma operação chamada\n“convolução”",
      "d) Os filtros Gaussiano e Laplaciano são exemplos de filtro passa-baixas",
      "e) O filtro da mediana pode ser utilizado para redução de ruído em uma imagem"
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-57",
    "numero": 57,
    "enunciado": "Considere: todas as etapas do processo de visualização de objetos 2D; uma window\ndelimitada pelo par de coordenadas (0,0)-(60,60); uma viewport delimitada pelo par\nde coordenadas (0,0)-(100,80); e os seguintes parâmetros de instanciamento,\naplicados nesta ordem: (1°) Escala em X: 1, Escala em Y: 2; (2°) Rotação: 0°; (3°)\nTranslação X: 10, Translação Y: 0\nAssumindo que, nas opções apresentadas abaixo, os retângulos pontilhados\nrepresentam a viewport, qual dos desenhos a seguir mais se parece com o desenho do\ntriângulo cuja definição no sistema de referência do universo é dada pelos pares de\ncoordenadas (10,0)-(10,30)-(40,0)? Considere ainda que as coordenadas que definem\nwindow e viewport correspondem, respectivamente, aos limites inferior esquerdo e\nsuperior direito de ambas.",
    "alternativas": [
      "a) b) c)\nNenhuma das\nopções acima.\nd) e)",
      "",
      "",
      "",
      ""
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-58",
    "numero": 58,
    "enunciado": "Identifique a declaração incorreta:",
    "alternativas": [
      "a) As operações de ajuste de brilho e contraste são operações lineares",
      "b) A equalização de histograma é uma transformação não-linear e específica para\ncada imagem",
      "c) A transformação necessária para calcular o negativo de uma imagem pode ser\naplicada simultaneamente (i.e., em paralelo) a todos pixels da imagem original",
      "d) A equalização de histograma pode ser obtida a partir de um histograma\ncumulativo da imagem original",
      "e) O objetivo da equalização de histograma é reduzir o constrastre nas regiões da\nimagem que correspondem à porção do histograma com maior concentração de\npixels"
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-59",
    "numero": 59,
    "enunciado": "Considerando o pipeline de visualização 3D e o equacionamento da câmera sintética,\nindique qual das afirmações abaixo está correta:",
    "alternativas": [
      "a) A transformação de câmera pode ser representada como uma seqüência de\ntransformações geométricas aplicadas ao conjunto de vértices que definem os\nobjetos geométricos de uma cena",
      "b) A transformação de câmera corresponde à última etapa do pipeline de\nvisualização 3D",
      "c) As coordenadas dos objetos da cena, após a transformação de câmera, são\nrelativas ao ponto indicado como posição do observador",
      "d) Considerando w como sendo o vetor da base que determina a direção do eixo z\nda câmera, pode-se afirmar que w é sempre obtido a partir da posição da\ncâmera e da origem do SRU",
      "e) A transformação de câmera é a operação responsável pelo mapeamento de\nobjetos 3D no espaço 2D"
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-60",
    "numero": 60,
    "enunciado": "A técnica de iluminação denominada ray-tracing",
    "alternativas": [
      "a) determina o grau de visibilidade de superfícies traçando raios de luz imaginários\npartindo de todos os vértices que definem as superfícies dos objetos da cena",
      "b) utiliza o modelo de iluminação local de Phong no cálculo parcial da iluminação",
      "c) considera a interação entre os objetos da cena no cálculo da iluminação, mas só\nfunciona com uma única fonte de luz",
      "d) apesar de possuir uma fase de pré-processamento custosa, onde é montada uma\nestrutura de árvore de iluminação, é bastante eficiente em situações em que a\ncâmera se move e as fontes de luz e os objetos permanecem estáticos",
      "e) se baseia no cálculo recursivo da iluminação transmitida e refletida por cada\nobjeto, sendo que sua eficiência aumenta a medida em que aumenta o nível de\ntransparência dos objetos envolvidos"
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-61",
    "numero": 61,
    "enunciado": "Considere as seguintes afirmações sobre as linguagens usadas para análise sintática:\nI – Os analisadores LL(1) aceitam linguagens com produções que apresentem\nrecursões a esquerda\nII – Os analisadores LR(1) reconhecem uma classe de linguagens maior que os\nanalisadores LALR(1)\nIII – Os analisadores SLR(1) reconhecem uma classe de linguagens menor que os\nanalisadores LR(0)",
    "alternativas": [
      "",
      "",
      "",
      "",
      ""
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-62",
    "numero": 62,
    "enunciado": "6HMD(cid:3)D(cid:3)VHJXLQWH(cid:3)OLQJXDJHP(cid:15)(cid:3)RQGH(cid:3) (cid:3)UHSUHVHQWD(cid:3)D(cid:3)VHQWHQça vazia:\nS o AB | CD\nA o a |\nB o b | f\nC o c | g\nD o h | i",
    "alternativas": [
      "a) {a, c, g}",
      "b) {a, b, f, c, g}",
      "c) {a, b, f, c, g, h, i}",
      "d) {a, c, g, h, i}",
      "e) {a, b, f}"
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-63",
    "numero": 63,
    "enunciado": "O esquema de tradução dirigida por sintaxe que segue traduz uma linguagem com\nterminais a, b, c e d em uma linguagem cujos terminais são 1, 2, 3, 4, 5, 6. Usando um\nparser bottom-up que executa as ações entre parênteses imediatamente após reduzir a\nregra correspondente, qual o resultado da tradução de “aaadbc”\nS -> AS {print \"1\"}\nS -> B {print \"2\"}\nA -> a {print \"3\"}\nB -> bC {print \"4\"}\nB -> dB {print \"5\"}\nC -> c {print \"6\"}",
    "alternativas": [
      "a) 1313132546",
      "b) 1113332546",
      "c) 3336452111",
      "d) 6452111333",
      "e) 2546131313"
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-64",
    "numero": 64,
    "enunciado": "Assinale a opção que melhor completa o parágrafo abaixo:\nSistemas distribuídos e computadores paralelos com múltiplos processadores\nfortemente acoplados possuem algumas características comuns, como a existência de\nvários processadores e a possibilidade de executar tarefas simultâneas, uma em cada\nprocessador, em um dado instante de tempo. Mas um sistema distribuído diferencia-se\nde um sistema multiprocessador fortemente acoplado principalmente porque o sistema\ndistribuído:",
    "alternativas": [
      "a) apresenta suporte de rede de alta velocidade e um relógio global compartilhado.",
      "b) exige um sistema operacional de rede e hardware padronizado nos computadores.",
      "c) não apresenta memória compartilhada nem relógio global.",
      "d) possui memória secundária compartilhada e protocolos de sincronização de estado.",
      "e) exige um ambiente de administração único e medidas especiais de segurança contra\nassociações ilícitas."
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-65",
    "numero": 65,
    "enunciado": "Considere dois sistemas computacionais formados por múltiplos computadores que\nmanipulam dados comuns. No primeiro, existe um computador central, chamado\nservidor, que é o único responsável pelos serviços de leitura e escrita desses dados.\nNo segundo, existe um grupo de computadores responsáveis pelos serviços de leitura\ne escrita, e cada um desses servidores deve manter uma réplica idêntica dos dados.\nEntre as vantagens e desvantagens de um único servidor em relação a vários\nservidores, podemos afirmar que o servidor único apresenta:\ni. Vantagem de maior velocidade de execução das operações de escrita e leitura\ne desvantagem de maior custo de armazenamento\nii. Vantagem de não necessitar de coordenação distribuída para ordenação das\noperações de escrita e desvantagem de menor velocidade nas leituras devido a\nserialização de operações\niii. Vantagem de manter mais facilmente a consistência dos dados mas\ndesvantagem de perda de disponibilidade em caso de falha do servidor.",
    "alternativas": [
      "a) (ii) e (iii)",
      "b) apenas (ii)",
      "c) apenas (i)",
      "d) (i), (iii)",
      "e) (i), (ii) e (iii)"
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-66",
    "numero": 66,
    "enunciado": "Um cluster é definido como um sistema distribuído formado por máquinas\nhomogêneas, executando o mesmo sistema operacional, interligadas por uma rede de\nalta velocidade. Como vantagens deste cluster em relação a uma máquina de grande\nporte poderíamos citar:\ni. melhor escalabilidade de unidades de processamento\nii. possibilidade de executar programas com múltiplas threads\niii. possibilidade de continuar o processamento isolando máquinas defeituosas\niv. possibilidade de executar programas Java usando RMI",
    "alternativas": [
      "a) (i) e (iii)",
      "b) (ii) e (iv)",
      "c) (i) e (iv)",
      "d) apenas (iii)",
      "e) (i), (ii), (iii) e (iv)"
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-67",
    "numero": 67,
    "enunciado": "Os tipos mais comuns de defeitos em sistemas distribuídos provocados por falhas\nfísicas de componentes ou interferência eletro-magnética são:",
    "alternativas": [
      "a) perda de arquivos, colapso de servidores, captura de senhas",
      "b) captura de senhas, sobrecarga de servidores, mensagens duplicadas",
      "c) perda de mensagens, mensagens com vírus e mensagens órfãs",
      "d) colapso de servidores, queda do enlace e perda de mensagens",
      "e) páginas web com endereço errado, spam e mensagens duplicadas"
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-68",
    "numero": 68,
    "enunciado": "O protocolo padrão para gerenciamento de redes TCP/IP, definido pelo IETF, é:",
    "alternativas": [
      "a) SMTP",
      "b) HTTP",
      "c) SNMP",
      "d) COPS",
      "e) SSH"
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-69",
    "numero": 69,
    "enunciado": "Qual das opções abaixo melhor caracteriza o protocolo IP?",
    "alternativas": [
      "a) Orientado a conexão, com suporte a QoS, com mecanismo de retransmissão",
      "b) Não orientado a conexão, sem suporte a QoS, sem mecanismo de retransmissão",
      "c) Orientado a conexão, sem suporte a QoS, sem mecanismo de retransmissão",
      "d) Orientado a conexão, sem suporte a QoS, com mecanismo de retransmissão",
      "e) Não orientado a conexão, com suporte a QoS, sem mecanismo de retransmissão"
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  },
  {
    "edicao": 2004,
    "id": "2004-70",
    "numero": 70,
    "enunciado": "Assinale a alternativa que apresenta um protocolo de roteamento baseado no\nalgoritmo vetor-distância e é classificado como IGP (Interior Gateway Protocol):",
    "alternativas": [
      "a) OSPF",
      "b) ICMP",
      "c) BGP",
      "d) RIP",
      "e) RSVP"
    ],
    "area_conhecimento": "Tecnologia de Computação",
    "area": "",
    "subarea": "",
    "dificuldade": "",
    "gabarito": "",
    "solucao": ""
  }
]
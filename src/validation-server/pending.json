[
  {
    "edicao": 2019,
    "id": "2019-21",
    "numero": 21,
    "enunciado": "Considere os seguintes algoritmos recursivos que resolvem o mesmo problema em\numa entrada de tamanho n:\nAlgoritmo 1: Divide o problema em 3 partes de tamanho n/4 cada e gasta um tempo adicional O(1)\npor chamada.\nAlgoritmo 2: Divide o problema em 3 partes de tamanho n/2 cada e gasta um tempo adicional O(n2)\npor chamada.\nAlgoritmo 3: Divide o problema em 3 partes de tamanho n/3 cada e gasta um tempo adicional de\nO(n) por chamada.\nA complexidade dos algoritmos 1, 2 e 3 Ã©, respectivamente:",
    "alternativas": [
      "a) ğ›©(ğ‘›ğ‘™ğ‘œğ‘”43 ), ğ›©(ğ‘›2), ğ›©(ğ‘› ğ‘™ğ‘œğ‘” ğ‘›)\nğ‘› ğ‘› ğ‘›",
      "b) ğ›© ( ) , ğ›© ( ) , ğ›© ( )\n4 2 3",
      "c) ğ›©(1), ğ›©(ğ‘›2), ğ›©(ğ‘›)",
      "d) ğ›©(ğ‘›4), ğ›©(ğ‘›2), ğ›©(ğ‘›3)",
      "e) ğ›©(ğ‘›ğ‘™ğ‘œğ‘”43), ğ›©(ğ‘›ğ‘™ğ‘œğ‘”23), ğ›©(ğ‘›ğ‘™ğ‘œğ‘”33)"
    ],
    "area_conhecimento": "Fundamentos da ComputaÃ§Ã£o",
    "area": "AnÃ¡lise de Algoritmos",
    "subarea": "Uso de RelaÃ§Ãµes de RecorrÃªncia para AnÃ¡lise de Algoritmos Recursivos",
    "dificuldade": "MÃ©dia",
    "gabarito": "A",
    "solucao": "Para resolver a questÃ£o, precisamos analisar a complexidade de cada algoritmo usando o Teorema Mestre. \n\nAlgoritmo 1: Divide o problema em 3 partes de tamanho n/4 cada e gasta um tempo adicional O(1) por chamada. A relaÃ§Ã£o de recorrÃªncia Ã© T(n) = 3T(n/4) + O(1). Aplicando o Teorema Mestre, temos a = 3, b = 4, f(n) = O(1). Como f(n) = O(n^c) com c = 0, e a comparaÃ§Ã£o entre n^log_b(a) = n^log_4(3) e f(n) mostra que f(n) Ã© menor, estamos no caso 1 do Teorema Mestre. Assim, T(n) = Î˜(n^log_4(3)).\n\nAlgoritmo 2: Divide o problema em 3 partes de tamanho n/2 cada e gasta um tempo adicional O(n^2) por chamada. A relaÃ§Ã£o de recorrÃªncia Ã© T(n) = 3T(n/2) + O(n^2). Aplicando o Teorema Mestre, temos a = 3, b = 2, f(n) = O(n^2). Aqui, n^log_b(a) = n^log_2(3), que Ã© menor que f(n) = O(n^2), entÃ£o estamos no caso 3 do Teorema Mestre. Assim, T(n) = Î˜(n^2).\n\nAlgoritmo 3: Divide o problema em 3 partes de tamanho n/3 cada e gasta um tempo adicional O(n) por chamada. A relaÃ§Ã£o de recorrÃªncia Ã© T(n) = 3T(n/3) + O(n). Aplicando o Teorema Mestre, temos a = 3, b = 3, f(n) = O(n). Aqui, n^log_b(a) = n, que Ã© igual a f(n), entÃ£o estamos no caso 2 do Teorema Mestre. Assim, T(n) = Î˜(n log n).\n\nPortanto, a complexidade dos algoritmos 1, 2 e 3 Ã©, respectivamente, Î˜(n^log_4(3)), Î˜(n^2), Î˜(n log n), que corresponde Ã  alternativa A."
  },
  {
    "edicao": 2019,
    "id": "2019-25",
    "numero": 25,
    "enunciado": "Considere a seguinte funÃ§Ã£o em C:\nvoid funcao(int n){\nint i,j;\nfor (i=1; i<=n; i++)\nfor(j=1; j<log(i); j++)\nprintf(â€œ%dâ€,i+j)\n}\nA complexidade dessa funÃ§Ã£o Ã©:",
    "alternativas": [
      "a) ğ›©(ğ‘›)",
      "b) ğ›©(ğ‘› ğ‘™ğ‘œğ‘” ğ‘›)",
      "c) ğ›©(ğ‘™ğ‘œğ‘” ğ‘›)",
      "d) ğ›©(ğ‘›2)",
      "e) ğ›©(ğ‘›2ğ‘™ğ‘œğ‘” ğ‘›)"
    ],
    "area_conhecimento": "Fundamentos da ComputaÃ§Ã£o",
    "area": "AnÃ¡lise de Algoritmos",
    "subarea": "AnÃ¡lise AssintÃ³tica de Limites de Complexidade",
    "dificuldade": "MÃ©dia",
    "gabarito": "A",
    "solucao": "Para determinar a complexidade da funÃ§Ã£o fornecida, precisamos analisar os loops aninhados. O loop externo 'for (i=1; i<=n; i++)' itera 'n' vezes. O loop interno 'for(j=1; j<log(i); j++)' depende do valor de 'i'. A funÃ§Ã£o 'log(i)' Ã© o logaritmo natural de 'i', que cresce muito lentamente. Para cada valor de 'i', o loop interno executa 'log(i) - 1' vezes. Portanto, o nÃºmero total de iteraÃ§Ãµes do loop interno para todos os valores de 'i' Ã© a soma de 'log(i) - 1' para 'i' de 1 a 'n'. Esta soma Ã© aproximadamente proporcional a 'n', pois a soma dos logaritmos de 1 a 'n' Ã© 'log(n!)', que Ã© aproximadamente 'n log(n)'. No entanto, como o loop interno executa apenas atÃ© 'log(i)', a contribuiÃ§Ã£o principal para a complexidade vem do loop externo, resultando em uma complexidade de ğ›©(ğ‘›)."
  },
  {
    "edicao": 2018,
    "id": "2018-25",
    "numero": 25,
    "enunciado": "Para medir o custo de execuÃ§Ã£o de um algoritmo, Ã© comum definir uma funÃ§Ã£o de\ncomplexidade f, em que f(n) Ã© a medida de tempo necessÃ¡rio para executar um algoritmo para um\nproblema de tamanho n. Considere as afirmaÃ§Ãµes abaixo sobre funÃ§Ãµes de complexidade:\nI. Se f(n) Ã© uma medida de quantidade de tempo necessÃ¡rio para executar um algoritmo em um\nproblema de tamanho n, entÃ£o f Ã© chamada funÃ§Ã£o de complexidade de tempo.\nII. Se f(n) Ã© uma medida de quantidade de memÃ³ria necessÃ¡ria para executar um algoritmo de\ntamanho n, entÃ£o f Ã© chamada funÃ§Ã£o de complexidade de espaÃ§o.\nIII. A complexidade de tempo nÃ£o representa o tempo diretamente, mas Ã© estimada pelo nÃºmero\nde vezes que determinada operaÃ§Ã£o relevante Ã© executada.\nQuais estÃ£o corretas?",
    "alternativas": [
      "a) Apenas I.",
      "b) Apenas II.",
      "c) Apenas III.",
      "d) Apenas I e II.",
      "e) I, II e III."
    ],
    "area_conhecimento": "Fundamentos da ComputaÃ§Ã£o",
    "area": "AnÃ¡lise de Algoritmos",
    "subarea": "Medidas de Complexidade",
    "dificuldade": "FÃ¡cil",
    "gabarito": "E",
    "solucao": "Vamos analisar cada uma das afirmaÃ§Ãµes: \n\nI. A afirmaÃ§Ã£o diz que se f(n) Ã© uma medida de quantidade de tempo necessÃ¡rio para executar um algoritmo em um problema de tamanho n, entÃ£o f Ã© chamada funÃ§Ã£o de complexidade de tempo. Isso estÃ¡ correto, pois a complexidade de tempo Ã© exatamente a funÃ§Ã£o que descreve como o tempo de execuÃ§Ã£o de um algoritmo cresce com o tamanho da entrada.\n\nII. A afirmaÃ§Ã£o diz que se f(n) Ã© uma medida de quantidade de memÃ³ria necessÃ¡ria para executar um algoritmo de tamanho n, entÃ£o f Ã© chamada funÃ§Ã£o de complexidade de espaÃ§o. Isso tambÃ©m estÃ¡ correto, pois a complexidade de espaÃ§o refere-se Ã  quantidade de memÃ³ria que um algoritmo utiliza em relaÃ§Ã£o ao tamanho da entrada.\n\nIII. A afirmaÃ§Ã£o diz que a complexidade de tempo nÃ£o representa o tempo diretamente, mas Ã© estimada pelo nÃºmero de vezes que determinada operaÃ§Ã£o relevante Ã© executada. Isso tambÃ©m estÃ¡ correto. A complexidade de tempo geralmente nÃ£o mede o tempo real em segundos, mas sim o nÃºmero de operaÃ§Ãµes fundamentais (como comparaÃ§Ãµes ou atribuiÃ§Ãµes) que um algoritmo realiza, o que Ã© uma estimativa indireta do tempo de execuÃ§Ã£o.\n\nPortanto, todas as trÃªs afirmaÃ§Ãµes estÃ£o corretas."
  },
  {
    "edicao": 2018,
    "id": "2018-37",
    "numero": 37,
    "enunciado": "Sobre ordenaÃ§Ã£o topolÃ³gica em grafos, Ã© correto afirmar que:",
    "alternativas": [
      "a) A busca em largura Ã© utilizada para obter a ordenaÃ§Ã£o topolÃ³gica de um grafo direcionado\nacÃ­clico.",
      "b) A ordenaÃ§Ã£o topolÃ³gica de um grafo pode ser vista como uma ordenaÃ§Ã£o de suas arestas ao\nlongo de uma linha horizontal, de tal forma que todos os vÃ©rtices estÃ£o classificados em ordem\ncrescente.",
      "c) A ordenaÃ§Ã£o topolÃ³gica de um grafo direcionado acÃ­clico G=(V,A) Ã© uma ordenaÃ§Ã£o linear de\ntodos os seus vÃ©rtices tal que G contÃ©m uma aresta (u, v), entÃ£o u aparece antes de v.",
      "d) A busca binÃ¡ria Ã© utilizada para obter a ordenaÃ§Ã£o topolÃ³gica de um grafo cÃ­clico nÃ£o direcionado.",
      "e) O algoritmo para obter a ordenaÃ§Ã£o topolÃ³gica de um grafo direcionado usa o transposto do grafo\nque consiste de todas as arestas com as suas direÃ§Ãµes invertidas."
    ],
    "area_conhecimento": "Fundamentos da ComputaÃ§Ã£o",
    "area": "Teoria dos Grafos",
    "subarea": "OrdenaÃ§Ã£o TopolÃ³gica",
    "dificuldade": "MÃ©dia",
    "gabarito": "C",
    "solucao": "A ordenaÃ§Ã£o topolÃ³gica Ã© uma ordenaÃ§Ã£o linear dos vÃ©rtices de um grafo direcionado acÃ­clico (DAG) tal que, para cada aresta (u, v), o vÃ©rtice u aparece antes do vÃ©rtice v na ordenaÃ§Ã£o. A alternativa C descreve corretamente essa definiÃ§Ã£o. Alternativa A estÃ¡ incorreta porque a busca em profundidade Ã© geralmente utilizada para obter a ordenaÃ§Ã£o topolÃ³gica, nÃ£o a busca em largura. Alternativa B estÃ¡ incorreta porque a ordenaÃ§Ã£o topolÃ³gica nÃ£o Ã© uma ordenaÃ§Ã£o de arestas, mas sim de vÃ©rtices. Alternativa D estÃ¡ incorreta porque a busca binÃ¡ria nÃ£o Ã© utilizada para ordenaÃ§Ã£o topolÃ³gica, e grafos cÃ­clicos nÃ£o tÃªm ordenaÃ§Ã£o topolÃ³gica. Alternativa E estÃ¡ incorreta porque o transposto do grafo nÃ£o Ã© utilizado no processo de ordenaÃ§Ã£o topolÃ³gica."
  },
  {
    "edicao": 2018,
    "id": "2018-44",
    "numero": 44,
    "enunciado": "Considere um computador no qual o interpretador do nÃ­vel 0 (hardware\ninterpretando o microcÃ³digo) gasta 20 nanosegundos (20x10-9 segundos) por microinstruÃ§Ã£o, e o\ninterpretador do nÃ­vel 1 (microcÃ³digo interpretando a linguagem de mÃ¡quina convencional)\nnecessita de 25 microinstruÃ§Ãµes para interpretar uma instruÃ§Ã£o de mÃ¡quina convencional. Um\nprograma teste, jÃ¡ em linguagem de mÃ¡quina convencional, leva 50 segundos para executar.\na) Quanto tempo levarÃ¡ o programa teste para executar se o tempo para executar uma\nmicroinstruÃ§Ã£o for aumentado para 30 nanosegundos?\nb) Quanto tempo levarÃ¡ o programa teste para executar se uma instruÃ§Ã£o de mÃ¡quina convencional\nnecessitar de somente 15 microinstruÃ§Ãµes para ser interpretada?",
    "alternativas": [
      "a) a) T = 60 segundos e b) 15 segundos.",
      "b) a) T = 65 segundos e b) 20 segundos.",
      "c) a) T = 70 segundos e b) 25 segundos.",
      "d) a) T = 75 segundos e b) 30 segundos.",
      "e) a) T = 80 segundos e b) 35 segundos."
    ],
    "area_conhecimento": "Fundamentos da ComputaÃ§Ã£o",
    "area": "Arquitetura e OrganizaÃ§Ã£o de Computadores",
    "subarea": "OrganizaÃ§Ã£o de Computadores",
    "dificuldade": "MÃ©dia",
    "gabarito": "C",
    "solucao": "Para resolver a questÃ£o, precisamos calcular o tempo de execuÃ§Ã£o do programa teste em dois cenÃ¡rios diferentes. \n\nPrimeiro, vamos entender o cenÃ¡rio inicial: \n- O interpretador do nÃ­vel 0 gasta 20 nanosegundos por microinstruÃ§Ã£o. \n- O interpretador do nÃ­vel 1 necessita de 25 microinstruÃ§Ãµes para interpretar uma instruÃ§Ã£o de mÃ¡quina convencional. \n- O programa teste leva 50 segundos para executar. \n\nAgora, vamos calcular o tempo total de execuÃ§Ã£o em cada cenÃ¡rio: \n\na) Se o tempo para executar uma microinstruÃ§Ã£o for aumentado para 30 nanosegundos: \n- O tempo para executar uma instruÃ§Ã£o de mÃ¡quina convencional serÃ¡ 25 microinstruÃ§Ãµes * 30 nanosegundos = 750 nanosegundos por instruÃ§Ã£o. \n- No cenÃ¡rio original, o tempo por instruÃ§Ã£o era 25 microinstruÃ§Ãµes * 20 nanosegundos = 500 nanosegundos por instruÃ§Ã£o. \n- O aumento no tempo de execuÃ§Ã£o Ã© de 750/500 = 1.5 vezes. \n- Portanto, o novo tempo de execuÃ§Ã£o do programa serÃ¡ 50 segundos * 1.5 = 75 segundos. \n\nb) Se uma instruÃ§Ã£o de mÃ¡quina convencional necessitar de somente 15 microinstruÃ§Ãµes: \n- O tempo para executar uma instruÃ§Ã£o de mÃ¡quina convencional serÃ¡ 15 microinstruÃ§Ãµes * 20 nanosegundos = 300 nanosegundos por instruÃ§Ã£o. \n- No cenÃ¡rio original, o tempo por instruÃ§Ã£o era 500 nanosegundos. \n- A reduÃ§Ã£o no tempo de execuÃ§Ã£o Ã© de 300/500 = 0.6 vezes. \n- Portanto, o novo tempo de execuÃ§Ã£o do programa serÃ¡ 50 segundos * 0.6 = 30 segundos. \n\nAssim, a alternativa correta Ã© 'C) a) T = 75 segundos e b) 30 segundos.'"
  },
  {
    "edicao": 2018,
    "id": "2018-70",
    "numero": 70,
    "enunciado": "Considere as assertivas abaixo sobre teste de sistema:\nï‚· O teste de ______________ tem por objetivo fazer o software falhar de diferentes maneiras, a\nfim de verificar a capacidade de recuperaÃ§Ã£o do software a um estado normal de funcionamento.\nï‚· O teste de ______________ exercita o sistema de forma a observar seu desempenho em\nsituaÃ§Ãµes de demanda anormal de recursos, quer em termos de quantidade, frequÃªncia ou\nvolume.\nï‚· O teste ___________ exercita o software em cada ambiente ou plataforma no qual deve\nfuncionar. TambÃ©m pode incluir examinar os procedimentos de instalaÃ§Ã£o, softwares para a\ninstalaÃ§Ã£o (e.g. instaladores), e a documentaÃ§Ã£o usada para apresentar o software ao usuÃ¡rio.\nAssinale a alternativa que preenche, correta e respectivamente, as lacunas das assertivas acima.",
    "alternativas": [
      "a) recuperaÃ§Ã£o â€“ stress â€“ de implantaÃ§Ã£o",
      "b) seguranÃ§a â€“ stress â€“ beta",
      "c) recuperaÃ§Ã£o â€“ carga â€“ de implantaÃ§Ã£o",
      "d) seguranÃ§a â€“ carga â€“ de implantaÃ§Ã£o",
      "e) recuperaÃ§Ã£o â€“ stress â€“ beta"
    ],
    "area_conhecimento": "Tecnologia de ComputaÃ§Ã£o",
    "area": "Engenharia de Software",
    "subarea": "VerificaÃ§Ã£o, ValidaÃ§Ã£o e Teste",
    "dificuldade": "FÃ¡cil",
    "gabarito": "A",
    "solucao": "Para resolver a questÃ£o, precisamos identificar os tipos de testes mencionados nas assertivas e preencher as lacunas corretamente. A primeira assertiva descreve um teste que visa verificar a capacidade de recuperaÃ§Ã£o do software, o que se refere ao 'teste de recuperaÃ§Ã£o'. A segunda assertiva menciona a avaliaÃ§Ã£o do desempenho do sistema sob demanda anormal de recursos, o que Ã© caracterÃ­stico do 'teste de stress'. A terceira assertiva fala sobre testar o software em diferentes ambientes ou plataformas, o que corresponde ao 'teste de implantaÃ§Ã£o'. Portanto, a alternativa correta que preenche as lacunas Ã© a 'A) recuperaÃ§Ã£o â€“ stress â€“ de implantaÃ§Ã£o'."
  }
]